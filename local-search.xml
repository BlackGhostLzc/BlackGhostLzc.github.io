<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/"/>
    <url>/2023/08/02/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ul><li>Shell</li><li>xv6 shell 代码讲解</li></ul><h3 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell"></a>什么是 shell</h3><ul><li>os &#x3D; API + 对象<blockquote><p>人不可能直接使用系统调用来使用操作系统，所以人和操作系统之间隔了一个应用程序，这个应用程序就叫 shell。shell 把内核的 API 和对象做一层封装，来帮助用户管理操作系统对象的一个<strong>应用程序</strong> 。<br>有 graphic shell 和 command line shell。</p></blockquote></li></ul><h3 id="shell-编程语言"><a href="#shell-编程语言" class="headerlink" title="shell 编程语言"></a>shell 编程语言</h3><ul><li>基于文本替换的快速工作流搭建<blockquote><p>再把 shell 命令构建成一棵树，解释为一组系统调用。</p></blockquote></li></ul><ol><li>重定向: cmd &gt; file &lt; file 2&gt; &#x2F;dev&#x2F;null</li><li>顺序结构: cmd1; cmd2, cmd1 &amp;&amp; cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量&#x2F;环境变量、控制流……</li></ol><ul><li>Job control<br>类比窗口管理器里的 “叉”、“最小化”<br>jobs, fg, bg, wait<br>(今天的 GUI 并没有比 CLI 多做太多事)<blockquote><p>例如用 jobs 查看所有的进程，用 fg 命令使该进程变成前台进程等等。</p></blockquote></li></ul><h3 id="复刻经典"><a href="#复刻经典" class="headerlink" title="复刻经典"></a>复刻经典</h3><p>一个简单地 shell 的实现<br>推荐阅读网站源代码。</p><h3 id="管道的一些细节"><a href="#管道的一些细节" class="headerlink" title="管道的一些细节"></a>管道的一些细节</h3><ul><li>在gdb中如何调试会产生子进程(多进程)的程序？</li></ul><ol><li>set follow-fork-mode child<blockquote><p>这可以在 fork 后直接切到子进程执行流。</p></blockquote></li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> follow-fork-mode <span class="hljs-comment">child</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">detach-on-fork off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">follow-exec-mode same</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">confirm off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">pagination off</span><br>source <span class="hljs-comment">visualize.py</span><br>break <span class="hljs-comment">_start</span><br>run<br>n <span class="hljs-comment">2</span><br>define <span class="hljs-comment">hook-stop</span><br>    pdump<br>end<br></code></pre></td></tr></table></figure><ol start="2"><li><p>info inferiors 命令查看 gdb中的进程</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Num  <span class="hljs-keyword">Description</span>       Executable<br><span class="hljs-number">1</span>    process <span class="hljs-number">1234</span>      <span class="hljs-regexp">/path/</span>to/parent<br><span class="hljs-number">2</span>    process <span class="hljs-number">5678</span>      <span class="hljs-regexp">/path/</span>to/child<br></code></pre></td></tr></table></figure></li><li><p>inferior 命令切换进程</p><blockquote><p>例如 inferior 1</p></blockquote></li></ol><ul><li><p>利用好工具，定制化的gdb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        <span class="hljs-built_in">print</span>()<br>    <br>        <span class="hljs-keyword">for</span> proc <span class="hljs-keyword">in</span> gdb.inferiors():<br>            pid = proc.pid<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(pid) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>    <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process <span class="hljs-subst">&#123;proc.num&#125;</span> (<span class="hljs-subst">&#123;pid&#125;</span>)&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">if</span> proc <span class="hljs-keyword">is</span> gdb.selected_inferior():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>()<br>    <br>            <span class="hljs-keyword">for</span> fd_desc <span class="hljs-keyword">in</span> subprocess.check_output(<br>                [<span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-string">&#x27;-l&#x27;</span>, <span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/fd&#x27;</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>            ).splitlines()[<span class="hljs-number">1</span>:]:<br>                perm, *_, fd, _, fname = fd_desc.split()<br>    <br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;rw&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;-&gt;&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;r&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;--&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;w&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;--&gt;&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;pipe:&#x27;</span> <span class="hljs-keyword">in</span> fname:<br>                    pipe_id = re.search(<span class="hljs-string">f&#x27;[0-9]+&#x27;</span>, fname).group()<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> [=== <span class="hljs-subst">&#123;pipe_id&#125;</span> ===]&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> <span class="hljs-subst">&#123;fname&#125;</span>&#x27;</span>)<br><br>ProcDump()<br><br><br></code></pre></td></tr></table></figure><blockquote><p>这个类继承自gdb.Command类，这个类是一个GDB命令的基类，用于创建新的GDB命令。在这个类的构造函数中，调用了父类的构造函数，并传入了三个参数，分别是”pdump”，gdb.COMMAND_DATA和gdb.COMPLETE_SYMBOL。其中，”pdump”是命令名称，gdb.COMMAND_DATA表示这是一个处理数据的命令，gdb.COMPLETE_SYMBOL表示这个命令需要在符号表中进行自动补全。<br>在你的代码中，你需要在ProcDump类中实现一个名为invoke的方法，这个方法将会被调用来执行pdump命令的实际功能。</p></blockquote></li><li><p>init.gdb脚本<br>init.gdb脚本是一个GDB初始化脚本，它会在GDB启动时自动执行。你可以在这个脚本中设置GDB的一些默认行为，例如设置别名、定义宏、加载符号表等。这个脚本可以包含任意数量的GDB命令，它们会按照在脚本中出现的顺序依次执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">gdb +x <span class="hljs-keyword">init</span>.gdb a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 &#x2F;dev&#x2F;pts ?</p><blockquote><p>&#x2F;dev&#x2F;pts是一个特殊的文件系统，它提供了一个伪终端（pseudo-terminal）接口，允许用户与计算机进行交互。当用户登录到计算机时，系统会为该用户分配一个伪终端，这个伪终端就会在&#x2F;dev&#x2F;pts目录下创建一个对应的设备文件。</p></blockquote></li></ul><p>echo hello &gt; &#x2F;dev&#x2F;pts&#x2F;8 会发生什么</p><blockquote><p>会在相应终端产生输出。使用 tty 命令可以查看当前 shell 终端对应的终端文件是哪一个。</p></blockquote><ul><li><p>说明<br>由于这里文件描述符的应用我在 MIT 6.S081 中的实验1中实现过类似的，所以在这里不再详细地描述调代码的细节。</p></li><li><p>关于 va_list</p><ol><li>va_start sets arg_ptr to the first optional argument in the list of arguments that’s passed to the function.</li><li>va_arg retrieves a value of type from the location that’s given by arg_ptr, and increments arg_ptr to point to the next argument in the list by using the size of type to determine where the next argument starts. </li><li>va_end resets the pointer to NULL</li></ol></li></ul><p>是不是似乎好像会实现 printf 函数了。</p>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/08/02/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FAPI/"/>
    <url>/2023/08/02/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FAPI/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/08/02/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器"><a href="#IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器" class="headerlink" title="IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器"></a>IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器</h3><ul><li>就是“几组约定好功能的线”，通过握手信号从线上读出&#x2F;写入数据</li><li>每一组线都有自己的地址<blockquote><p>CPU可以直接使用指令(in&#x2F;out&#x2F;MMIO)和设备交换数据<br>CPU不管设备具体是如何实现的</p></blockquote></li></ul><h3 id="总线、中断控制器和DMA"><a href="#总线、中断控制器和DMA" class="headerlink" title="总线、中断控制器和DMA"></a>总线、中断控制器和DMA</h3><p>越来越多的IO设备，如何给未来留出一点空间？</p><ul><li>CPU只直接连接一个设备，这个IO设备实际上是一块板卡，板卡上有很多个小插槽(寄存器)。这个IO设备负责管理其他IO设备，这个设备就叫做总线。</li><li>甚至这个IO设备做得更彻底一点，我们的内存也连接在这个总线上，同一个地址空间，CPU只需要一个地址，就可以知道访问的是内存还是IO设备(统一编址)。</li></ul><h3 id="中断没能解决的"><a href="#中断没能解决的" class="headerlink" title="中断没能解决的"></a>中断没能解决的</h3><p>假设程序希望写入1GB的数据到磁盘</p><ul><li>即使磁盘已经准备好了，依然需要非常浪费时间的循环。<blockquote><p>DMA的出现：一个专门执行”memcpy”程序的CPU<br>通过增加一个CPU专门负责从内存到总线的数据搬运<br>memory-&gt;memory     device-&gt;memory    memory-&gt;device</p></blockquote></li></ul><h3 id="IO设备和计算机之间的边界逐渐模糊"><a href="#IO设备和计算机之间的边界逐渐模糊" class="headerlink" title="IO设备和计算机之间的边界逐渐模糊"></a>IO设备和计算机之间的边界逐渐模糊</h3><p>DMA不就是一个“只做一件特别事情的”CPU吗</p><ul><li>那么我们还可以有做各种事情的”CPU”啊, 例如显卡</li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课的主要内容"><a href="#本次课的主要内容" class="headerlink" title="本次课的主要内容"></a>本次课的主要内容</h2><ul><li>什么是设备驱动程序</li><li>Linux设备抽象</li></ul><h3 id="设备驱动程序原理"><a href="#设备驱动程序原理" class="headerlink" title="设备驱动程序原理"></a>设备驱动程序原理</h3><ul><li>设备其实是一组寄存器和一组协议，一个设备，一个协议</li></ul><p>设备可以分为两种</p><ol><li>字符设备：字节流，例如键盘</li><li>块设备：字节数组，例如磁盘</li></ol><h3 id="操作系统：设备-支持各类操作的对象（文件）"><a href="#操作系统：设备-支持各类操作的对象（文件）" class="headerlink" title="操作系统：设备&#x3D;支持各类操作的对象（文件）"></a>操作系统：设备&#x3D;支持各类操作的对象（文件）</h3><ul><li>read: 从设备某个指定的位置读出数据</li><li>write：向设备某个位置写入数据</li><li>ioctl: 读取&#x2F;设置设备的状态, ioctl是一个系统调用<br>上面为设备建立一个模型       <blockquote><p>也就是说，把上面这三个系统调用，也就是通用的API，经过设备驱动程序，翻译成设备能够听得懂的语言, 这段代码就是设备驱动程序。</p></blockquote></li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>把系统调用“翻译”成与设备寄存器的交互</p><ul><li>就是一段普通的内核代码</li><li>有可能这个设备驱动程序后面就是一个真实的设备，有可能没有设备，就是用设备驱动程序来模拟这个设备</li></ul><p>例如：&#x2F;dev&#x2F;中的对象</p><ol><li>&#x2F;dev&#x2F;null   null设备</li><li>&#x2F;dev&#x2F;random   随机数生成器</li></ol><h3 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h3><p>我们希望实现一个最简单的“软件定义核弹”</p>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/"/>
    <url>/2023/08/02/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="虚拟化：操作系统同时保存多个状态机"><a href="#虚拟化：操作系统同时保存多个状态机" class="headerlink" title="虚拟化：操作系统同时保存多个状态机"></a>虚拟化：操作系统同时保存多个状态机</h3><p>C程序 &#x3D; 状态机</p><ul><li>初始状态： main(argc, argv)</li><li>状态迁移： 指令的执行，包括syscall</li></ul><p>实际上，在 UNIX&#x2F;Linux 系统内核完成初始化后，只有一个 init 进程被启动，从此以后，操作系统内核就化身为了一个事件驱动的程序、状态机的管理者，仅在中断和系统调用发生时开始执行。</p><p>下面看一段小代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写出代码的运行结果。</p></blockquote><ul><li>.&#x2F;a.out</li><li>.&#x2F;a.out | cat</li></ul><ol><li>当执行.&#x2F;a.out时，会打印 6 个 Hello</li><li>当执行.&#x2F;a.out | wc -l 时，会打印 8 个 Hello ? 这是为什么呢？</li></ol><p>不妨用 strace 来看一下。<br>我们发现，</p><blockquote><p>我们的 printf 不总是打印到标准输出的。也就是说它根据标准输出连接的是终端还是管道，它会做不同的行为，这里连接到了管道，也就把输出放到一个缓冲区里面 。当第一个循环之后，缓冲区里面有一个 hello，有两个进程；第二次循环完毕后，缓冲区里面有 2 个 hello, 总共 4 个进程。所以打印 8 个。 </p></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>应用程序执行的环境。</p><ul><li>export: 告诉shell在创建子进程的时候设置环境变量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="可执行文件：状态机的描述"><a href="#可执行文件：状态机的描述" class="headerlink" title="可执行文件：状态机的描述"></a>可执行文件：状态机的描述</h2><h3 id="一个描述了状态机初始状态-迁移的数据结构"><a href="#一个描述了状态机初始状态-迁移的数据结构" class="headerlink" title="一个描述了状态机初始状态 + 迁移的数据结构"></a>一个描述了状态机初始状态 + 迁移的<font color=#FF000 >数据结构</font></h3><ol><li>寄存器：大部分由ABI规定，操作系统负责设置。例如初始化pc。</li><li>地址空间：二进制文件+ABI共同决定。例如argv和envp的存储。</li><li>其他有用的信息（例如调试和core dump的信息）</li></ol><hr><h2 id="可执行文件里面应该有什么？"><a href="#可执行文件里面应该有什么？" class="headerlink" title="可执行文件里面应该有什么？"></a>可执行文件里面应该有什么？</h2><p>可执行程序描述了状态机重置后的状态，那状态有什么呢？</p><blockquote><p>无非就是寄存器和内存（地址空间）</p></blockquote><hr><h2 id="操作系统上的可执行程序"><a href="#操作系统上的可执行程序" class="headerlink" title="操作系统上的可执行程序"></a>操作系统上的可执行程序</h2><p>需要满足以下条件：</p><ol><li><p>具有执行(x)权限<br>执行.&#x2F;a.c命令 (出现permission denied错误)<br>但如果先执行 chmod +x a.c命令，会出现加载器不能正确识别题。    </p></li><li><p>加载器能够识别的可执行文件</p></li></ol><hr><h2 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h2><blockquote><p>就是操作系统里面的一个普通对象。</p></blockquote><h3 id="UNIX-Linux"><a href="#UNIX-Linux" class="headerlink" title="UNIX&#x2F;Linux"></a>UNIX&#x2F;Linux</h3><ul><li>a.out</li><li>ELF</li><li>She-bang<blockquote><p>She-bang是什么呢？其实就是一个“偷换参数”地execve。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">#!/usr/bin/python3               #这是一个可执行文件<br>print(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再执行命令 chmod +x a.c。上面这个文件就可以执行了。<br>如果加载器这样一个程序的时候，如果它发现一个#!开头的，就会在execve偷换一下，把#!后面的填入execve的第一个参数，该文件名填入第二个参数。</p><hr><h2 id="从C代码到二进制文件"><a href="#从C代码到二进制文件" class="headerlink" title="从C代码到二进制文件"></a>从C代码到二进制文件</h2><p>一段简单的C代码(main.c)：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    hello();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>gcc -O2 -c main.c得到main.o文件, 然后objdump -d main.o得到反汇编 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-number">0</span>:   f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa             endbr64 <br>   <span class="hljs-number">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>             sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">8</span>:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>   a:   e8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   f &lt;main+<span class="hljs-number">0xf</span>&gt;<br>   f:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>  <span class="hljs-number">11</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>             add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">15</span>:   c3                      ret    <br></code></pre></td></tr></table></figure><p>我们可以看到 0xa 地址处，由于不知道hello函数的地址，这里暂时填为 0</p><p>hello.c的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xa</span> + <span class="hljs-number">1</span>;   <span class="hljs-comment">//有上面汇编代码可以看出，代填 </span><br>               <span class="hljs-comment">//hello地址为 main 的地址加上偏移再加上1(操作码1个字节)</span><br>    <span class="hljs-type">int32_t</span> offset = *(<span class="hljs-type">int32_t</span>*)p;<br>    assert( (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xf</span> +offset == (<span class="hljs-type">char</span>*)hello);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下：在我们的main函数要调用hello函数时，此时pc会指向这条call指令的下一条指令的地址，也就是pc指针会是(char*)main + 0xf,由于是相对寻址(call指令的语义)，所以会跳转到pc + offset的位置，offset也就是待填地址处的值。而跳转后的地址要是hello的地址。</p></blockquote><p>我们 readelf -a main.o 来看一下有什么输出信息,其中有一部分是这样的（这里复制过来格式有点不正确）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Relocation</span> section &#x27;.rela.text.startup&#x27; at offset <span class="hljs-number">0</span>x1b8 contains <span class="hljs-number">1</span> entry:<br>  <span class="hljs-attribute">Offset</span>          Info       Type        Sym. Value    Sym. Name+Addend<br><span class="hljs-attribute">00000000000b</span>  <span class="hljs-number">000600000004</span> R_X86_64_PLT32 <span class="hljs-number">0000000000000000</span> hello - <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="重新理解编译、链接流程"><a href="#重新理解编译、链接流程" class="headerlink" title="重新理解编译、链接流程"></a>重新理解编译、链接流程</h2><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><blockquote><p>High-level semantics(高级C状态机) -&gt; Low-level semantics(汇编状态机)</p></blockquote><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><blockquote><p>Low-level semantics -&gt; Binary semantics(状态机的容器)</p></blockquote><ol><li>“一一对应”地翻译成二进制代码，sections, symbols, debug info……</li><li>不能决定的要留下“之后要怎么办”的信息(relocations重定位)</li></ol><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><blockquote><p>合并所有的容器，得到一个完整的状态机</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/2023/08/02/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：多处理器编程：从入门到放弃："><a href="#本讲内容：多处理器编程：从入门到放弃：" class="headerlink" title="本讲内容：多处理器编程：从入门到放弃："></a>本讲内容：多处理器编程：从入门到放弃：</h2><ul><li>入门：多线程编程库</li><li>放弃：原子性、可见性、顺序</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>每个线程都有自己的堆栈，如何确定各自的堆栈大小？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> low[<span class="hljs-number">64</span>];<br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> high[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_range</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">void</span> *ptr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ptr &lt; low[T]) low[T] = ptr;<br>    <span class="hljs-keyword">if</span> (ptr &gt; high[T]) high[T] = ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">probe</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">int</span> n)</span> &#123;<br>  update_range(T, &amp;n);<br>  <span class="hljs-type">long</span> sz = (<span class="hljs-type">uintptr_t</span>)high[T] - (<span class="hljs-type">uintptr_t</span>)low[T];<br>  <span class="hljs-keyword">if</span> (sz % <span class="hljs-number">1024</span> &lt; <span class="hljs-number">32</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack(T%d) &gt;= %ld KB\n&quot;</span>, T, sz / <span class="hljs-number">1024</span>);<br>  &#125;<br>  probe(T, n + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Infinite recursion</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tprobe</span><span class="hljs-params">(<span class="hljs-type">int</span> T)</span> &#123;<br>  low[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;<br>  high[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>  update_range(T, &amp;T);<br>  probe(T, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    create(Tprobe);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要 setbuf(stdout, NULL) 关闭缓冲区？</p><blockquote><p>有时候一个printf明明在crash前的代码运行了，但没有得到输出，原因是什么呢？<br>是因为printf先把输出放在缓冲区里。</p></blockquote><p>这段代码的核心思想就是无穷递归，利用函数参数存储在栈空间里估算栈的大小。</p><h2 id="放弃：原子性"><a href="#放弃：原子性" class="headerlink" title="放弃：原子性"></a>放弃：原子性</h2><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100000000</span><br><br><span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tsum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    sum++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  create(Tsum);<br>  create(Tsum);<br>  join();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %ld\n&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译优化 -O2得到答案 200000000</p><blockquote><p>编译器直接计算出答案，一条指令赋值给sum</p></blockquote><p>编译优化 -O1得到答案 100000000</p>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/"/>
    <url>/2023/08/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="动态链接与加载原理"><a href="#动态链接与加载原理" class="headerlink" title="动态链接与加载原理"></a>动态链接与加载原理</h2><h3 id="若干要素"><a href="#若干要素" class="headerlink" title="若干要素"></a>若干要素</h3><ol><li>编译成位置无关代码</li><li>对外部函数的调用是查表的</li><li>在运行（加载）的时候填表</li></ol><p>我们就发明了GOT(Global Offset Table)</p><blockquote><p>也就是table </p></blockquote><h3 id="有个有趣的问题"><a href="#有个有趣的问题" class="headerlink" title="有个有趣的问题"></a>有个有趣的问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>; <br></code></pre></td></tr></table></figure><p>编译器遇到函数调用，应该翻译成哪种指令？</p><ul><li>如果是同一个动态链接库    call foo   (因为如果是一个库的，链接的时候相对地址已经确定下来了)</li><li>如果是另外一个动态链接库  call TABLE(foo)</li></ul><p>这就需要PLT (Procedure Linkage Table)       </p><ul><li>函数太多，每个都标记区分太难看</li><li>编译器总是生成一个直接的call<blockquote><p>来自另一个动态链接库     call foo@plt            </p></blockquote></li></ul><h3 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h3><p>对于一个动态链接的二进制文件，execve后的第一条指令在哪里？</p><ul><li>what are the first a few steps executed after execve() of a ELF dynamic link binary?  (Chatgpt)</li></ul><blockquote><p>第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2   _start函数<br>也就是说，刚刚执行玩execve后，我们的pc指针指向了ld.so中的代码。</p></blockquote><ol><li>首先会加载这个ELF文件，把相关的段加载进地址空间中。</li><li>内核会根据查看程序头表(program header)中的PT_INTERP的判断是否需要动态链接。如果需要，内核就会把动态链接器(通常来说是ld-linux.so)加载进进程的地址空间中。</li><li>设置栈的初始状态。</li><li>把控制交给动态链接器：内核把pc指针设置为动态链接器的入口地址。</li><li>动态链接器的初始化，解析符号，重定位等。</li><li>把控制权交给程序(通常来说是_start函数)</li></ol><ul><li>How can I compile an ELF binary that use an alternative dynamic loader than the default ld.so?（能否替换这个加载器） <blockquote><p>gcc -o hello hello.c -Wl, –dynamic-linker&#x3D;&#x2F;path&#x2F;to&#x2F;my_ld.so<br>readelf -l hello | grep “program interpreter” 查看可执行文件的动态链接器</p></blockquote></li></ul><p>示例代码<br>ld.S  ——  将来链接成动态链接库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br>.globl _start<br>_start:<br>  movq $SYS_write, %rax   <span class="hljs-comment">// write(</span><br>  movq $<span class="hljs-number">1</span>,         %rdi   <span class="hljs-comment">//   fd=1,</span><br>  lea  <span class="hljs-title function_">st</span><span class="hljs-params">(%rip)</span>,   %rsi   <span class="hljs-comment">//   buf=st,</span><br>  movq $<span class="hljs-params">(ed - st)</span>, %rdx   <span class="hljs-comment">//   count=ed-st</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>  movq $SYS_exit,  %rax   <span class="hljs-comment">// exit(</span><br>  movq $1,         %rdi   <span class="hljs-comment">//   status=1</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>st:<br>  .ascii &quot;\033[01;<span class="hljs-number">31</span>mThis is a loader.\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m\n<span class="hljs-string">&quot;</span><br><span class="hljs-string">ed:</span><br></code></pre></td></tr></table></figure><p>hello.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld<span class="hljs-selector-class">.so</span>: ld<span class="hljs-selector-class">.S</span> hello<span class="hljs-selector-class">.c</span><br>gcc -fPIC -shared -c ld<span class="hljs-selector-class">.S</span><br>ld -shared ld<span class="hljs-selector-class">.o</span> -o ld<span class="hljs-selector-class">.so</span><br>gcc hello<span class="hljs-selector-class">.c</span> -Wl,<span class="hljs-attr">--dynamic-linker</span>=$(PWD)/ld.so<br></code></pre></td></tr></table></figure><ul><li>当我们输入make指令并执行 .&#x2F;a.out 时，我们看到，我们并没有输出Hello,而是输出了This is a loader. 这也就说明了我们的动态链接器确实换掉了，由于hello.c是动态链接的，所以内核会加载我们自己的动态链接器并执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/"/>
    <url>/2023/08/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课要回答的问题"><a href="#本次课要回答的问题" class="headerlink" title="本次课要回答的问题"></a>本次课要回答的问题</h2><ol><li>可执行文件是如何被操作系统加载的</li><li>什么是动态链接&#x2F;动态加载</li></ol><h2 id="静态ELF加载器：实现"><a href="#静态ELF加载器：实现" class="headerlink" title="静态ELF加载器：实现"></a>静态ELF加载器：实现</h2><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><ol><li>解析数据结构 + 复制到内存 + 跳转</li><li>创建进程运行时的初始状态(argv,envp,…)</li></ol><h3 id="loader-static-c"><a href="#loader-static-c" class="headerlink" title="loader-static.c"></a>loader-static.c</h3><ol><li>可以加载任何静态链接的代码, minimal.S, dfs-fork.c</li><li>并可以正确处理参数&#x2F;环境变量 env.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STK_SZ           (1 &lt;&lt; 20)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROUND(x, align)  (void *)(((uintptr_t)x) &amp; ~(align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD(x, align)    (((uintptr_t)x) &amp; (align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> push(sp, T, ...) (&#123; *((T*)sp) = (T)__VA_ARGS__; sp = (void *)((uintptr_t)(sp) + sizeof(T)); &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">execve_</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-comment">// WARNING: This execve_ does not free process resources.</span><br>  <span class="hljs-type">int</span> fd = open(file, O_RDONLY);<br>  assert(fd &gt; <span class="hljs-number">0</span>);<br>  Elf64_Ehdr *h = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  assert(h != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>  assert(h-&gt;e_type == ET_EXEC &amp;&amp; h-&gt;e_machine == EM_X86_64);<br><br>  Elf64_Phdr *pht = (Elf64_Phdr *)((<span class="hljs-type">char</span> *)h + h-&gt;e_phoff);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;e_phnum; i++) &#123;<br>    Elf64_Phdr *p = &amp;pht[i];<br>    <span class="hljs-keyword">if</span> (p-&gt;p_type == PT_LOAD) &#123;<br>      <span class="hljs-type">int</span> prot = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_R) prot |= PROT_READ;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_W) prot |= PROT_WRITE;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_X) prot |= PROT_EXEC;<br>      <span class="hljs-type">void</span> *ret = mmap(<br>        ROUND(p-&gt;p_vaddr, p-&gt;p_align),              <span class="hljs-comment">// addr, rounded to ALIGN</span><br>        p-&gt;p_memsz + MOD(p-&gt;p_vaddr, p-&gt;p_align),   <span class="hljs-comment">// length</span><br>        prot,                                       <span class="hljs-comment">// protection</span><br>        MAP_PRIVATE | MAP_FIXED,                    <span class="hljs-comment">// flags, private &amp; strict</span><br>        fd,                                         <span class="hljs-comment">// file descriptor</span><br>        (<span class="hljs-type">uintptr_t</span>)ROUND(p-&gt;p_offset, p-&gt;p_align)); <span class="hljs-comment">// offset</span><br>      assert(ret != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(p-&gt;p_vaddr + p-&gt;p_filesz), <span class="hljs-number">0</span>, p-&gt;p_memsz - p-&gt;p_filesz);<br>    &#125;<br>  &#125;<br>  close(fd);<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STK_SZ], rnd[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">void</span> *sp = ROUND(<span class="hljs-built_in">stack</span> + <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>) - <span class="hljs-number">4096</span>, <span class="hljs-number">16</span>);<br>  <span class="hljs-type">void</span> *sp_exec = sp;<br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// argc</span><br>  <span class="hljs-keyword">while</span> (argv[argc]) argc++;<br>  push(sp, <span class="hljs-type">intptr_t</span>, argc);<br>  <span class="hljs-comment">// argv[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= argc; i++)<br>    push(sp, <span class="hljs-type">intptr_t</span>, argv[i]);<br>  <span class="hljs-comment">// envp[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (; *envp; envp++) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strchr</span>(*envp, <span class="hljs-string">&#x27;_&#x27;</span>)) <span class="hljs-comment">// remove some verbose ones</span><br>      push(sp, <span class="hljs-type">intptr_t</span>, *envp);<br>  &#125;<br>  <span class="hljs-comment">// auxv[], AT_NULL-terminate</span><br>  push(sp, <span class="hljs-type">intptr_t</span>, <span class="hljs-number">0</span>);<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_RANDOM, .a_un.a_val = (<span class="hljs-type">uintptr_t</span>)rnd &#125; );<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_NULL &#125; );<br><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov $0, %%rdx;&quot;</span> <span class="hljs-comment">// required by ABI</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov %0, %%rsp;&quot;</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;jmp *%1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span>(sp_exec), <span class="hljs-string">&quot;b&quot;</span>(h-&gt;e_entry))</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s file [args...]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  execve_(argv[<span class="hljs-number">1</span>], argv + <span class="hljs-number">1</span>, envp);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下我们这里的loader(它是动态链接的): 给我们的loader传入一个参数,它执行到某一个状态的时候，把我们的ELF文件(argv[1])搬到我们的loader程序的状态上,相当于我们的程序被替换了,但这个过程并没有执行execve,只是简单地用mmap系统调用(当然操作系统加载loader这个程序的时候会用execve)。</p></blockquote></li></ol><h3 id="初始化堆栈"><a href="#初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><p>状态机是well-defined的。</p><table><thead><tr><th>表头</th><th>表头</th><th>长度(字节)</th></tr></thead><tbody><tr><td>其他信息</td><td></td><td>未知</td></tr><tr><td>Null auxiliary vector entry</td><td></td><td>1 eightbyte each</td></tr><tr><td>Auxiliary vector entries</td><td></td><td>2 eightbytes each</td></tr><tr><td>0</td><td></td><td>8</td></tr><tr><td>Environment pointers</td><td></td><td>8 bytes each</td></tr><tr><td>0</td><td>8 + 8*argc + %rsp</td><td>8</td></tr><tr><td>Argument pointers</td><td>8 + %rsp</td><td>argc 8</td></tr><tr><td>Argument count</td><td>%rsp</td><td>8</td></tr><tr><td>Undefined</td><td>Low Address</td><td></td></tr></tbody></table><h3 id="有趣之处"><a href="#有趣之处" class="headerlink" title="有趣之处"></a>有趣之处</h3><blockquote><p>这是在操作系统上实现的。用 open , mmap, close实现了一个 execve。     </p></blockquote><hr><h2 id="动态链接和加载"><a href="#动态链接和加载" class="headerlink" title="动态链接和加载"></a>动态链接和加载</h2><h3 id="为什么要动态加载"><a href="#为什么要动态加载" class="headerlink" title="为什么要动态加载"></a>为什么要动态加载</h3><ol><li>减少库函数的磁盘和内存拷贝</li></ol><ul><li>每个可执行文件里面都有所有的库函数拷贝那也太浪费了</li><li>只要遵守约定，不挑战库函数的版本(否则发布一个新版本就要重新编译全部程序)</li></ul><h3 id="这就有了”拆解应用程序”的需求"><a href="#这就有了”拆解应用程序”的需求" class="headerlink" title="这就有了”拆解应用程序”的需求"></a>这就有了”拆解应用程序”的需求</h3><blockquote><p>随着库函数越来越大，希望项目能够运行时链接。</p></blockquote><h3 id="动态链接，但不讲ELF-换一种方法。"><a href="#动态链接，但不讲ELF-换一种方法。" class="headerlink" title="动态链接，但不讲ELF,换一种方法。"></a>动态链接，但不讲ELF,换一种方法。</h3><ul><li>如果编译器、链接器、加载器都受你控制</li><li>那你怎么设计实现一个“最直观”的动态链接格式？</li><li>如何改进，就得到了ELF！</li><li>假设编译器可以为你生成位置无关代码(PIC)</li></ul><h3 id="来看一下蒋神的设计-main-part"><a href="#来看一下蒋神的设计-main-part" class="headerlink" title="来看一下蒋神的设计(main part)"></a>来看一下蒋神的设计(main part)</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul><li>dl.h(数据结构定义)</li></ul><h4 id="全家桶工具集"><a href="#全家桶工具集" class="headerlink" title="全家桶工具集"></a>全家桶工具集</h4><ul><li>dlbox.c(gcc, readdl, objdump, interp)</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>libc.S - 提供 putchar 和 exit</li><li>libhello.S - 调用 putchar, 提供 hello</li><li>main.S - 调用 hello, 提供 main</li></ul><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o dlbox dlbox<span class="hljs-selector-class">.c</span><br>./dlbox gcc libc<span class="hljs-selector-class">.S</span><br>./dlbox gcc libhello<span class="hljs-selector-class">.S</span><br>./dlbox gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.S</span><br>./dlbox readdl libc<span class="hljs-selector-class">.dl</span>         <span class="hljs-comment">//readelf</span><br></code></pre></td></tr></table></figure><blockquote></blockquote><p>会生成.dl格式的自定义可执行文件。这个可执行文件是不可以在操作系统上执行，需要自己的加载器。<br>并且我们的加载器是在当前目录中动态加载.dl文件(根据)的，如果先前没有生成所需要的.dl文件的话，我们的加载器会出现错误。</p><blockquote></blockquote><h4 id="演示一下下"><a href="#演示一下下" class="headerlink" title="演示一下下"></a><strong>演示一下下</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br>DL_HEAD<br><br><span class="hljs-title function_">LOAD</span><span class="hljs-params">(<span class="hljs-string">&quot;libc.dl&quot;</span>)</span><br><span class="hljs-title function_">IMPORT</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br><span class="hljs-title function_">EXPORT</span><span class="hljs-params">(hello)</span><br><br>DL_CODE<br><br>hello:<br>  lea <span class="hljs-title function_">str</span><span class="hljs-params">(%rip)</span>, %rdi<br>  mov <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span>, %eax<br>  push %rbx<br>  mov %rdi, %rbx<br>  inc %eax<br>  mov %eax, <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span><br>  add $0x30, %eax<br>  movb %al, 0<span class="hljs-title function_">x6</span><span class="hljs-params">(%rdi)</span><br>loop:<br>  <span class="hljs-title function_">movsbl</span> <span class="hljs-params">(%rbx)</span>,%edi<br>  test %dil,%dil<br>  je out<br>  call <span class="hljs-title function_">DSYM</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br>  inc  %rbx<br>  jmp loop<br>out:<br>  pop %rbx<br>  ret<br><br>str:<br>  .asciz &quot;Hello X\n&quot;<br><br>count:<br>  .<span class="hljs-type">int</span> 0<br><br>DL_END<br><br></code></pre></td></tr></table></figure><blockquote><p>这个文件需要使用外部的putchar函数,所以需要call DSYM(putchar), DSYM表示动态链接的，也需要手动指明putchar函数所在的库libc.dl。它定义有一个hello函数，所以需要导出。也就是EXPORT(hello).</p></blockquote><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><ol><li><p><strong>首先来看一下dl.h文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REC_SZ 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_MAGIC <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ASSEMBLER__</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_HEAD     __hdr: \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* magic */</span>    .ascii DL_MAGIC; \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* file_sz */</span>  .4byte (__end - __hdr); \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* code_off */</span> .4byte (__code - __hdr)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_CODE     .fill REC_SZ - 1, 1, 0; \</span><br><span class="hljs-meta">                      .align REC_SZ, 0; \</span><br><span class="hljs-meta">                      __code:</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_END      __end:</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> RECORD(sym, off, name) \</span><br><span class="hljs-meta">    .align REC_SZ, 0; \</span><br><span class="hljs-meta">    sym .8byte (off); .ascii name</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPORT(sym) RECORD(sym:,           0, <span class="hljs-string">&quot;?&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPORT(sym) RECORD(    , sym - __hdr, <span class="hljs-string">&quot;#&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOAD(lib)   RECORD(    ,           0, <span class="hljs-string">&quot;+&quot;</span> lib  <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DSYM(sym)   *sym(%rip)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> &#123;</span><br>    <span class="hljs-type">char</span> magic[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">uint32_t</span> file_sz, code_off;<br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> &#123;</span><br>    <span class="hljs-type">int64_t</span> offset;<br>    <span class="hljs-type">char</span> type, name[REC_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int64_t</span>) - <span class="hljs-number">1</span>];<br>  &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><blockquote><ol><li>__ASSEMBLER__是一个内置的宏，它由编译器预定义，用于判断当前代码是否为汇编代码。在编写汇编代码时，编译器会自动定义这个宏。</li><li>怎么用汇编语言定义结构体呢？ 为什么变量名前面要加.呢？这表示这是在当前偏移量下定义的。</li><li>RECORD宏定义：.align REC_SZ, 0 表示将当前位置对齐到 REC_SZ 字节边界。<br>这行代码定义了一个标签 sym，并将 off 表示的偏移量存储到该标签处。.8byte 指令告诉汇编器为该标签分配一个 8 字节的存储空间，即使用一个 64 位无符号整数来存储偏移量。<br>.ascii name 表示将 name 参数表示的记录名称作为 ASCII 字符串嵌入到汇编代码中。.ascii 指令用于将一个字符串常量嵌入到汇编代码中。</li><li>#define DSYM(sym)  这是间接跳转，先将 %rip 寄存器中存储的当前指令地址加上 hello 符号相对于当前指令的偏移量，得到函数地址，然后再根据这个地址的值进行跳转，而符号表结构体前八个字节就是函数的地址。</li></ol></blockquote></li><li><p><strong>dlbox.c文件</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">symtab</span>;</span> <span class="hljs-comment">// borrowed spaces from header</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><br><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br><span class="hljs-comment">// Implementation of binutils</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_readdl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DLIB file %s:\n\n&quot;</span>, h-&gt;path);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    LOAD  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  EXTERN  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: <span class="hljs-built_in">printf</span>(   <span class="hljs-string">&quot;%08lx  %s\n&quot;</span>, sym-&gt;offset, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_objdump</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">char</span> *hc = (<span class="hljs-type">char</span> *)h, cmd[<span class="hljs-number">64</span>];<br>  FILE *fp = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Disassembly of binary %s:\n&quot;</span>, h-&gt;path);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> *code = hc + h-&gt;hdr.code_off; code &lt; hc + h-&gt;hdr.file_sz; code++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>      <span class="hljs-keyword">if</span> (hc + sym-&gt;offset == code) &#123;<br>        <span class="hljs-type">int</span> off = code - hc - h-&gt;hdr.code_off;<br>        <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>        <span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">&quot;ndisasm - -b 64 -o 0x%08x\n&quot;</span>, off);<br>        fp = popen(cmd, <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%016x &lt;%s&gt;:\n&quot;</span>, off, sym-&gt;name);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fp) fputc(*code, fp);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>&#125;<br><br><span class="hljs-comment">// binutils: interpreter</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmd</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd;<br>  <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path);<br>&#125; commands[] = &#123;<br>  &#123; <span class="hljs-string">&quot;gcc&quot;</span>,     dl_gcc &#125;,<br>  &#123; <span class="hljs-string">&quot;readdl&quot;</span>,  dl_readdl &#125;,<br>  &#123; <span class="hljs-string">&quot;objdump&quot;</span>, dl_objdump &#125;,<br>  &#123; <span class="hljs-string">&quot;interp&quot;</span>,  dl_interp &#125;,<br>  &#123; <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-literal">NULL</span> &#125;,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;gcc|readdl|objdump|interp&#125; FILE...\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> cmd *cmd = &amp;commands[<span class="hljs-number">0</span>]; cmd-&gt;handler; cmd++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **path = &amp;argv[<span class="hljs-number">2</span>]; *path &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], cmd-&gt;cmd) == <span class="hljs-number">0</span>; path++) &#123;<br>      <span class="hljs-keyword">if</span> (path != argv + <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>      cmd-&gt;handler(*path);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Implementation of dlopen()</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">libs</span>[16], <span class="hljs-title">syms</span>[128];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(syms[i].name, name) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)syms[i].offset;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(libs); i++) &#123;<br>    <span class="hljs-keyword">if</span> (libs[i] &amp;&amp; <span class="hljs-built_in">strcmp</span>(libs[i]-&gt;name, sym-&gt;name) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// already loaded</span><br>    <span class="hljs-keyword">if</span> (!libs[i]) &#123;<br>      libs[i] = sym;<br>      dlopen(sym-&gt;name); <span class="hljs-comment">// load recursively</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="来解释一下-按顺序-："><a href="#来解释一下-按顺序-：" class="headerlink" title="来解释一下(按顺序)："></a>来解释一下(按顺序)：</h3><ol><li><p>首先需要dl_gcc各.S文件得到.dl。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原来命令行还可以这么写！ 前一句生成64位的位置无关代码，然后再把代码段拷贝成.dl文件。这里主要是一些宏替换，并且由于我们的汇编代码格式是很严格地按照dl_hdr的形式写的，所以我们得到的其实是一个dl_lib的结构体。更直观地来感受一下，我们使用命令gcc -E main.S,得到宏替换展开的文件(如下):</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 0 &quot;main.S&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot; 2</span><br><span class="hljs-comment"># 1 &quot;main.S&quot;</span><br><span class="hljs-comment"># 1 &quot;dl.h&quot; 1</span><br><span class="hljs-comment"># 2 &quot;main.S&quot; 2</span><br><br>__hdr: <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__end - __hdr)</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__code - __hdr)</span><br><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libc.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libhello.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; hello: <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(main - __hdr)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;#&quot;</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><br><span class="hljs-string">.fill</span> 32 - 1, 1, 0; <span class="hljs-string">.align</span> 32, 0; __code:<br><br>main:<br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  movq $0, %rax<br>  ret<br><br>__end:<br></code></pre></td></tr></table></figure><blockquote><p>xxd main.dl命令得到二进制文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dotnetcli">00000000: 0114 0514 e000 0000 c000 0000 0000 0000  ................<br>00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 2b6c 6962 632e 646c  ........+libc.dl<br>00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000040: 0000 0000 0000 0000 2b6c 6962 6865 6c6c  ........+libhell<br>00000050: 6f2e 646c 0000 0000 0000 0000 0000 0000  o.dl............<br>00000060: 0000 0000 0000 0000 3f68 656c 6c6f 0000  ........?hello..<br>00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000080: c000 0000 0000 0000 236d 6169 6e00 0000  ........#main...<br>00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000c0: ff15 9aff ffff ff15 94ff ffff ff15 8eff  ................<br>000000d0: ffff ff15 88ff ffff 48c7 c000 0000 00c3  ........H.......<br></code></pre></td></tr></table></figure><blockquote><p>libc.dl、libhello.dl、hello这三个符号都是填零的。只有main函数已经填上了正确的偏移。<br>可以反推，我们得到的.dl文件的格式是这样的：首先是__hdr头，这里有模数，文件的大小，以及代码段的偏移。 然后是符号表；符号表结束后，再32个字节填0作为分界线，然后是代码段。 妙哇妙哇！原来宏定义还可以这么用！</p></blockquote></li><li><p><strong>然后是dl_interp函数来解释执行</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>找到main函数，exit(entry()) 的作用就是在程序结束时执行 main 函数，并将其返回值作为程序的退出码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>这里要打开.dl文件，并且把这个文件用mmap函数映射到dlbox进程的地址空间，此时其他.dl文件的代码段就会映射到dlbox进程的地址空间中，也就可以确定函数的地址了，这也就和动态链接的链接时绑定思想不谋而合。打开这个可执行程序时，h-&gt;symtab &#x3D; (struct symbol *)((char *)h + REC_SZ);这里是初始化符号表。</li><li>如果遇到.dl作为符号表项(‘+’)，则用dlload递归加载，dlload则是调用dlopen实现的。</li><li>如果遇到符号表项的某一项标记位’?’,表示引用外部符号，我们通过查表dlsym函数来填表。</li><li>可以想象，这是一个递归的过程，递归地填表。如果变量是这个main程序的函数(‘#’),我们直接可以确定该函数的地址。也就是表头的地址加上偏移。</li><li>如果这个符号是个.dl文件，则需要调用dlopen把这个文件整体映射进进程的地址空间(递归)，映射完后，所有符号的地址都会被确定，然后我们就可以遍历来填sym表了。这个sym表记录了所有符号，也是一个结构体，一开始所有的项的name字段初始化为NULL。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>如果这个符号是外部的函数，由于我们先包含.dl的库文件，所以外部符号这时候都会解析完毕，我们就可以直接填入正确的地址。</li><li>上面的思想主要是：我们在装载动态库的时候，我们不像静态链接那样可以知道这个模块是装载在哪个位置的。我们的解决方法是通过间接跳转在本模块的某个位置(这是可以确定的)，这个位置就有这个函数的地址的信息。由于我们都是按模块装载的，所以这一点并不难实现，通过添加一个sym的全局变量结构数组，在每装载一个模块(.dl)时，就把该模块的所有这个模块的export类型的变量全部填入这个sym数组中。<br>然后，有了这个sym数组，就可以开始回填到每个模块的符号表中带有(‘?’)的符号offset字段了。</li></ol></blockquote></li></ol><hr><h3 id="反思与改进-最精彩的部分"><a href="#反思与改进-最精彩的部分" class="headerlink" title="反思与改进(最精彩的部分)"></a><strong>反思与改进(最精彩的部分)</strong></h3><h5 id="一些小缺陷"><a href="#一些小缺陷" class="headerlink" title="一些小缺陷"></a>一些小缺陷</h5><ul><li>存储保护和加载位置。允许将.dl中的一部分以某个指定的权限映射到内存的某个位置—&gt;程序头表</li><li>允许自由指定加载器—&gt;加入INTERP</li><li>空间浪费 —&gt;字符串存储在常量池，统一通过“指针”访问(这也是ELF难读的原因)</li></ul><h5 id="另一个大缺陷"><a href="#另一个大缺陷" class="headerlink" title="另一个大缺陷"></a>另一个大缺陷</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>一种写法，两种情况</p></blockquote><ul><li>来自于其他编译单元(静态链接)</li><li>动态链接库</li></ul><p>例如，有a.o和b.o静态链接再和lib.so动态链接,如果a.o中引用了一个外部符号foo,那么该如何判断这个符号究竟是属于哪个单元呢？如果只是简单地宏替换, call *foo(%rip),但其实这样是效率很低的。</p><h5 id="“发明”PLT-GOT"><a href="#“发明”PLT-GOT" class="headerlink" title="“发明”PLT &amp; GOT"></a>“发明”PLT &amp; GOT</h5><blockquote><p>先编译为相对于%rip的简单的call调用，在链接的时候，如果发现这是一个本单元的符号，直接相对于rip寻址；如果发现这是一个外部(动态链接)库的话，就需要plt这条entry,再把地址填上去。</p></blockquote><blockquote><p>我们的“符号表”就是Global Offset Table(GOT).</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000000011e0</span> &lt;printf@plt&gt;:<br>    <span class="hljs-attribute">11e0</span>:       f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa             endbr64<br>    <span class="hljs-attribute">11e4</span>:       f2 ff <span class="hljs-number">25</span> <span class="hljs-number">7</span>d <span class="hljs-number">2</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span>    bnd jmp *<span class="hljs-number">0</span>x2d7d(%rip)        # <span class="hljs-number">3</span>f68 &lt;printf@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span>&gt;<br>    <span class="hljs-attribute">11eb</span>:       <span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>咦，这条jmp指令不是有点熟悉吗？和我们的DSYM很相似。这不印证了我们的猜想吗？</p></blockquote><h5 id="最后一个问题：数据"><a href="#最后一个问题：数据" class="headerlink" title="最后一个问题：数据"></a>最后一个问题：数据</h5><blockquote><p>不管多少个静态库动态库，但我们的程序只有一个errno,environ,stdout。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/"/>
    <url>/2023/08/02/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/</url>
    
    <content type="html"><![CDATA[<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><ul><li><p>加载第一个进程 （init 应用程序）</p><blockquote><p>相当于在操作系统中放置一个位于初始状态的状态机</p></blockquote></li><li><p>包含一些进程可以操纵的操作系统对象</p></li><li><p>然后 Linux 变成一个中断(系统调用)处理程序</p></li></ul><p>systemd为什么是进程树的根 (init 进程并不是 systemd)</p><h2 id="Linux-Kernel-系统调用上的发行版和应用生态"><a href="#Linux-Kernel-系统调用上的发行版和应用生态" class="headerlink" title="Linux Kernel 系统调用上的发行版和应用生态"></a>Linux Kernel 系统调用上的发行版和应用生态</h2><ul><li>系统工具 coreutils, binutils, systemd, ….</li><li>桌面系统 </li><li>应用程序</li></ul><h2 id="构建最小的Linux"><a href="#构建最小的Linux" class="headerlink" title="构建最小的Linux"></a>构建最小的Linux</h2><p>目标：把Linux内核启动起来，把minimal.S的二进制文件加载，打印HelloWorld，然后就退出。</p><p>我们真正的壁垒</p><ol><li>怎么样提出问题</li><li>怎样回答问出的问题</li></ol><p>问题：  我希望用 QEMU 在给定的 Linux 内核完成初始化后，直接执行我自己编写的、静态链接的 init 二进制文件。我应该怎么做？</p><ol><li>需要编译一个静态链接的 init 二进制文件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ gcc -<span class="hljs-keyword">static</span> -o <span class="hljs-keyword">init</span> <span class="hljs-keyword">init</span>.c<br></code></pre></td></tr></table></figure></li><li>创建一个 initramfs 文件系统，其中包含您的 init 二进制文件和任何其他必需的文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">initramfs:<br><span class="hljs-comment"># Copy kernel and busybox from the host system</span><br>@<span class="hljs-built_in">mkdir</span> -p build/initramfs/bin<br>sudo bash -c <span class="hljs-string">&quot;cp /boot/vmlinuz build/ &amp;&amp; chmod 666 build/vmlinuz&quot;</span><br><span class="hljs-built_in">cp</span> init build/initramfs/<br><span class="hljs-built_in">cp</span> $(shell <span class="hljs-built_in">which</span> busybox) build/initramfs/bin/<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>什么是 cpio </p><blockquote><p>cpio 是一个类似于 tar 的工具，用于创建和提取归档文件。最终，归档文件将输出到名为 initramfs.cpio 的文件中。这个命令通常用于创建一个自定义的 initramfs 文件系统，以便在启动时加载自定义的软件和配置文件。</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> build/initramfs &amp;&amp; \<br>find . -print0 \<br>| cpio <span class="hljs-params">--null</span> -ov <span class="hljs-params">--format=newc</span> \<br>| gzip -9 &gt; <span class="hljs-string">../initramfs.cpio.gz</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 initramfs</p><blockquote><p>initramfs 是一个临时文件系统，它被加载到内存中，以便在 Linux 内核初始化后提供一个初始根文件系统。这个临时的根文件系统在根文件系统挂载之前执行必要的初始化任务。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-initrd build/initramfs.cpio.gz<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>然后，您需要在 QEMU 中将 initramfs 文件系统加载到内存中，并将 init 二进制文件设置为 init 进程。您可以使用以下命令启动 QEMU：<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">run:<br><span class="hljs-comment"># Run QEMU with the installed kernel and generated initramfs</span><br>qemu-system-x86_64 <span class="hljs-string">\</span><br>  -serial mon:stdio <span class="hljs-string">\</span><br>  -kernel build/vmlinuz <span class="hljs-string">\</span><br>  -initrd build/initramfs.cpio.gz <span class="hljs-string">\</span><br>  -machine accel=kvm:tcg <span class="hljs-string">\</span><br>  -append <span class="hljs-string">&quot;console=ttyS0 quiet rdinit=$(INIT)&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>rdinit&#x3D;init 是一个内核命令行参数，用于指定内核启动后应该运行哪个程序作为根文件系统的初始化进程。在 Linux 系统中，init 进程是所有进程的祖先进程，负责启动系统中的各种服务和进程。rdinit&#x3D;init 参数告诉内核在启动时运行名为 init 的程序作为 init 进程，这通常是指在 initramfs 文件系统中的程序。<br>如果这个init进程中途结束退出了的话，例如把这个init进程换成我们的一个minimal.S(简单的打印后退出)，那么由于init进程结束，系统会panic。init进程有着特殊的作用。</p></blockquote></li></ol><ul><li>什么是busybox<blockquote><p>Busybox是一个开源工具集，集成了许多常用的Unix工具，如ls、cat、grep、find等，可以在嵌入式系统中提供命令行界面的支持。Busybox的目标是提供一个小巧、高效的Unix工具集。</p></blockquote></li></ul><ol><li>busybox sh 就变成一个 shell</li><li>busybox ls 就执行 ls 命令</li></ol><ul><li>busybox 可以看成Linux所有程序的一个打包</li></ul><ul><li><p>init 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (2) Run a shell on the init console</span><br><span class="hljs-variable">$BB</span> sh<br></code></pre></td></tr></table></figure><p>把 init 程序换成这个脚本后，系统启动没有 kernel panic了。<br>make run启动后，得到了一个Linux的终端，但输入 ls 命令是没有反应的。</p><blockquote><p>回想一下：系统在启动以后，只有 init 和 busybox，系统并不认识 ls 命令。可以 &#x2F;bin&#x2F;busybox ls。</p></blockquote></li><li><p>那应该怎么办？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (3) Rock&#x27;n Roll!</span><br><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-variable">$BB</span> sh<br><br><span class="hljs-built_in">mkdir</span> -p /tmp<br><span class="hljs-built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc  none /proc<br><span class="hljs-built_in">mkdir</span> -p /sys  &amp;&amp; mount -t sysfs none /sys<br><span class="hljs-built_in">mknod</span> /dev/tty c 4 1<br>setsid /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1<br></code></pre></td></tr></table></figure></li><li><p>在 &#x2F;bin 目录下创建多个命令的快捷方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>最后回答什么是 systemd, 它为什么是进程树的根。</p><blockquote><p>在之后，会执行 &#x2F;usr&#x2F;sbin&#x2F;init<br>可以看到，这是个快捷方式，指向 &#x2F;lib&#x2F;systemd&#x2F;systemd</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/"/>
    <url>/2023/08/02/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ol><li>编程中的一些细节</li><li>调试工具的正确使用方法</li></ol><h3 id="软件的热更新DSU"><a href="#软件的热更新DSU" class="headerlink" title="软件的热更新DSU"></a>软件的热更新DSU</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOSTRING(s)  STRINGIFY(s)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">padding</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;.fill &quot;</span> TOSTRING(PADDING) <span class="hljs-string">&quot;, 1, 0x90&quot;</span></span><br><span class="hljs-params">  )</span>;<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In old function %s\n&quot;</span>, __func__);<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo_new</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In new function %s\n&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-comment">// 48 b8 (64-bit imm)   movabs $imm,%rax</span><br><span class="hljs-comment">// ff e0                jmpq   *%rax</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> PATCH[] = <span class="hljs-string">&quot;\x48\xb8--------\xff\xe0&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DSU</span><span class="hljs-params">(<span class="hljs-type">void</span> *func, <span class="hljs-type">void</span> *func_new)</span> &#123;<br>  <span class="hljs-type">int</span> flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;<br><br>  <span class="hljs-comment">// Grant write permission to the memory</span><br>  <span class="hljs-comment">// We must handle boundary cases</span><br>  <span class="hljs-type">uintptr_t</span> fn = (<span class="hljs-type">uintptr_t</span>)func;<br>  <span class="hljs-type">uintptr_t</span> base = fn &amp; ~<span class="hljs-number">0xfff</span>;<br>  <span class="hljs-keyword">if</span> (fn + <span class="hljs-keyword">sizeof</span>(PATCH) &gt; base + <span class="hljs-number">4096</span>) &#123;<br>    np = <span class="hljs-number">2</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    np = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;np = %d\n&quot;</span>, np);<br><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, flag);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>  <br>  <span class="hljs-comment">// Patch the first instruction (this is UB in C spec)</span><br>  <span class="hljs-built_in">memcpy</span>(func, PATCH, <span class="hljs-keyword">sizeof</span>(PATCH));<br>  <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span> *)func + <span class="hljs-number">2</span>, &amp;func_new, <span class="hljs-keyword">sizeof</span>(func_new));<br><br>  <span class="hljs-comment">// Revoke the write permission</span><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, PROT_READ | PROT_EXEC);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  foo();<br>  DSU(foo, foo_new);  <span class="hljs-comment">// Dynamic software update</span><br>  foo();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些编程小技巧"><a href="#一些编程小技巧" class="headerlink" title="一些编程小技巧"></a>一些编程小技巧</h4><ul><li><p>什么是 __func__？</p><blockquote><p><strong>func</strong> 是C语言中的一个内置宏，它返回当前函数的名称作为一个字符串常量。它可以用于调试和错误报告，以便在程序出错时能够更容易地确定错误发生在哪个函数中。<br>相当于：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">my_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __func__ <span class="hljs-string">&quot;my_func&quot;</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current function: %s\n&quot;</span>, __func__);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __func__ </span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 <strong>func</strong> 宏不需要包含任何头文件，因为它是C语言的内置宏，可以直接在代码中使用。</p></blockquote></li><li><p>使用 assert 断言</p><blockquote><p>有利于 bug 的定位</p></blockquote></li></ul><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><ul><li><p>为什么要把函数设置成 inline?<br>内联函数（inline function）是一种编译器提供的优化手段，它的本质是将函数在调用处展开，从而避免了函数调用的开销。也就是说，内联函数不是真正的函数调用，而是将函数的代码嵌入到调用处，类似于宏替换。</p></li><li><p>打一个小补丁</p><blockquote><p>我们知道，在调用一个函数的时候，首先 call foo, 把返回地址压栈，并跳转到foo函数处，然后再在foo函数那里给上一个补丁。</p></blockquote><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">movabs <span class="hljs-built_in">$imm</span> , <span class="hljs-built_in">%rax</span><br>jump *(rax)<br></code></pre></td></tr></table></figure><p>%rax是 foo_new函数的地址，因为foo_new函数最后也会调用 ret 指令，所以结束后返回到原来的地方。</p></li></ul><h3 id="用好工具"><a href="#用好工具" class="headerlink" title="用好工具"></a>用好工具</h3><ul><li>如何让gdb以更友好的方式帮我们打印相关的信息？<br>计算机公理3：让你感到不适的 tedious 工作，一定有办法提高效率。</li></ul><blockquote><p>用python写一个脚本，增加一个自定义的gdb命令</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>REGS = [<br>    <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;rbx&#x27;</span>, <span class="hljs-string">&#x27;rcx&#x27;</span>, <span class="hljs-string">&#x27;rdx&#x27;</span>,<br>    <span class="hljs-string">&#x27;rbp&#x27;</span>, <span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-string">&#x27;rsi&#x27;</span>, <span class="hljs-string">&#x27;rdi&#x27;</span>,<br>    <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-string">&#x27;r9&#x27;</span>, <span class="hljs-string">&#x27;r10&#x27;</span>, <span class="hljs-string">&#x27;r11&#x27;</span>,<br>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RegDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(RegDump, self).__init__(<br>            <span class="hljs-string">&quot;rdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, arg, _</span>):<br>        <span class="hljs-comment"># 得到变量 ctx 的值</span><br>        <span class="hljs-comment"># 每次输入 rdump 命令会执行 invoke 函数</span><br>        ctx = gdb.parse_and_eval(<span class="hljs-string">f&#x27;ctx&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(REGS):<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;r.upper():<span class="hljs-number">3</span>&#125;</span> = <span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(ctx[r]):016x&#125;</span>&#x27;</span>,<br>                end=[<span class="hljs-string">&#x27;  &#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>][i % <span class="hljs-number">2</span>]<br>            )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>RegDump()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_source_line</span>(<span class="hljs-params">address</span>):<br>    <span class="hljs-comment"># by GPT-4</span><br><br>    <span class="hljs-comment"># Find the source code line corresponding to the given address</span><br>    symtab_and_line = gdb.find_pc_line(address)<br><br>    <span class="hljs-comment"># Check if the source code line was found</span><br>    <span class="hljs-keyword">if</span> symtab_and_line.symtab <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Get the source file name and line number</span><br>        filename = symtab_and_line.symtab.filename<br>        line_number = symtab_and_line.line<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Path(filename).name&#125;</span>:<span class="hljs-subst">&#123;line_number&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Source code line not found&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        n = gdb.parse_and_eval(<span class="hljs-string">f&#x27;NTASK&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            tsk = gdb.parse_and_eval(<span class="hljs-string">f&#x27;tasks[<span class="hljs-subst">&#123;i&#125;</span>]&#x27;</span>)<br>            pc = <span class="hljs-built_in">int</span>(tsk[<span class="hljs-string">&#x27;context&#x27;</span>][<span class="hljs-string">&#x27;rip&#x27;</span>])<br>            is_current = <span class="hljs-built_in">int</span>(<br>                gdb.parse_and_eval(<span class="hljs-string">f&#x27;&amp;tasks[<span class="hljs-subst">&#123;i&#125;</span>] == current&#x27;</span>)<br>            )<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;Proc-<span class="hljs-subst">&#123;i&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&quot; *&quot;</span>[is_current]&#125;</span> &#x27;</span>,<br>                get_source_line(pc)<br>            )<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>ProcDump()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/08/02/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux进程的地址空间"><a href="#Linux进程的地址空间" class="headerlink" title="Linux进程的地址空间"></a>Linux进程的地址空间</h2><p>有什么工具可以来查看进程的地址空间</p><ol><li>pmap</li><li>cat &#x2F;proc&#x2F; [pid] &#x2F; maps</li><li>gdb</li><li>readelf</li><li>objdump</li></ol><p>有的程序刚开始执行就结束了(比如打印一个东西就退出)，如果要查看这个进程的地址空间。那怎么办？</p><blockquote><p>使用gdb。<br>使用gdb命令 info inferiors得到进程的pid</p></blockquote><ul><li>该命令打印gdb当前管理的inferiors列表，每个inferior都有自己的不同地址空间，inferior与进程对应。</li></ul><ol><li><p>得到进程的pid后,使用命令 !pmap [pid], 在gdb中使用shell命令需要在前面加上 ！。</p></li><li><p>同样，在gdb中，还可以使用 !cat &#x2F;proc&#x2F; [pid] &#x2F;maps来查看进程的地址空间。</p></li></ol><ul><li>其实pmap就是使用系统中的 &#x2F;proc&#x2F;[pid]&#x2F;这个文件实现的。<br>怎么证明呢？<blockquote><p>使用 strace   strace pmap [pid]</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>gdb调试starti之后，查看进程的地址空间：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">8</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>     <span class="hljs-number">16</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>              <span class="hljs-number">416</span>K<br></code></pre></td></tr></table></figure><p>我们还发现，在按下starti后，有一条信息：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fe32b0 in _start () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>说明动态链接的第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2中，甚至在地址空间中此时也没有libc这个库。<br>在状态机在刚刚被初始化的一瞬间，在进程里面还没有printf。</p><blockquote><p>动态链接的ELF文件中，有一个INTERP, 就是这里的ld-linux-x86-64.so.2, 需要另外一个程序，才能执行现在这个程序，对于动态链接来说，这就是加载器。</p></blockquote><p>再在main函数上打个断点，continue后再打印一次进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555558000</span>      <span class="hljs-number">4</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7d7f000</span>     <span class="hljs-number">12</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7d82000</span>    <span class="hljs-number">160</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7daa000</span>   <span class="hljs-number">1620</span>K r-x-- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f3f000</span>    <span class="hljs-number">352</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f97000</span>     <span class="hljs-number">16</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9b000</span>      <span class="hljs-number">8</span>K rw--- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9d000</span>     <span class="hljs-number">52</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbb000</span>      <span class="hljs-number">8</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffd000</span>      <span class="hljs-number">8</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>             <span class="hljs-number">2644</span>K<br></code></pre></td></tr></table></figure><p>如上，我们发现libc已经有了。加载器也还在，未来可能还需要这个加载器加载其他动态链接库。</p><h4 id="其他小细节"><a href="#其他小细节" class="headerlink" title="其他小细节"></a>其他小细节</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> main&#123;<br><span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在库都加载完成后，用 !cat &#x2F;proc&#x2F;14776&#x2F;&#x2F;maps 查看该进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7ffff7fbd000</span>-<span class="hljs-number">7</span>ffff7fc1000 r--p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vvar]</span><br><br><span class="hljs-attribute">7ffff7fc1000</span>-<span class="hljs-number">7</span>ffff7fc3000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vdso]</span><br><br></code></pre></td></tr></table></figure><p>我们发现这两行， vvar 和 vdso 是什么？</p><blockquote><p>不进入内核的系统调用。<br>vvar is a memory region that contains kernel variables that are frequently accessed by user-space programs. These variables are read-only and can be accessed directly by the user-space programs without making a system call.<br>例如<br>当前的时间， 系统页面大小<br>vdso is a memory region that contains a small shared library provided by the kernel. This library contains a set of functions that are commonly used by user-space programs and can be excuted directly in user mode, without the need for a system call.</p></blockquote><h3 id="进程地址空间的管理"><a href="#进程地址空间的管理" class="headerlink" title="进程地址空间的管理"></a>进程地址空间的管理</h3><p>操作系统应该提供一个修改进程地址空间的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 映射</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br><br><span class="hljs-comment">// 修改映射权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>本质：在状态机状态上增加&#x2F;删除&#x2F;修改一段可访问的内存</p><ul><li>mmap: 可以用来申请内存 (MAP_ANONYMOUS)，也可以把文件 “搬到” 进程地址空间中</li></ul><p>一小段示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GiB * (1024LL * 1024 * 1024)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *p = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span> GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap: %lx\n&quot;</span>, (<span class="hljs-type">uintptr_t</span>)p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)p == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;cannot map&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  *(p + <span class="hljs-number">2</span> GiB) = <span class="hljs-number">1</span>;<br>  *(p + <span class="hljs-number">4</span> GiB) = <span class="hljs-number">2</span>;<br>  *(p + <span class="hljs-number">7</span> GiB) = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">4</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">6</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">7</span> GiB));<br>&#125;<br></code></pre></td></tr></table></figure><p>疑问：这个程序运行会不会需要很长的时间，因为它分配了那么多的内存？</p><blockquote><p>其实一瞬间就完成了。也就是说，在使用mmap的时候，只是在操作系统中标记了这个进程这么多的内存，这个进程中这些内存还并没有开始分配，只是在后面用到了才会产生缺页中断。</p></blockquote><h3 id="入侵地址空间"><a href="#入侵地址空间" class="headerlink" title="入侵地址空间"></a>入侵地址空间</h3><p>进程 (M,  R 状态机) 在 “无情执行指令机器” 上执行</p><ul><li>状态机是一个封闭世界</li><li>但如果允许一个进程对其他进程的地址空间有访问权？</li></ul><p>一些入侵地址空间的例子</p><ol><li>调试器(gdb)</li></ol><ul><li>gdb 可以任意观测和修改程序的状态</li></ul><ol start="2"><li>Profiler (perf)</li></ol><h4 id="入侵进程地址空间-1-金山游侠"><a href="#入侵进程地址空间-1-金山游侠" class="headerlink" title="入侵进程地址空间 (1): 金山游侠"></a>入侵进程地址空间 (1): 金山游侠</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_WATCH 65536</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <span class="hljs-comment">// Name of the binary</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-type">int</span> memfd;         <span class="hljs-comment">// Address space of the process</span><br>  <span class="hljs-type">int</span> bits;          <span class="hljs-comment">// Search bit-width (16, 32, or 64)</span><br>  <span class="hljs-type">bool</span> has_watch;    <span class="hljs-comment">// Watched values</span><br>  <span class="hljs-type">uintptr_t</span> watch[MAX_WATCH];<br>&#125;;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span>;<br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint32_t</span> val)</span> &#123;<br>  <span class="hljs-type">uintptr_t</span> start, kb;<br>  <span class="hljs-type">char</span> perm[<span class="hljs-number">16</span>];<br>  FILE *fp = popens(<span class="hljs-string">&quot;pmap -x $(pidof %s) | tail -n +3&quot;</span>, g-&gt;name);<br>  <span class="hljs-type">int</span> nmatch = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;start) == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%ld%*ld%*ld%s%*[^\n]s&quot;</span>, &amp;kb, perm);<br>    <span class="hljs-keyword">if</span> (perm[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Non-writable areas</span><br><br>    <span class="hljs-type">uintptr_t</span> size = kb * <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for brevity</span><br>    lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>    size = read(g-&gt;memfd, mem, size);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Scanning %lx--%lx\n&quot;</span>, start, start + size);<br><br>    <span class="hljs-keyword">if</span> (!g-&gt;has_watch) &#123;<br>      <span class="hljs-comment">// First-time search; scan all memory</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> off = <span class="hljs-number">0</span>; off &lt; size; off += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>        <span class="hljs-keyword">if</span> (v == val &amp;&amp; nmatch &lt; MAX_WATCH) &#123;<br>          g-&gt;watch[nmatch++] = start + off;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Search in the watched values</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>        <span class="hljs-type">intptr_t</span> off = g-&gt;watch[i] - start;<br>        <span class="hljs-keyword">if</span> (g-&gt;watch[i] &amp;&amp; <span class="hljs-number">0</span> &lt;= off &amp;&amp; off &lt; size) &#123;<br>          <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>          <span class="hljs-keyword">if</span> (v == val) nmatch++;<br>          <span class="hljs-keyword">else</span> g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(mem);<br>  &#125;<br>  pclose(fp);<br><br>  <span class="hljs-keyword">if</span> (nmatch &gt; <span class="hljs-number">0</span>) &#123;<br>    g-&gt;has_watch = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d match(es).\n&quot;</span>, nmatch);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">overwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint64_t</span> val)</span> &#123;<br>  <span class="hljs-type">int</span> nwrite = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++)<br>    <span class="hljs-keyword">if</span> (g-&gt;watch[i]) &#123;<br>      lseek(g-&gt;memfd, g-&gt;watch[i], SEEK_SET);<br>      write(g-&gt;memfd, &amp;val, g-&gt;bits / <span class="hljs-number">8</span>);<br>      nwrite++;<br>    &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d value(s) written.\n&quot;</span>, nwrite);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>    g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  g-&gt;has_watch = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Search for %d-bit values in %s.\n&quot;</span>, g-&gt;bits, g-&gt;name);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">load_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  FILE *pid_fp;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  g-&gt;name = name;<br>  g-&gt;bits = <span class="hljs-number">32</span>;<br>  reset(g);<br><br>  pid_fp = popens(<span class="hljs-string">&quot;pidof %s&quot;</span>, g-&gt;name);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(pid_fp, <span class="hljs-string">&quot;%d&quot;</span>, &amp;g-&gt;pid) != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Panic: fail to get pid of \&quot;%s\&quot;.\n&quot;</span>, g-&gt;name);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>release:<br>  <span class="hljs-keyword">if</span> (pid_fp) pclose(pid_fp);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &gt;= <span class="hljs-number">0</span>) &#123;<br>    close(g-&gt;memfd);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">long</span> val;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> <span class="hljs-title">game</span>;</span><br><br>  <span class="hljs-keyword">if</span> (load_game(&amp;game, argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (!feof(<span class="hljs-built_in">stdin</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s %d) &quot;</span>, game.name, game.pid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> release;<br><br>    <span class="hljs-keyword">switch</span> (buf[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-keyword">goto</span> release; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); game.bits = val; reset(&amp;game); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); scan(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); overwrite(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>: reset(&amp;game); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>release:<br>  close_game(&amp;game);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span> &#123;<br>  <span class="hljs-type">char</span> cmd[<span class="hljs-number">128</span>];<br>  va_list args;<br>  va_start(args, fmt);<br>  vsnprintf(cmd, <span class="hljs-keyword">sizeof</span>(cmd), fmt, args);<br>  va_end(args);<br>  FILE *ret = popen(cmd, <span class="hljs-string">&quot;r&quot;</span>);<br>  assert(ret);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span> &#123;<br>  <span class="hljs-type">uint64_t</span> val = *(<span class="hljs-type">uint64_t</span> *)(&amp;mem[off]);<br>  <span class="hljs-keyword">switch</span> (bits) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: val &amp;= <span class="hljs-number">0xffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: val &amp;= <span class="hljs-number">0xffffffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>: <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码导读</p><ul><li>va_list，va_start()、va_arg() 和 va_end() 是什么<blockquote><p>这可以使C语言实现变长参数。</p><blockquote><p>va_list 是一个类型，用于表示可变参数列表。<br>va_start() 宏用于初始化可变参数列表<br>va_arg() 宏用于访问可变参数列表中的下一个参数<br>va_end() 宏用于结束可变参数列表的访问</p></blockquote></blockquote></li><li>一段小例子<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> &#123;<br>    va_list ap;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;<br><br>    va_start(ap, count); <span class="hljs-comment">// 初始化可变参数列表</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        total += va_arg(ap, <span class="hljs-type">double</span>); <span class="hljs-comment">// 获取下一个参数</span><br>    &#125;<br><br>    va_end(ap); <span class="hljs-comment">// 结束可变参数列表</span><br><br>    <span class="hljs-keyword">return</span> total / count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> avg = average(<span class="hljs-number">5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;平均值为：%f\n&quot;</span>, avg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>popen函数</p><blockquote><p>popen()会调用fork()产生子进程，然后从子进程中调用&#x2F;bin&#x2F;sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。</p></blockquote></blockquote></li><li>也就是说，首先获取游戏进程的名字后，先创建一个子进程执行 pidof [name]的命令，可以获取游戏进程pid。然后fscanf(pid_fp, “%d”, &amp;g-&gt;pid) !&#x3D; 1读取该进程pid。<br>接着打开&#x2F;proc&#x2F;[pid]&#x2F;mem这个文件。g-&gt;memfd指向这个文件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br></code></pre></td></tr></table></figure></li><li>scan函数<br>在用pmap得到虚拟地址区域后，就可以把这个区域映射到入侵程序的地址空间中，并得到起始地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for </span><br></code></pre></td></tr></table></figure></li><li>之后把 &#x2F;proc&#x2F;pid&#x2F;mem的文件偏移设为虚拟地址区域起始处。</li></ul><ul><li>如果想要在&#x2F;proc&#x2F;pid&#x2F;mem 文件访问进程的虚拟地址 0x12345678，您需要将文件偏移量设置为 0x12345678。<br>并把这个区域的内存全部写入入侵进程的地址空间中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>size = read(g-&gt;memfd, mem, size);<br></code></pre></td></tr></table></figure></li></ul><ul><li>然后就可以根据偏移，可以把相应的地址对应起来了。大致意思就是在入侵地址里暴力寻找符合条件的地址，然后根据找的的符合条件的地址，由于偏移是一样的，也就可以把这个地址对应到被入侵进程的相应虚拟地址区域中了。</li></ul><h4 id="入侵进程地址空间-2-变速齿轮"><a href="#入侵进程地址空间-2-变速齿轮" class="headerlink" title="入侵进程地址空间 (2): 变速齿轮"></a>入侵进程地址空间 (2): 变速齿轮</h4><p>用修改程序系统调用的手段来欺骗程序对时间的认识，就可以实现游戏的加速和减速。</p><ul><li><p>简单的一段C程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> hp = <span class="hljs-number">10000</span>;<br><br>__attribute__((noinline)) <span class="hljs-type">int</span> <span class="hljs-title function_">hit</span><span class="hljs-params">(<span class="hljs-type">int</span> damage)</span> &#123;<br>  <span class="hljs-keyword">return</span> hp - damage;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    hp = hit(rand() % <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hp = %d\n&quot;</span>, hp);<br>    usleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">if</span> (hp &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>python 脚本</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(argv) &lt; <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Usage <span class="hljs-subst">&#123;argv[<span class="hljs-number">0</span>]&#125;</span> [--hp] [--fast] [--slow]&#x27;</span>)<br>    exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">addr, patch</span>):<br>    pid = <span class="hljs-built_in">int</span>(subprocess.check_output([<span class="hljs-string">&#x27;pidof&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/mem&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.seek(addr)<br>        fp.write(patch)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">symbol</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> subprocess.check_output([<span class="hljs-string">&#x27;nm&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]).splitlines():<br>        tokens = line.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).split()<br>        <span class="hljs-keyword">if</span> tokens[-<span class="hljs-number">2</span>:] == [<span class="hljs-string">&#x27;T&#x27;</span>, symbol]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tokens[<span class="hljs-number">0</span>], base=<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--hp&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># hit -&gt; mov $9999999, %eax; ret</span><br>    patch(name(<span class="hljs-string">&#x27;hit&#x27;</span>), <span class="hljs-string">b&#x27;\xb8\x7f\x96\x98\x00\xc3&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--slow&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shl $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xe7\x04&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--fast&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shr $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xef\x04&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/fork%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/fork%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul><li>fork状态机复制，包括持有的所有操作系统对象(如文件描述符)</li><li>execve重置状态机，但继承持有的所有操作系统的对象</li><li>例如在fork之前打开一个管道, 然后就可以把一部分计算的输出管道给另外一个进程的输入</li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><ul><li>RTFM: O_CLOEXEC : execve时文件描述符不应该被继承； O_APPEND：以追加的方式写该文件</li><li>对于数据文件，文件描述符会记住上次访问的位置</li><li>dup：复制一个文件描述符，进程有两个fd指向同一个文件，并且具有同一个offset</li></ul><h2 id="回到fork-复制，但又没有完全复制"><a href="#回到fork-复制，但又没有完全复制" class="headerlink" title="回到fork, 复制，但又没有完全复制"></a>回到fork, 复制，但又没有完全复制</h2><p>概念上状态机被复制，但实际上复制后内存都共享</p><ul><li>“Copy on Write”只有被写入的页面才会复制一份<ol><li>被复制后，整个地址空间都被标记位”只读”</li><li>操作系统捕获Page Fault后酌情复制页面</li><li>操作系统会维护每个页面的引用计数</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/02/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="我们该如何学习-C-标准库"><a href="#我们该如何学习-C-标准库" class="headerlink" title="我们该如何学习 C 标准库?"></a>我们该如何学习 C 标准库?</h2><ul><li><del>直接调试 glibc (像我们上课那样)</del></li><li>寻找更好的替代品，一定有为嵌入式设备实现的简化 libc。<blockquote><p>选择 musl<br>musl是一个轻量级的C标准库，它专注于提供高效、可靠和安全的C语言运行时环境。musl库的设计目标是遵循POSIX标准，同时保持代码的简洁和易于维护。它主要用于嵌入式系统、轻量级容器和其他类似的应用程序中，因为它比其他标准库更小、更快、更安全，并且不包含任何专有代码或许可证限制。在某些情况下，它也可以用作替代glibc的标准库。</p></blockquote></li></ul><ul><li>那怎么编译一个 C 程序用 musl 作为 libc 而不是用 glibc呢 ？<ol><li>sudo apt-get install musl-tools</li><li>编写C程序，包含 stdio.h 头文件</li><li>musl-gcc -o hello hello.c</li></ol></li></ul><h2 id="libc-的基本功能"><a href="#libc-的基本功能" class="headerlink" title="libc 的基本功能"></a>libc 的基本功能</h2><ul><li>基础数据的体系结构无关抽象</li></ul><ul><li>inttypes.h</li></ul><ul><li>字符串和数组操作</li></ul><h2 id="操作系统对象与环境"><a href="#操作系统对象与环境" class="headerlink" title="操作系统对象与环境"></a>操作系统对象与环境</h2><ul><li><p>环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **env = environ; *env; env++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *env);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>environ是一个字符指针的指针。</p></li><li><p>environ是谁赋值的？</p></li></ul><p>gdb调试<br>第一条指令的时候 environ 还没有被赋值。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fc7bfe in _dlstart () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib/</span>ld-musl-x86_64.so.<span class="hljs-number">1</span><br>(gdb) p(<span class="hljs-keyword">char</span>*) environ<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>而在main函数的时候，environ是有正确的值的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>__libc_start_main函数<br>char **envp = argv + argc + <span class="hljs-number">1</span>;<br>.....<br>.....<br><span class="hljs-regexp">//</span>__init_libc函数<br>environ = envp<br></code></pre></td></tr></table></figure><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："><a href="#本讲内容：指令序列和高级语言的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："></a>本讲内容：指令序列和高级语言的状态机模型；回答以下问题：</h2><ul><li>什么是软件 (程序)？</li><li>如何在操作系统上构造最小&#x2F;一般&#x2F;图形界面应用程序？</li><li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li></ul><h2 id="构建一个最小的程序"><a href="#构建一个最小的程序" class="headerlink" title="构建一个最小的程序"></a>构建一个最小的程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcc-编译出来的文件一点也不小"><a href="#gcc-编译出来的文件一点也不小" class="headerlink" title="gcc 编译出来的文件一点也不小"></a>gcc 编译出来的文件一点也不小</h3><ol><li>objdump 工具可以查看对应的汇编代码</li><li>–verbose 可以查看所有编译选项 (真不少)</li><li>printf 变成了 puts@plt</li><li>-Wl,–verbose 可以查看所有链接选项 (真不少)<br>原来链接了那么多东西<br>还解释了 end 符号的由来</li><li>-static 会链接 libc (大量的代码)<blockquote><p>gcc a.c 和 gcc a.c -static 有什么区别？</p></blockquote></li></ol><h3 id="强行构造最小的-Hello-World？"><a href="#强行构造最小的-Hello-World？" class="headerlink" title="强行构造最小的 Hello, World？"></a>强行构造最小的 Hello, World？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c hello<span class="hljs-selector-class">.c</span>    -&gt; hello<span class="hljs-selector-class">.o</span> <br>ld hello<span class="hljs-selector-class">.o</span> -e <span class="hljs-selector-tag">main</span>   -&gt; <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>执行a.out,会发生Segmentation Fault.</p><p>如果改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再继续执行上面的编译命令，发现程序可以正常执行了（死循环）。</p><blockquote><p>查看汇编语言，猜测程序返回时的 ret 出现了错误。</p></blockquote><h3 id="解决异常退出"><a href="#解决异常退出" class="headerlink" title="解决异常退出"></a>解决异常退出</h3><blockquote><p>解决办法：用一条特殊的指令请操作系统帮忙</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">movq $SYS_exit,  %rax   <span class="hljs-comment"># exit(</span><br>movq $1,         %rdi   <span class="hljs-comment">#   status=1</span><br><span class="hljs-keyword">syscall</span>                 <span class="hljs-comment"># );</span><br></code></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<ul><li>程序把控制权完全交给操作系统</li><li>操作系统可以改变程序状态甚至终止程序</li></ul></li></ul><h2 id="理解高级编程语言程序"><a href="#理解高级编程语言程序" class="headerlink" title="理解高级编程语言程序"></a>理解高级编程语言程序</h2><blockquote><p>编程语言也是一个状态机</p></blockquote><ul><li>非递归的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> pc, n;<br>  <span class="hljs-type">char</span> from, to, via;<br>&#125; Frame;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ret()     (&#123; top--; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  Frame stk[<span class="hljs-number">64</span>], *top = stk - <span class="hljs-number">1</span>;<br>  call(n, from, to, via);<br>  <span class="hljs-keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;<br>    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;<br>    <span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <br>      <span class="hljs-comment">// 为什么goto(4)只是设置pc为3，是因为循环会++</span><br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>什么叫函数调用<blockquote><p>函数是由很多个栈帧组成的，每一个栈帧都有一个PC</p></blockquote></li></ul><p>什么是函数调用？</p><blockquote><p> 函数调用就是在栈帧的顶部再加上一个栈帧，这个栈帧的PC是0，然后把参数放到栈上</p></blockquote><p>什么是函数返回</p><blockquote><p>  把顶部的栈给抹掉</p></blockquote><p>什么是执行一条语句</p><blockquote><p>  取最顶上栈帧PC上的语句执行</p></blockquote><ul><li>代码讲解<br>这是递归版的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    hanoi(n - <span class="hljs-number">1</span>, from, via, to);<br>    hanoi(<span class="hljs-number">1</span>,     from, to,  via);<br>    hanoi(n - <span class="hljs-number">1</span>, via,  to,  from);<br>  &#125;<br>  <span class="hljs-comment">// return 省略了</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据上面的思想，把整个hanoi函数理解成一个栈帧，每一个栈帧有一个PC，还需要参数信息</p></blockquote></li></ul><p><strong>可以理解成函数体每一条语句都是一条PC指针</strong><br>每一次循环，都会取最顶上的栈帧来操作<br>这也就是下部分的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作系统上的软件-应用程序"><a href="#操作系统上的软件-应用程序" class="headerlink" title="操作系统上的软件 (应用程序)"></a>操作系统上的软件 (应用程序)</h2><blockquote><p>任何程序 &#x3D; minimal.S &#x3D; 调用 syscall 的状态机</p></blockquote><p>可执行文件是操作系统中的对象</p><ul><li><p>与大家日常使用的文件 (a.c, README.txt) 没有本质区别</p></li><li><p>操作系统提供 API 打开、读取、改写 (都需要相应的权限)</p></li></ul><p>查看可执行文件</p><ul><li>vim, cat, xxd 都可以直接 “查看” 可执行文件</li><li>vim 中二进制的部分无法 “阅读”，但可以看到字符串常量</li><li>使用 xxd 可以看到文件以 “\x7f” “ELF” 开头</li><li>Vscode 有 binary editor 插件</li></ul><p>在 Vim 中输入 %!xxd 命令会将当前编辑的文件转换成十六进制表示，并在 Vim 中显示。这个命令的作用是将当前编辑的文件作为输入传递给 xxd 命令(%表示对整个文件执行操作)，xxd 命令会将其转换成十六进制格式，并将结果输出到标准输出流，此时 Vim 会将其读取并显示在编辑器中。</p><h2 id="动手实验：观察程序的执行"><a href="#动手实验：观察程序的执行" class="headerlink" title="动手实验：观察程序的执行"></a>动手实验：观察程序的执行</h2><p>工具程序代表：编译器 (gcc)</p><ul><li>主要的系统调用：execve, read, write</li><li>strace -f gcc a.c (gcc 会启动其他进程， -f选项会追踪所有子进程)<ul><li>可以管道给编辑器 vim -</li><li>编辑器里还可以 %!grep (细节&#x2F;技巧)</li></ul></li></ul><p>grep 命令的 -e 选项用于指定一个或多个匹配模式，这些模式可以是正则表达式或普通字符串。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">strace <span class="hljs-keyword">ls</span> |&amp; <span class="hljs-keyword">grep</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">read</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">write</span><br></code></pre></td></tr></table></figure><p>图形界面程序代表：编辑器 (xedit)</p><ul><li>主要的系统调用：poll, recvmsg, writev</li><li>strace xedit<ul><li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li><li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/02/hello-world/"/>
    <url>/2023/08/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
