<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："><a href="#本讲内容：指令序列和高级语言的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："></a>本讲内容：指令序列和高级语言的状态机模型；回答以下问题：</h2><ul><li>什么是软件 (程序)？</li><li>如何在操作系统上构造最小&#x2F;一般&#x2F;图形界面应用程序？</li><li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li></ul><h2 id="构建一个最小的程序"><a href="#构建一个最小的程序" class="headerlink" title="构建一个最小的程序"></a>构建一个最小的程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcc-编译出来的文件一点也不小"><a href="#gcc-编译出来的文件一点也不小" class="headerlink" title="gcc 编译出来的文件一点也不小"></a>gcc 编译出来的文件一点也不小</h3><ol><li>objdump 工具可以查看对应的汇编代码</li><li>–verbose 可以查看所有编译选项 (真不少)</li><li>printf 变成了 puts@plt</li><li>-Wl,–verbose 可以查看所有链接选项 (真不少)<br>原来链接了那么多东西<br>还解释了 end 符号的由来</li><li>-static 会链接 libc (大量的代码)<blockquote><p>gcc a.c 和 gcc a.c -static 有什么区别？</p></blockquote></li></ol><h3 id="强行构造最小的-Hello-World？"><a href="#强行构造最小的-Hello-World？" class="headerlink" title="强行构造最小的 Hello, World？"></a>强行构造最小的 Hello, World？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c hello<span class="hljs-selector-class">.c</span>    -&gt; hello<span class="hljs-selector-class">.o</span> <br>ld hello<span class="hljs-selector-class">.o</span> -e <span class="hljs-selector-tag">main</span>   -&gt; <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>执行a.out,会发生Segmentation Fault.</p><p>如果改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再继续执行上面的编译命令，发现程序可以正常执行了（死循环）。</p><blockquote><p>查看汇编语言，猜测程序返回时的 ret 出现了错误。</p></blockquote><h3 id="解决异常退出"><a href="#解决异常退出" class="headerlink" title="解决异常退出"></a>解决异常退出</h3><blockquote><p>解决办法：用一条特殊的指令请操作系统帮忙</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">movq $SYS_exit,  %rax   <span class="hljs-comment"># exit(</span><br>movq $1,         %rdi   <span class="hljs-comment">#   status=1</span><br><span class="hljs-keyword">syscall</span>                 <span class="hljs-comment"># );</span><br></code></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<ul><li>程序把控制权完全交给操作系统</li><li>操作系统可以改变程序状态甚至终止程序</li></ul></li></ul><h2 id="理解高级编程语言程序"><a href="#理解高级编程语言程序" class="headerlink" title="理解高级编程语言程序"></a>理解高级编程语言程序</h2><blockquote><p>编程语言也是一个状态机</p></blockquote><ul><li>非递归的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> pc, n;<br>  <span class="hljs-type">char</span> from, to, via;<br>&#125; Frame;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ret()     (&#123; top--; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  Frame stk[<span class="hljs-number">64</span>], *top = stk - <span class="hljs-number">1</span>;<br>  call(n, from, to, via);<br>  <span class="hljs-keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;<br>    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;<br>    <span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <br>      <span class="hljs-comment">// 为什么goto(4)只是设置pc为3，是因为循环会++</span><br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>什么叫函数调用<blockquote><p>函数是由很多个栈帧组成的，每一个栈帧都有一个PC</p></blockquote></li></ul><p>什么是函数调用？</p><blockquote><p> 函数调用就是在栈帧的顶部再加上一个栈帧，这个栈帧的PC是0，然后把参数放到栈上</p></blockquote><p>什么是函数返回</p><blockquote><p>  把顶部的栈给抹掉</p></blockquote><p>什么是执行一条语句</p><blockquote><p>  取最顶上栈帧PC上的语句执行</p></blockquote><ul><li>代码讲解<br>这是递归版的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    hanoi(n - <span class="hljs-number">1</span>, from, via, to);<br>    hanoi(<span class="hljs-number">1</span>,     from, to,  via);<br>    hanoi(n - <span class="hljs-number">1</span>, via,  to,  from);<br>  &#125;<br>  <span class="hljs-comment">// return 省略了</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据上面的思想，把整个hanoi函数理解成一个栈帧，每一个栈帧有一个PC，还需要参数信息</p></blockquote></li></ul><p><strong>可以理解成函数体每一条语句都是一条PC指针</strong><br>每一次循环，都会取最顶上的栈帧来操作<br>这也就是下部分的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作系统上的软件-应用程序"><a href="#操作系统上的软件-应用程序" class="headerlink" title="操作系统上的软件 (应用程序)"></a>操作系统上的软件 (应用程序)</h2><blockquote><p>任何程序 &#x3D; minimal.S &#x3D; 调用 syscall 的状态机</p></blockquote><p>可执行文件是操作系统中的对象</p><ul><li><p>与大家日常使用的文件 (a.c, README.txt) 没有本质区别</p></li><li><p>操作系统提供 API 打开、读取、改写 (都需要相应的权限)</p></li></ul><p>查看可执行文件</p><ul><li>vim, cat, xxd 都可以直接 “查看” 可执行文件</li><li>vim 中二进制的部分无法 “阅读”，但可以看到字符串常量</li><li>使用 xxd 可以看到文件以 “\x7f” “ELF” 开头</li><li>Vscode 有 binary editor 插件</li></ul><p>在 Vim 中输入 %!xxd 命令会将当前编辑的文件转换成十六进制表示，并在 Vim 中显示。这个命令的作用是将当前编辑的文件作为输入传递给 xxd 命令(%表示对整个文件执行操作)，xxd 命令会将其转换成十六进制格式，并将结果输出到标准输出流，此时 Vim 会将其读取并显示在编辑器中。</p><h2 id="动手实验：观察程序的执行"><a href="#动手实验：观察程序的执行" class="headerlink" title="动手实验：观察程序的执行"></a>动手实验：观察程序的执行</h2><p>工具程序代表：编译器 (gcc)</p><ul><li>主要的系统调用：execve, read, write</li><li>strace -f gcc a.c (gcc 会启动其他进程， -f选项会追踪所有子进程)<ul><li>可以管道给编辑器 vim -</li><li>编辑器里还可以 %!grep (细节&#x2F;技巧)</li></ul></li></ul><p>grep 命令的 -e 选项用于指定一个或多个匹配模式，这些模式可以是正则表达式或普通字符串。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">strace <span class="hljs-keyword">ls</span> |&amp; <span class="hljs-keyword">grep</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">read</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">write</span><br></code></pre></td></tr></table></figure><p>图形界面程序代表：编辑器 (xedit)</p><ul><li>主要的系统调用：poll, recvmsg, writev</li><li>strace xedit<ul><li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li><li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/02/hello-world/"/>
    <url>/2023/08/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
