<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线程切换</title>
    <link href="/2023/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/7.%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <url>/2023/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/7.%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="xv6中的线程"><a href="#xv6中的线程" class="headerlink" title="xv6中的线程"></a>xv6中的线程</h2><p>一个线程可以认为是串行执行代码的单元。</p><ol><li>内核线程的概念，对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存。</li><li>每一个用户进程都有独立的内存地址空间，并且包含了一个线程，这个线程控制了用户进程代码指令的执行。所以XV6中的用户线程之间没有共享内存，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。XV6中的进程不会共享内存。<blockquote><p>在一些其他更加复杂的系统中，例如Linux，允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间</p></blockquote></li></ol><hr><h2 id="xv6线程调度"><a href="#xv6线程调度" class="headerlink" title="xv6线程调度"></a>xv6线程调度</h2><p><strong>每个CPU核都创建了一个线程调度器</strong>。<br>对于运算密集型线程，线程调度可以利用定时器中断。定时器中断处理程序会自愿的将CPU让出(yield)给线程调度器，让其他线程运行。<br>线程状态：</p><ol><li>RUNNING，线程当前正在某个CPU上运行</li><li>RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行</li><li>SLEEPING，这个状态意味着线程在等待一些I&#x2F;O事件，它只会在I&#x2F;O事件发生了之后运行</li></ol><hr><h2 id="xv6线程切换"><a href="#xv6线程切换" class="headerlink" title="xv6线程切换"></a>xv6线程切换</h2><p>用户程序在运行时，实际上是用户进程中的一个用户线程在运行。如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的<code>trapframe</code>中，同时属于这个用户程序的内核线程被激活。<br>如果XV6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中第一个进程的内核线程会被切换到第二个进程的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回到用户空间也是通过恢复<code>trapframe</code>完成的。</p><p>完整过程（以时钟切换为例）：</p><ol><li>定时器中断强迫CPU从用户空间切换到内核，用户空间的代码保存在<code>trapframe</code>中。</li><li>内核运行<code>usertrap</code>，这时候运行的是进程1的内核线程。</li><li>调用<code>swtch</code>函数，保存进程1的内核线程寄存器到<code>context</code>对象，在<code>proc</code>结构体中有一个<code>context</code>。(用户寄存器在<code>trapframe</code>，内核线程寄存器在<code>context</code>)。</li><li><code>swtch</code>函数恢复原来在这个CPU上的调度器线程保存的寄存器和stack pointer,<code>swtch</code>函数返回后，CPU寄存器被设置为调度器线程的上下文，然后就在调度下线程的context下执行<code>scheduler</code>函数。</li><li><code>scheduler</code>函数把P1设置成RUNABLE状态，查找下一个RUNABLE进程，再次调用<code>swtch</code>函数, <code>swtch</code>函数完成后，返回到了新线程的上下文中。<blockquote><p>整个xv6中一个CPU核对应一个内核调度线程，它在系统启动时创建。这个内核调度线程是一个死循环，它不断地选择可运行的进程并进行上下文切换，以实现多进程并发。XV6的start.s文件，可以看到为每个CPU核设置好调度器线程。</p></blockquote></li></ol><hr><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><h3 id="yield函数"><a href="#yield函数" class="headerlink" title="yield函数"></a>yield函数</h3><p><code>yield</code>是线程切换的第一步。当触发时钟中断时，会调用<code>yield</code>函数，当前进程会出让CPU并让另一个进程运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);<br>  p-&gt;state = RUNNABLE;<br>  sched();<br>  release(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要内容是加锁，防止一个线程在多个CPU核上被调度。将进程的状态改为RUNABLE，表示让出CPU，随后执行<code>sched</code>函数。</p><h3 id="sched函数"><a href="#sched函数" class="headerlink" title="sched函数"></a>sched函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> intena;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(!holding(&amp;p-&gt;lock))<br>    panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br>  <span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;<br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  mycpu()-&gt;intena = intena;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="swtch函数"><a href="#swtch函数" class="headerlink" title="swtch函数"></a>swtch函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">.globl swtch<br>swtch:<br>        sd ra, 0(a0)<br>        ....省略<br><br>        ld ra, 0(a1)<br>        ....省略<br>        ret<br></code></pre></td></tr></table></figure><blockquote><p>a0是p-&gt;context的地址，a1是cpu中的context结构体地址</p></blockquote><ol><li>会将当前的内核线程的寄存器(ra,sp,s0等)保存到p-&gt;context中,proc结构体中的context字段就是用来保存该进程内核线程寄存器的。</li><li>然后会把cpu中的context赋值给(ra,sp,s0)等寄存器<blockquote><p><strong>CPU结构体中的context保存了当前CPU核的调度器线程的寄存器!!!</strong><br>内核调度线程没有进程与之对应，并且一个CPU核只有一个内核调度线程，所以把它所需要的context直接放到了cpu的context结构体中保存。而cpu中context结构体中有一个返回地址一定就是scheduler函数的某一条指令。</p></blockquote></li></ol><ul><li><p>swtch函数中只保存并恢复了14个寄存器</p><blockquote><p><strong>switch是按照一个普通函数来调用的</strong>，对于有些寄存器，<code>swtch</code>函数的调用者默认<code>swtch</code>函数会做修改，所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以<code>swtch</code> 函数里只需要保存Callee Saved Register就行。</p></blockquote></li><li><p>返回地址的妙用</p><blockquote><p>正因为switch是按照一个普通函数来调用的，在这里，所以<code>ra</code>寄存器存储的是内核线程1的返回地址，随后<code>ld ra, 0(a1)</code>指令，<strong>把返回地址给换了</strong>，换成了CPU处理器调度器线程的返回地址，以及后面的一些上下文。随后<code>swtch</code>函数完成后，返回到了<code>scheduler</code>函数。</p></blockquote></li></ul><h3 id="scheduler函数"><a href="#scheduler函数" class="headerlink" title="scheduler函数"></a>scheduler函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br><br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (;;)<br>  &#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    intr_on();<br><br>    <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)<br>    &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span> (p-&gt;state == RUNNABLE)<br>      &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调度器线程在<code>scheduler</code>函数中也会调用了<code>swtch</code>函数，同样的，它把CPU上寄存器换成了新线程的，并把调度器线程的寄存器保存到了<code>mycpu()-&gt;context</code>中。所以我们从<code>swtch</code>函数返回时，如果不考虑调度器线程在里面的作用，实际上是返回到了对于<code>switch</code>的另一个调用，而不是调度器线程中的调用。<strong>我们返回到的是调度到的新进程在很久之前对于switch的调用</strong>。这就是线程切换的核心。</p><blockquote><p>在课程的示例中，P1线程由于定时器的中断而被调度，执行<code>yield</code>函数，<code>sched</code>函数，<code>swtch</code>函数后而被阻塞。假设P2线程正在执行，随后P2线程也经过同样的过程再执行调度线程，再执行P1,P1被唤醒的刚开始执行指令的地址就是<code>sched</code>函数中的<code>swtch</code>的返回地址。<br>如果不是因为定时器中断发生的切换，ra寄存器可能指向其他位置。</p></blockquote><p>scheduler函数又会调用swtch函数，但参数稍有不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;state = RUNNING;<br>c-&gt;proc = p;<br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br></code></pre></td></tr></table></figure><blockquote><p>这样就把当前调度器线程的寄存器传入cpu的context结构体中。再把寄存器的值换成调度的新进程的内核线程的context。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统层级结构</title>
    <link href="/2023/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/9.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/9.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-文件系统组织架构"><a href="#1-文件系统组织架构" class="headerlink" title="1.文件系统组织架构"></a>1.文件系统组织架构</h2><p><img src="https://fanxiao.tech/img/posts/MIT_6S081/image-20210207194130429.png" alt="image-20210207194130429"></p><ul><li><p><code>disk</code>层：对硬盘上的块进行读写操作</p></li><li><p><code>buffer cache</code>层：在内存中对磁盘块进行缓存，并确保只有1个内核进程能在一段时间内修改文件块上存储的数据。</p></li><li><p><code>logging</code>层：让更高的层级能够将对文件块的所有<code>update</code>打包到一个<code>transaction</code>中，从而能保证所有文件块能够在将要崩溃时原子地进行<code>update</code></p></li><li><p><code>inode</code>层：为每个文件提供独一无二的inode number</p></li><li><p><code>directory</code>层：每个文件夹也作为一个特殊的inode结构体，不过内容是一条一条的entry</p></li><li><p><code>pathname</code>层：将文件夹组织为层级，解析路径、</p></li><li><p><code>file descriptor</code>层：将所有的资源都抽象为<code>struct file</code>,如设备，文本文件，管道等</p><hr></li></ul><h2 id="2-Disk-层"><a href="#2-Disk-层" class="headerlink" title="2.Disk 层"></a>2.Disk 层</h2><p>xv6文件系统的磁盘块布局如下：</p><p><img src="https://fanxiao.tech/img/posts/MIT_6S081/image-20210207200046544.png" alt="image-20210207200046544"></p><ul><li><p><code>block 0</code>：启动区域，文件系统不会使用，包含了操作系统启动所需要的代码</p></li><li><p><code>blcok 1</code>: <code>superblock</code>，存储了文件系统的元数据（block的大小、block的数目、inode的数目等），里面有一个mkfs的程序，用来构建初始的文件系统</p></li><li><p><code>block 2-31</code>：<code>log block</code></p></li><li><p><code>block 32-44</code>: <code>inode</code>，一个<code>inode</code>的大小为64字节，一个<code>block</code>的大小为1024字节，因此<code>block32</code>为<code>inode 1-16</code>，block33为<code>inode 17-32</code></p></li><li><p><code>block 45 bitmap block</code>，用来跟踪哪些<code>block</code>是在使用</p></li><li><p>最后从<code>block 46</code>开始是<code>data block</code>，要么是在<code>bitmap</code>中被标记为空闲状态，要么存储了文件&#x2F;文件夹的内容</p><hr></li></ul><h2 id="3-Buffer-cache层"><a href="#3-Buffer-cache层" class="headerlink" title="3.Buffer cache层"></a>3.Buffer cache层</h2><h3 id="buffer-cache层的作用"><a href="#buffer-cache层的作用" class="headerlink" title="buffer cache层的作用"></a>buffer cache层的作用</h3><ol><li>将对磁盘块的访问权限进行同步，保证内存中只保存一个该磁盘块的拷贝，且一次只有一个内核线程访问这个拷贝，但同时可以有多个对这个<code>block</code>的引用</li><li>将被频繁访问的块缓存到内存中(局部性原理)</li></ol><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p><code>bcache</code>就是内存中对硬盘<code>block</code>的缓冲，<code>head</code>的作用是把<code>bcache</code>组织为一个链表，缓冲区的使用早晚就是通过<code>head</code>来判断的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br></code></pre></td></tr></table></figure><p>buffer cache有两个接口，分别是<code>bread()</code>和<code>bwrite()</code>。<br><code>bread</code>通过<code>bget</code>获取一个指定了设备<code>dev</code>和<code>blockno</code>的<code>buf *</code>，这是从硬盘指定的块中获取的一个缓冲数据结构体。<code>valid</code>表示的是内存中的某个<code>block</code>有无磁盘块的一份拷贝，如果没有就要调用<code>virtio_disk_rw</code>函数从磁盘写到内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，可以允许多个文件指向内存中同一个<code>buffer</code>，这里的替换算法也是相当简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为什么要<code>acquiresleep</code>?<blockquote><p>获取这个锁之后立即让这个进程进入睡眠，一旦这个锁可用，该线程就会立刻被唤醒。</p></blockquote></li></ul><p><code>bwrite</code>是向硬盘指定块写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>brelse</code>是释放操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>  <br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-Block-层"><a href="#4-Block-层" class="headerlink" title="4.Block 层"></a>4.Block 层</h2><p>block allocator为磁盘的是否空闲的状态准备了一个bitmap，每一位对应一个磁盘块，0表示空闲1表示正在使用，<code>mkfs</code>负责设置这些位。</p><p><code>sb</code>是一个super block,它记录了文件系统一些基本信息。<br><code>BBLOCK</code>宏是判断某个逻辑块号的信息在哪个<code>bitmap</code>块中。<br>一个<code>bitmap</code>块中，总共用<code>BSIZE</code>个字节，也就是<code>BPB</code>个bit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPB           (BSIZE*8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span><br></code></pre></td></tr></table></figure><p>下面的代码中<code>bp</code>是获取到的<code>bitmap</code>块，一个<code>bitmap</code>的每一个bit都用来标记该<code>blockno</code>是不是空闲的。<code>b</code>是遍历到的位图的第0个bit表示的逻辑块号。<code>bi</code>就是偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">balloc</span><span class="hljs-params">(uint dev)</span><br>&#123;<br>  <span class="hljs-type">int</span> b, bi, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  bp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(b = <span class="hljs-number">0</span>; b &lt; sb.size; b += BPB)&#123;<br>    bp = bread(dev, BBLOCK(b, sb));<br>    <span class="hljs-keyword">for</span>(bi = <span class="hljs-number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;<br>      m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// Is block free?</span><br>        bp-&gt;data[bi/<span class="hljs-number">8</span>] |= m;  <span class="hljs-comment">// Mark block in use.</span><br>        log_write(bp);<br>        brelse(bp);<br>        bzero(dev, b + bi);<br>        <span class="hljs-keyword">return</span> b + bi;<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;balloc: out of blocks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样还需要<code>bfree</code>函数释放硬盘块。</p><hr><h2 id="5-Inode-层"><a href="#5-Inode-层" class="headerlink" title="5.Inode 层"></a>5.Inode 层</h2><p>这里就开始涉及文件是如何组织的了。</p><ol><li><code>inode</code>:内存中的结构，用于文件描述。</li><li><code>dinode</code>:硬盘中的结构，64字节大小，例如<code>inode block</code>中就是存放这些结构体的。它们在硬盘中占据连续的一些块。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-type">short</span> major;<br>  <span class="hljs-type">short</span> minor;<br>  <span class="hljs-type">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// File type</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> nlink;          <span class="hljs-comment">// Number of links to inode in file system</span><br>  uint size;            <span class="hljs-comment">// Size of file (bytes)</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>也就是说内存中的inode是active inodes，即内存中有C指针指向这个inode,ref是指向这个inode指针的数量。ref为0时要删除这个inode</p></blockquote></li></ol><p><code>NDIRECT</code>个<code>addr</code>叫做direct blocks，最后一个<code>addr</code>给出了indirect block的地址，因此一个文件的前12kB（<code>NDIRECT</code> x <code>BSIZE</code>）可以从inode中的direct block <code>addr</code>直接读取，后256kB（<code>NINDIRECT</code> x<code>BSIZE</code>）可以通过indirect block addr翻译得到。因此xv6支持的最大的文件大小为268kB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">inode</span>[<span class="hljs-title">NINODE</span>];</span><br>&#125; itable;<br></code></pre></td></tr></table></figure><p>内存中的itable也是对<code>dinode block</code>的缓存,也就是<code>inode cache</code> ,<code>inode</code>中的valid就是对这个缓存是否有效的标记。<br><code>iget</code>函数和<code>iput</code>函数在此之上实现对inode指针的获取和释放。<br>典型用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ip = iget(dev, inum);<br>ilock(ip);<br>...examine and modify ip-&gt;xxx<br><span class="hljs-title function_">iunlock</span><span class="hljs-params">(ip)</span>;<br>iput(ip);<br></code></pre></td></tr></table></figure><p><code>iget</code>返回了一个直到调用<code>iput</code>都有效的<code>inode</code>，任何代码均可同时访问，因此可以有很多指针指向同一个<code>inode</code>。</p><p><code>ialloc</code>负责从硬盘上的inode blocks中寻找空闲的inode，当找到之后将新的type写入到disk中然后通过调用<code>iget</code>返回一个内存中的inode（将这个inode写入到inode cache）中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">ialloc</span><span class="hljs-params">(uint dev, <span class="hljs-type">short</span> type)</span><br>&#123;<br>  <span class="hljs-type">int</span> inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.ninodes; inum++)&#123;<br>    bp = bread(dev, IBLOCK(inum, sb));<br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;<br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-built_in">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      log_write(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      brelse(bp);<br>      <span class="hljs-keyword">return</span> iget(dev, inum);<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>iget</code>在inode cache中查找和传入的device、inode no相同的active entry，如果找到了这个entry就返回对这个inode的一个新的指针，否则找到一个空的entry将其dev、inum等设置为对应的数值，并设置valid为0待后续从block中读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">iget</span><span class="hljs-params">(uint dev, uint inum)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// Is the inode already cached?</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;icache.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;icache.lock);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode cache entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;icache.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>bmap()</code>负责获取inode中的第n块data block的地址。当<code>bn&lt;NDIRECT</code>时直接返回<code>ip-&gt;addrs[bn]</code>，如果没有这个地址就调用<code>balloc</code>分配一个data block。当<code>NDIRECT&lt;bn&lt;NINDIRECT</code>时先<code>bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT])</code>，然后获取<code>bp-&gt;data[bn-NDIRECT]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-Directory层"><a href="#6-Directory层" class="headerlink" title="6.Directory层"></a>6.Directory层</h2><p>和文件类似，只不过这个inode结构体类型为T_DIR,数据部分是<code>directory entry</code>,每一个<code>entry</code>数据类型为<code>struct dirent</code>,因为每一个<code>entry</code>仍旧是一个条目，所以还应该包含一个<code>inode number</code>.<br><code>dirlookup</code> 是在directoy中查找名称为<code>name</code>的<code>directoy entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">dirlookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)</span><br>&#123;<br>  uint off, inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    panic(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(namecmp(name, de.name) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// entry matches path element</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> iget(dp-&gt;dev, inum);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>readi</code>函数就是在<code>struct inode* ip</code>的文件读取<code>off</code>偏移的内容，这里需要用到<code>bmap</code>函数来打开逻辑块号，再把内容复制到内核空间中或者用户空间(根据<code>user_dst</code>为1或者为0) 中地址为<code>dst</code>的地方去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readi</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span> (off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (off + n &gt; ip-&gt;size)<br>    n = ip-&gt;size - off;<br><br>  <span class="hljs-keyword">for</span> (tot = <span class="hljs-number">0</span>; tot &lt; n; tot += m, off += m, dst += m)<br>  &#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off / BSIZE));<br>    m = min(n - tot, BSIZE - off % BSIZE);<br>    <span class="hljs-keyword">if</span> (either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="hljs-number">-1</span>)<br>    &#123;<br>      brelse(bp);<br>      tot = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dirlink</code>讲一个新的<code>directory entry</code>写入文件夹<code>dp</code>中，查找<code>dp</code>中尚未分配的<code>entry</code>,如果找到就要用<code>writei</code>在文件中写入内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">dirlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint inum)</span><br>&#123;<br>  <span class="hljs-type">int</span> off;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// Check that name is not present.</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Look for an empty dirent.</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);<br>  de.inum = inum;<br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-Pathname-层"><a href="#7-Pathname-层" class="headerlink" title="7.Pathname 层"></a>7.Pathname 层</h2><p><code>namei</code>函数对pathname进行解析，返回<code>inode</code>。<code>namei</code>调用了<code>namex</code>函数，<code>namex</code>函数传入参数<code>nameiparent</code>,当为1是返回的<code>inode</code>是传入path的父文件夹。<br>例如，如果path地第一个字符为&#x2F;,则表示这是绝对路径，那么首先需要得到<code>ROOTINO</code>的<code>inode</code>；否则就是相对路径，则要把<code>myproc-&gt;cwd</code>的引用计数加1,<code>proc</code>中的<code>cwd</code>类型是<code>struct inode*</code>。<br>然后不断用<code>skipelem</code>函数解析path中的&#x2F;,不断查找下一级的<code>inode</code>,最后<code>namei</code>返回目标<code>inode</code>。<br>主要内容见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namex</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    ip = iget(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span><br>    ip = idup(myproc()-&gt;cwd);<br><br>  <span class="hljs-keyword">while</span>((path = skipelem(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// Stop one level early.</span><br>      iunlock(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((next = dirlookup(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    iunlockput(ip);<br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-File-descriptor层"><a href="#8-File-descriptor层" class="headerlink" title="8.File descriptor层"></a>8.File descriptor层</h2><p>File descriptor层让UNIX中所有的资源，包括设备都可以同一表示为文件。每个打开的文件都可以用<code>struct file</code>来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-type">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-type">char</span> readable;<br>  <span class="hljs-type">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-type">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>open</code>可以增加文件，一个进程打开的文件都保存在结构体<code>proc</code>中的<code>struct file *ofile[NOFILE]</code>数组中。<br>所有打开的文件都保存在global file table，即<code>ftable</code>中。<br><code>filealloc</code>负责在file table中分配一个文件，在<code>ftable</code>中扫描<code>ref==0</code>的file，增加<code>ref</code>后返回这个<code>file *</code>。<br><code>filedup</code>负责对这个file descriptor的<code>ref++</code>并返回这个文件的<code>file *</code>。<br><code>fileclose</code>负责对file descriptor的<code>ref–</code>，当<code>ref==0</code>时根据这个file的类型释放掉<code>pipe</code>或者<code>inode</code>。</p><hr><h2 id="9-相关系统调用"><a href="#9-相关系统调用" class="headerlink" title="9.相关系统调用"></a>9.相关系统调用</h2><p><code>sys_link</code>和<code>sys_unlink</code>这两个系统调用实现对<code>inode</code>的增加或者删除引用。<br><code>sys_link</code>传入一个参数<code>old</code>和一个参数<code>new</code>,<code>new</code>是需要链接到<code>old</code>的路径。<code>sys_link</code>首先增加<code>struct inode* ip</code>的<code>nlink</code>,然后调用<code>nameiparent</code>查找<code>new</code>的父文件夹，调用<code>dirlink</code>在父文件夹中创建一个名为<code>new</code>的<code>directory entry</code>。<br>主要内容见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_link</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">dp</span>, *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, old, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, new, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((ip = namei(old)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ilock(ip);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ip-&gt;nlink++;<br>  iupdate(ip);<br>  iunlock(ip);<br><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(new, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  ilock(dp);<br>  <span class="hljs-keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    <span class="hljs-keyword">goto</span> bad;<br>  &#125;<br>  iunlockput(dp);<br>  iput(ip);<br><br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad:<br>  ilock(ip);<br>  ip-&gt;nlink--;<br>  iupdate(ip);<br>  iunlockput(ip);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>系统调用<code>open</code>可能会调用<code>create</code>函数。<br><code>create</code>首先调用<code>nameiparent</code>获取父文件夹，然后调用<code>dirlookup</code>来查看这个文件夹下是否已经存在同名的inode，如果存在且调用这个<code>create</code>的是<code>open</code>来创建一个文件的话，那么直接返回这个inode。如果这个名称不存在，则调用ialloc。如果是<code>mkdir</code>调用的<code>create</code>（即<code>type==T_DIR</code>)，则要创建<code>..</code>和<code>.</code>作为对父级inode和当前inode的引用，最终将当前的<code>name</code> <code>dirlink</code>到当前inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">dp</span>;</span><br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  ilock(dp);<br><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip;<br>    iunlockput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  ilock(ip);<br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  iupdate(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    iupdate(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-keyword">if</span>(dirlink(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || dirlink(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  iunlockput(dp);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU_15445：Project C++ Primer</title>
    <link href="/2023/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Project0/"/>
    <url>/2023/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Project0/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>书到用时方恨少，这个Project虽说前缀树我在之前就学过，但C++的基础知识还是很不牢固，所以先把一些需要用的知识点要在这里再记一下。</p><h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><ul><li>左值是可以放在赋值号左边的，左值必须要在内存中有实体。</li><li>右值出现在赋值号右边；右值可以在寄存器也可以在内存中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = num;<br><span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>上面。<code>num</code>有地址是左值，<code>b</code>是对<code>num</code>的引用，所以这是左值引用。而10是右值，所以<code>c</code>是右值引用，这里是错误的。<br>但这样又是可以的：<br><code>const int&amp; c =10</code>,允许使用常量左值引用操作右值。<br>实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><h4 id="右值引用介绍"><a href="#右值引用介绍" class="headerlink" title="右值引用介绍"></a>右值引用介绍</h4><p>右值引用也必须立即进行初始化操作，且<strong>使用右值进行初始化</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>上面的操作都是正确的。<br>右值引用 引用 右值，会使右值被存储到特定的位置。</p><ul><li>左值引用的短板<br>传值传参和传值返回都会产生拷贝，有的甚至是深拷贝，代价很大。而左值引用的实际意义在于做参数和做返回值都可以减少拷贝，从而提高效率。但是，左值引用的短板是不能够<strong>引用局部变量</strong>。</li></ul><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 接收一个 std::vector&lt;int&gt; 的右值引用参数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">processVector</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; vec)</span> &#123;<br>    <span class="hljs-comment">// 对右值引用进行操作，而不进行拷贝</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// 将 nums 作为右值传递给函数</span><br>    processVector(<span class="hljs-built_in">std</span>::move(nums));<br><br>    <span class="hljs-comment">// 此时 nums 已被移动，不再可用</span><br>    <span class="hljs-comment">// 这里访问 nums 将导致未定义的行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>右值引用的特性是可以绑定到临时对象（右值）上的引用，而临时对象在表达式求值后就会被销毁。因此，当我们将<code>nums</code>通过<code>std::move()</code>转换为右值引用后，它的值类别变为右值，而不再是左值。<br>在函数参数中接收到右值引用 vec 后，我们可以直接操作它，而不需要进行对象拷贝。这是因为右值引用的特性允许我们“窃取”临时对象的资源，而不是进行拷贝。在这种情况下，我们可以直接使用 <code>vec</code> 的资源（例如 <code>std::vector</code> 中的数据），而不需要进行额外的拷贝操作。</p><h4 id="move移动语义"><a href="#move移动语义" class="headerlink" title="move移动语义"></a>move移动语义</h4><p>作用是将一个左值强制转化为右值，以实现移动语义。左值被 move 后变为右值，于是右值引用可以引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> t = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int&amp;&amp; rrt = t; // 编译报错，不能直接引用左值</span><br><br><span class="hljs-comment">// 2.但是右值引用可以引用被move的左值</span><br><span class="hljs-type">int</span>&amp;&amp; rrt = <span class="hljs-built_in">std</span>::move(t);  <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>右值引用意义和移动构造函数:<br>右值做参数，那么就会调用移动构造，而调用移动构造就会减少拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次移动构造就会少做一次深拷贝。</p><h4 id="forward完美转发"><a href="#forward完美转发" class="headerlink" title="forward完美转发"></a>forward完美转发</h4><p>有了<code>move</code>函数之后，我们又遇到了一个新的问题：</p><p>按照上面的写法，处理临时变量用右值引用<code>T&amp;&amp;</code>，处理普通变量用<code>const</code>引用<code>const T&amp;</code>，我们需要分别建立两个函数，然后入参使用不同的类型，每个函数都要写两遍。<br>那么能不能避免重复，将<code>T &amp;&amp;</code>类型和<code>const T &amp;</code>类型合二为一呢？</p><blockquote><p>答案就是：<code>forward</code>函数，<code>std::forward</code>也被称为完美转发，即：保持原来的值属性不变：</p></blockquote><ul><li>如果原来的值是左值，经<code>std::forward</code>处理后该值还是左值。</li><li>如果原来的值是右值，经<code>std::forward</code>处理后它还是右值。<br>这样一来，我们就可以使用<code>forward</code>函数对入参进行封装，从而保证了入参的统一性，从而可以实现一个方法处理两种类型！<br>正因为如此，<code>forward</code>函数被大量用在了入参值类型情况不确定的C++模板中！</li></ul><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><code>std::unique_ptr</code>是一个智能指针类模板，用于管理动态分配的对象。它提供了独占所有权的语义，意味着一个<code>unique_ptr</code>指针可以拥有对一个对象的唯一所有权，并负责在其生命周期结束时自动释放该对象。</p><ul><li><code>move</code>: 转移所有权，将原指针置空。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">ptr1</span><span class="hljs-params">(new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; ptr2 = <span class="hljs-built_in">std</span>::move(ptr1); <span class="hljs-comment">// 移动所有权</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>vec.push_back(<span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>)); <span class="hljs-comment">// 移动 unique_ptr 到容器中</span><br></code></pre></td></tr></table></figure><ul><li><code>reset</code>:更改所有权。</li></ul><ol><li><code>ptr.reset()</code>:销毁对象，指针置空。</li><li><code>ptr.reset(new_ptr)</code>:智能指针指向新的对象，原对象销毁。</li></ol><ul><li><code>get</code>：<code>get()</code>是<code> unique_ptr</code>类的成员函数，它返回指向<code>unique_ptr</code>所拥有的对象的指针，即原始指针。</li></ul><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说了这么多，如果感觉还不是很懂，就直接来看代码吧。<br>我这里只介绍一些比较重要的函数。</p><h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">TrieNode(TrieNode &amp;&amp;other_trie_node) noexcept &#123;<br>    key_char_ = other_trie_node.key_char_;<br>    is_end_ = other_trie_node.is_end_;<br>    children_.swap(other_trie_node.children_);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这就是移动构造函数。<br>调用<code> children_.swap(other_trie_node.children_)</code>，使用<code> std::swap</code>函数将 <code>other_trie_node</code> 的 <code>children_</code> 成员变量与当前对象的 <code>children_</code>成员变量进行交换。这样做可以实现高效的移动操作，避免不必要的复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *<span class="hljs-title function_">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; &amp;&amp;child)</span> &#123;<br>    <span class="hljs-keyword">if</span> (HasChild(key_char) || key_char != child-&gt;key_char_) &#123;<br>      <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    children_[key_char] = <span class="hljs-built_in">std</span>::move(child);<br>    <span class="hljs-keyword">return</span> &amp;children_[key_char];<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *<span class="hljs-title function_">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> &#123;<br>    <span class="hljs-keyword">auto</span> node = children_.find(key_char);<br>    <span class="hljs-keyword">if</span> (node != children_.end()) &#123;<br>      <span class="hljs-keyword">return</span> &amp;(node-&gt;second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>为什么返回的都是智能指针的指针？</p><blockquote><p>因为智能指针对一个对象有唯一的所有权,如果我们在字典树的操作中需要不断迭代的话，需要移动指针，那就需要用到智能指针的指针了。</p></blockquote></li><li><p>为什么要<code>children_[key_char] = std::move(child)</code>?</p><blockquote><p>child 是一个右值引用的 std::unique_ptr<TrieNode>，应该直接将其移动给 children_[key_char]。child 的所有权转移给 children_[key_char]，而不是重新构造一个新的 std::unique_ptr。这样做可以避免不必要的内存分配和析构，并正确地转移所有权。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RemoveChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> &#123;<br>    <span class="hljs-keyword">auto</span> node = children_.find(key_char);<br>    <span class="hljs-keyword">if</span> (node != children_.end()) &#123;<br>      node-&gt;second.reset();<br>      children_.erase(key_char);<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="TrieNodeWithValue"><a href="#TrieNodeWithValue" class="headerlink" title="TrieNodeWithValue"></a>TrieNodeWithValue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value) : TrieNode(<span class="hljs-built_in">std</span>::forward&lt;TrieNode&gt;(trieNode)) &#123;<br>    value_ = value;<br>    SetEndNode(<span class="hljs-literal">true</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>移动构造函数，把<code>trieNode</code>作为右值传递给<code>TrieNodeWithValue</code>，实现资源的转移。</p><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br>  <span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key, T value)</span> &#123;<br>     <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    latch_.WLock();<br>    <span class="hljs-keyword">auto</span> cur = &amp;root_;<br>    <span class="hljs-comment">// latch_.WLock();</span><br>    <span class="hljs-keyword">auto</span> c = key.begin();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">auto</span> x = c++;<br>      <span class="hljs-keyword">if</span> (c == key.end()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cur-&gt;get()-&gt;HasChild(*x)) &#123;<br>        cur = cur-&gt;get()-&gt;GetChildNode(*x);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur = cur-&gt;get()-&gt;InsertChildNode(*x, <span class="hljs-built_in">std</span>::make_unique&lt;TrieNode&gt;(*x));<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">char</span> ch = key.back();<br>    <span class="hljs-keyword">auto</span> end_node = cur-&gt;get()-&gt;GetChildNode(ch);<br><br>    <span class="hljs-keyword">if</span> (end_node != nullptr &amp;&amp; end_node-&gt;get()-&gt;IsEndNode()) &#123;<br>      latch_.WUnlock();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (end_node != nullptr) &#123;<br>      <span class="hljs-keyword">auto</span> new_node = new TrieNodeWithValue&lt;T&gt;(<span class="hljs-built_in">std</span>::move(*(end_node-&gt;get())), value);<br>      end_node-&gt;reset(new_node);<br><br>      latch_.WUnlock();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果为空</span><br>    cur = cur-&gt;get()-&gt;InsertChildNode(ch, <span class="hljs-built_in">std</span>::make_unique&lt;TrieNode&gt;(ch));<br>    <span class="hljs-comment">// 现在还是一个中间节点，还不是TrieNodeWithValue</span><br>    <span class="hljs-keyword">auto</span> new_node = new TrieNodeWithValue&lt;T&gt;(<span class="hljs-built_in">std</span>::move(**cur), value);<br>    cur-&gt;reset(new_node);<br>    latch_.WUnlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    latch_.WLock();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *&gt; storage;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *node = &amp;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key) &#123;<br>      storage.emplace_back(node);<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *next = node-&gt;get()-&gt;GetChildNode(ch);<br><br>      <span class="hljs-keyword">if</span> (next == nullptr) &#123;<br>        latch_.WUnlock();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      node = next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node-&gt;get()-&gt;HasChildren()) &#123;<br>      <span class="hljs-comment">// node = node-&gt;get()-&gt;GetChildNode(key[key.size()-1]);</span><br>      node-&gt;get()-&gt;SetEndNode(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = storage.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 想一下， root 节点是不记录字符的</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *pre = storage[i];<br>        <span class="hljs-keyword">if</span> ((i &lt; static_cast&lt;<span class="hljs-type">int</span>&gt;(key.size() - <span class="hljs-number">1</span>)) &amp;&amp; (node-&gt;get()-&gt;IsEndNode() || node-&gt;get()-&gt;HasChildren())) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pre-&gt;get()-&gt;RemoveChildNode(key[i]);<br>        node = pre;<br>      &#125;<br>    &#125;<br><br>    latch_.WUnlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br>  T <span class="hljs-title function_">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key, <span class="hljs-type">bool</span> *success)</span> &#123;<br>    *success = <span class="hljs-literal">true</span>;<br>    latch_.RLock();<br>    <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> cur = &amp;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key) &#123;<br>      <span class="hljs-keyword">if</span> (cur-&gt;get()-&gt;HasChild(ch)) &#123;<br>        cur = cur-&gt;get()-&gt;GetChildNode(ch);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        *success = <span class="hljs-literal">false</span>;<br>        latch_.RUnlock();<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!cur-&gt;get()-&gt;IsEndNode()) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      latch_.RUnlock();<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> flag_node = dynamic_cast&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur-&gt;get());<br>    <span class="hljs-keyword">if</span> (flag_node == nullptr) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      latch_.RUnlock();<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    latch_.RUnlock();<br>    <span class="hljs-keyword">return</span> flag_node-&gt;GetValue();<br>  &#125;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池的C语言实现</title>
    <link href="/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1.任务队列"></a>1.任务队列</h2><p>线程池结构体就是存储任务队列的。很明显，任务中需要有执行函数的函数地址和传入的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> (*function)(<span class="hljs-type">void</span> *arg);<br>    <span class="hljs-type">void</span> *arg;<br>&#125; Task;<br></code></pre></td></tr></table></figure><p>在这里，我们的<code>function</code>函数只接受单个参数。</p><ul><li>如果需要多个参数呢？我在github上给出了一小段实现代码。<br><a href="https://github.com/BlackGhostLzc/ThreadPool.git">这是我的github仓库</a><br>其实就是需要一个参数结构体<code>MyParam</code>，<code>function</code>中传入的<code>arg</code>类型转换为<code>MyParam</code>就行了。</li></ul><hr><h2 id="2-线程池定义"><a href="#2-线程池定义" class="headerlink" title="2.线程池定义"></a>2.线程池定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadPool</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 任务队列</span><br>    Task *taskQ;<br>    <span class="hljs-type">int</span> queueCapacity;<br>    <span class="hljs-type">int</span> queueSize; <span class="hljs-comment">// 当前任务个数</span><br>    <span class="hljs-type">int</span> queueFront;<br>    <span class="hljs-type">int</span> queueRear;<br><br>    <span class="hljs-type">pthread_t</span> managerID;  <span class="hljs-comment">// 管理者线程ID</span><br>    <span class="hljs-type">pthread_t</span> *threadIDs; <span class="hljs-comment">// 工作的线程ID</span><br><br>    <span class="hljs-type">int</span> minNum;  <span class="hljs-comment">// 最小线程数</span><br>    <span class="hljs-type">int</span> maxNum;  <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-type">int</span> busyNum; <span class="hljs-comment">// 忙的线程数</span><br>    <span class="hljs-type">int</span> liveNum; <span class="hljs-comment">// 存活的线程数</span><br>    <span class="hljs-type">int</span> exitNum; <span class="hljs-comment">// 要杀死的线程个数</span><br><br>    <span class="hljs-type">pthread_mutex_t</span> mutexPool; <span class="hljs-comment">// 锁整个线程池</span><br>    <span class="hljs-type">pthread_mutex_t</span> mutexBusy; <span class="hljs-comment">// 锁busyNum变量</span><br><br>    <span class="hljs-type">pthread_cond_t</span> notFull; <span class="hljs-comment">// 任务队列是否是满的</span><br>    <span class="hljs-type">pthread_cond_t</span> notEmpty;<br><br>    <span class="hljs-type">int</span> shutdown; <span class="hljs-comment">// 是否销毁线程池</span><br>&#125; ThreadPool;<br></code></pre></td></tr></table></figure><hr><h2 id="3-函数申明"><a href="#3-函数申明" class="headerlink" title="3.函数申明"></a>3.函数申明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建线程池</span><br>ThreadPool *<span class="hljs-title function_">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span>;<br><span class="hljs-comment">// 销毁线程池</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolDestroy</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// 往等待队列中添加任务,threadPool中的TaskQ</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadPoolAdd</span><span class="hljs-params">(ThreadPool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 忙碌线程的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// 存活线程的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// manager线程处理函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 存活线程处理函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 线程退出</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadExit</span><span class="hljs-params">(ThreadPool *pool)</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-函数代码实现"><a href="#4-函数代码实现" class="headerlink" title="4.函数代码实现"></a>4.函数代码实现</h2><h3 id="threadPoolCreate"><a href="#threadPoolCreate" class="headerlink" title="threadPoolCreate"></a>threadPoolCreate</h3><p>体会一下<code>do... while(0)</code>的妙用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c">ThreadPool *<span class="hljs-title function_">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ThreadPool));<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadpool fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        pool-&gt;threadIDs = (<span class="hljs-type">pthread_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadIDs fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(pool-&gt;threadIDs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        pool-&gt;minNum = min;<br>        pool-&gt;maxNum = max;<br>        pool-&gt;busyNum = <span class="hljs-number">0</span>;<br>        pool-&gt;liveNum = min; <span class="hljs-comment">// 和最小个数相等</span><br>        pool-&gt;exitNum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_cond_init(&amp;pool-&gt;notFull, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mutex or condition init fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 任务队列</span><br>        pool-&gt;taskQ = (Task *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Task) * queueSize);<br>        pool-&gt;queueCapacity = queueSize;<br>        pool-&gt;queueSize = <span class="hljs-number">0</span>;<br>        pool-&gt;queueFront = <span class="hljs-number">0</span>;<br>        pool-&gt;queueRear = <span class="hljs-number">0</span>;<br><br>        pool-&gt;shutdown = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 创建线程</span><br>        pthread_create(&amp;pool-&gt;managerID, <span class="hljs-literal">NULL</span>, manager, pool);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; min; ++i)<br>        &#123;<br>            pthread_create(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs)<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    <span class="hljs-keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ)<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    <span class="hljs-keyword">if</span> (pool)<br>        <span class="hljs-built_in">free</span>(pool);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadPoolDestroy"><a href="#threadPoolDestroy" class="headerlink" title="threadPoolDestroy"></a>threadPoolDestroy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolDestroy</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br><br>    <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭线程池</span><br>    pool-&gt;shutdown = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 阻塞回收管理者线程</span><br>    pthread_join(pool-&gt;managerID, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 唤醒阻塞的消费者线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;liveNum; ++i)<br>    &#123;<br>        pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>    &#125;<br>    <span class="hljs-comment">// 释放堆内存</span><br>    <span class="hljs-keyword">if</span> (pool-&gt;taskQ)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;threadIDs)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    &#125;<br><br>    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);<br>    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);<br>    pthread_cond_destroy(&amp;pool-&gt;notEmpty);<br>    pthread_cond_destroy(&amp;pool-&gt;notFull);<br><br>    <span class="hljs-built_in">free</span>(pool);<br>    pool = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="threadPoolAdd"><a href="#threadPoolAdd" class="headerlink" title="threadPoolAdd"></a>threadPoolAdd</h3><ul><li>为什么需要<code>while</code>循环<br>因为<code>pthread_cond_signal</code>会唤醒所有被条件变量阻塞的线程。<br>假设有两个生产者线程因为任务队列已经满了，而被阻塞在该位置。随后某个工作线程拿取了一个任务而使得任务队列没有满，接着<code>pthread_cond_signal</code>唤醒这两个生产者线程。这两个生产者线程首先都尝试获取<code>mutexPool</code>这把锁，然后只有一个生产者线程拿到了这把锁，执行到下一个<code>while</code>循环条件不满足就退出了，然后就可以把任务添加到任务队列中，最后释放掉了锁。此时任务队列又满了。<br>随后第二个生产者线程获得锁，仍在<code>while</code>循环中，它发现条件仍然满足，又调用<code>pthread_cond_wait</code>函数。<br>通过这样的机制，生产者线程就不会在已经满了的任务队列中继续添加任务了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">threadPoolAdd</span><span class="hljs-params">(ThreadPool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><br>    pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 阻塞生产者线程</span><br>        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;shutdown)<br>    &#123;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 添加任务</span><br>    pool-&gt;taskQ[pool-&gt;queueRear].function = func;<br>    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;<br>    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="hljs-number">1</span>) % pool-&gt;queueCapacity;<br>    pool-&gt;queueSize++;<br><br>    pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="threadPoolBusyNum、threadPoolAliveNum"><a href="#threadPoolBusyNum、threadPoolAliveNum" class="headerlink" title="threadPoolBusyNum、threadPoolAliveNum"></a>threadPoolBusyNum、threadPoolAliveNum</h3><p>这两个函数比较简单，不做说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-keyword">return</span> busyNum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-type">int</span> aliveNum = pool-&gt;liveNum;<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-keyword">return</span> aliveNum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>上一篇说过，<code>woker</code>函数是一个<code>while</code>循环，这很自然，因为线程池就是要复用线程，一个线程结束后应该转去执行其他任务，不应该结束。<br><code>while</code>循环下还有一个<code>while</code>循环，这和上面的逻辑很像。也是为了防止某个线程尝试获取空队列中的任务，这会引发难以预料的错误。<br>最后线程的执行就是一次函数调用<code>task.function(task.arg)</code><br>这里还需要注意对<code>busyNum</code>的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)arg;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-comment">// 当前任务队列是否为空</span><br>        <span class="hljs-keyword">while</span> (pool-&gt;queueSize == <span class="hljs-number">0</span> &amp;&amp; !pool-&gt;shutdown)<br>        &#123;<br>            <span class="hljs-comment">// 阻塞工作线程</span><br>            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);<br><br>            <span class="hljs-comment">// 判断是不是要销毁线程</span><br>            <span class="hljs-keyword">if</span> (pool-&gt;exitNum &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                pool-&gt;exitNum--;<br>                <span class="hljs-keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)<br>                &#123;<br>                    pool-&gt;liveNum--;<br>                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>                    threadExit(pool);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断线程池是否被关闭了</span><br>        <span class="hljs-keyword">if</span> (pool-&gt;shutdown)<br>        &#123;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>            threadExit(pool);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任务队列中取出一个任务</span><br>        Task task;<br>        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;<br>        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;<br>        <span class="hljs-comment">// 移动头结点</span><br>        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="hljs-number">1</span>) % pool-&gt;queueCapacity;<br>        pool-&gt;queueSize--;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_cond_signal(&amp;pool-&gt;notFull);<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());<br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum++;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>        task.function(task.arg);<br>        <span class="hljs-built_in">free</span>(task.arg);<br>        task.arg = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld end working...\n&quot;</span>, pthread_self());<br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum--;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h3><p><code>manager</code>是管理这些存活线程的线程。<br><code>exitNum</code>是需要杀死的线程数目。<br>在这里，增加存活线程和杀死存活线程的逻辑比较简单，详情见代码。<br>每一次最多增加或杀死<code>NUMBER</code>个存活线程。其实杀死存活线程的逻辑仍然在存活线程的<code>worker</code>函数中，<del>存活线程都是自杀的</del>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)arg;<br>    <span class="hljs-keyword">while</span> (!pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 每隔3s检测一次</span><br>        sleep(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 取出线程池中任务的数量和当前线程的数量</span><br>        pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-type">int</span> queueSize = pool-&gt;queueSize;<br>        <span class="hljs-type">int</span> liveNum = pool-&gt;liveNum;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br><br>        <span class="hljs-comment">// 取出忙的线程的数量</span><br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br><br>        <span class="hljs-comment">// 添加线程</span><br>        <span class="hljs-comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span><br>        <span class="hljs-keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)<br>        &#123;<br>            pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>            <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>                    counter++;<br>                    pool-&gt;liveNum++;<br>                &#125;<br>            &#125;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>        &#125;<br>        <span class="hljs-comment">// 销毁线程</span><br>        <span class="hljs-comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span><br>        <span class="hljs-keyword">if</span> (busyNum * <span class="hljs-number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)<br>        &#123;<br>            pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>            pool-&gt;exitNum = NUMBER;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>            <span class="hljs-comment">// 让工作的线程自杀</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMBER; ++i)<br>            &#123;<br>                pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadExit"><a href="#threadExit" class="headerlink" title="threadExit"></a>threadExit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">threadExit</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid = pthread_self();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == tid)<br>        &#123;<br>            pool-&gt;threadIDs[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池概述</title>
    <link href="/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-线程池的原理"><a href="#1-线程池的原理" class="headerlink" title="1.线程池的原理"></a>1.线程池的原理</h2><p>为什么需要线程池</p><ul><li>并发的线程数目较多，假如每一个线程都只是执行一个时间很短的任务就结束了，那么这样频繁的创建线程就会大大降低系统的效率，因为频繁创建和销毁线程都需要时间。</li></ul><p>线程池就是使得线程可以复用，一个线程执行完一个任务后并不销毁。线程池里的线程都是后台线程。如果某个线程在托管代码中空闲，那么线程池将插入另一个辅助线程来使所有处理器繁忙。如果线程池中的所有线程都繁忙，但队列中包含挂起的任务，那么线程池应该创建一个辅助线程但线程的总数不应超过最大值。超过最大值的线程需要排队。</p><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>存储需要处理的任务，由工作的线程来处理这些任务，线程池threadpool中就是存储这些待处理的任务。</p><blockquote><p>生产者消费者模型：生产者线程往任务队列里放任务，消费者线程把任务从队列中取出去。</p></blockquote><h4 id="工作的线程"><a href="#工作的线程" class="headerlink" title="工作的线程"></a>工作的线程</h4><p>任务队列的消费者。它们不停地读取任务队列，从中取出任务并处理。<br>如果任务队列为空，工作的线程将被阻塞；如果阻塞后有新的任务，由生产者将阻塞解除，工作线程开始工作。</p><h4 id="管理者线程"><a href="#管理者线程" class="headerlink" title="管理者线程"></a>管理者线程</h4><p>周期性地对任务队列中任务的数量以及处于忙碌状态的工作线程进行检测。</p><ul><li>任务过多的时候，可以创建一些新的工作线程</li><li>任务过少时，可以销毁一些工作线程</li></ul><hr><h2 id="2-项目介绍"><a href="#2-项目介绍" class="headerlink" title="2.项目介绍"></a>2.项目介绍</h2><h3 id="相关函数介绍"><a href="#相关函数介绍" class="headerlink" title="相关函数介绍"></a>相关函数介绍</h3><p>首先需要介绍几个<code>pthread.h</code>的库函数。<br><code>pthread_create(pthread_t *restrict thread, const pthread_attr_t`` *restrict attr, void *(*start_routine)(void *),void *restrict arg)</code>:创建线程, <code>start_rountine</code>作为线程起始执行函数，<code>arg</code>是传进该函数的参数。</p><p><code>pthread_join(pthread_t thread, void **retval)</code>:等待 <code>thread</code>线程结束，调用该函数的线程将被阻塞。</p><p><code>pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)</code>: 在调用这个函数前，都要获取<code>mutex</code>互斥锁。然后挂起该线程，阻塞的时候释放<code>mutex</code>这把锁（避免死锁）。等到再被唤醒的时候，他又会重新获取<code>mutex</code>这把锁。</p><p><code>pthread_signal(pthread_cond_t *cond)</code>:唤醒阻塞在<code>cond</code>条件变量上的所有线程，通常配合上面的函数一起使用。</p><h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h3><ol><li>存活线程：是等待执行任务的线程或者已经在执行任务的线程</li><li>忙碌线程：已经在执行任务的线程</li></ol><ul><li>需要创建一个管理者线程，传入一个函数指针<code>manage</code>,这个<code>manage</code>函数是一个<code>while</code>循环，它每隔一段时间就做一次检查，判断是否需要添加新的存活线程或者销毁存活线程。</li><li>创建多个存活线程，传入函数指针<code>worker</code>,同样，这个<code>worker</code>函数也是一个<code>while</code>循环，不断处理线程池中的待处理任务。在获取了线程池中的任务后，待处理任务的执行就是一个函数调用，函数完成后接着下一次的<code>while</code>循环判断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态机模型的应用</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件视角的操作系统</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：计算机硬件的状态机模型；回答以下问题："><a href="#本讲内容：计算机硬件的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：计算机硬件的状态机模型；回答以下问题："></a>本讲内容：计算机硬件的状态机模型；回答以下问题：</h2><ul><li>什么是计算机硬件？</li><li>计算机硬件和程序员之间是如何约定的？</li><li>听说操作系统也是程序。那到底是鸡生蛋还是蛋生鸡？</li></ul><h2 id="硬件与程序员的约定"><a href="#硬件与程序员的约定" class="headerlink" title="硬件与程序员的约定"></a>硬件与程序员的约定</h2><h3 id="Bare-metal-与程序员的约定"><a href="#Bare-metal-与程序员的约定" class="headerlink" title="Bare-metal 与程序员的约定"></a>Bare-metal 与程序员的约定</h3><blockquote><p>Bare-metal 是指在没有操作系统或者其他软件支持的情况下直接运行硬件的情况。</p></blockquote><ul><li><p>Bare-metal 与厂商的约定</p><ul><li>CPU Reset 后的状态 (寄存器值)</li></ul></li></ul><blockquote><p>   Reset 后处理器都从固定地址 (Reset Vector) 启动<br>     - 厂商自由处理这个地址上的值<br>     - Memory-mapped I&#x2F;O</p></blockquote><ul><li><p>厂商为操作系统开发者提供 Firmware</p><ul><li>管理硬件和系统配置</li><li>把存储设备上的代码加载到内存<ul><li>例如存储介质上的第二级 loader (加载器)</li><li>或者直接加载操作系统 (嵌入式系统)</li></ul></li></ul></li><li><p>Firmware 负责加载操作系统: BIOS vs UEFI<br>Legacy BIOS 把第一个可引导设备的第一个 512 字节加载到物理内存的 7c00 位置<br>此时处理器处于 16-bit 模式。</p></li><li><p>我们构造一个 512 字节的 “Master Boot Record” 作为磁盘镜像装在在模拟器上，并且用 gdb 观察指令在处理器上的执行。</p></li></ul><p>如何验证这一点？<br>计算机系统公理：你想到的就一定有人做到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asm">#define SECT_SIZE  512<br><br>.code16  // 16-bit assembly<br><br>// Entry of the code<br>.globl _start<br>_start:<br>  lea   (msg), %si   // R[si] = &amp;msg;<br><br>again:<br>  movb  (%si), %al   // R[al] = *R[si]; &lt;--+<br>  incw  %si          // R[si]++;           |<br>  orb   %al, %al     // if (!R[al])        |<br>  jz    done         //   goto done; --+   |<br>  movb  $0x0e, %ah   // R[ah] = 0x0e;  |   |<br>  movb  $0x00, %bh   // R[bh] = 0x00;  |   |<br>  int   $0x10        // bios_call();   |   |<br>  jmp   again        // goto again; ---+---+<br>                     //                |<br>done:                //                |<br>  jmp   .            // goto done; &lt;---+<br><br>// Data: const char msg[] = &quot;...&quot;;<br>msg:<br>  .asciz &quot;This is a baby step towards operating systems!\r\n&quot;<br><br>// Magic number for bootable device<br>.org SECT_SIZE - 2<br>.byte 0x55, 0xAA<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">mbr.img: mbr.S</span><br>gcc -ggdb -c <span class="hljs-variable">$&lt;</span><br>ld mbr.o -Ttext 0x7c00<br>objcopy -S -O binary -j .text a.out <span class="hljs-variable">$@</span><br><br><span class="hljs-section">run: mbr.img</span><br>qemu-system-x86_64 <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">debug: mbr.img</span><br>qemu-system-x86_64 -s -S <span class="hljs-variable">$&lt;</span> &amp;  <span class="hljs-comment"># Run QEMU in background</span><br>gdb -x init.gdb  <span class="hljs-comment"># RTFM: gdb (1)</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.img *.o a.out<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs init.gdb"># Kill process (QEMU) on gdb exits<br>define hook-quit<br>  kill<br>end<br><br># Connect to remote<br>target remote localhost:1234<br>file a.out<br>break *0x7c00<br>layout src<br>continue<br></code></pre></td></tr></table></figure><blockquote><p>前三行命令定义了一个名为 hook-quit 的 GDB 钩子。当用户在 GDB 中执行 quit 命令时，GDB 将自动执行 hook-quit 钩子中定义的命令。在这个例子中，hook-quit 钩子中只有一条命令 kill，它的作用是在用户退出 GDB 时杀死正在被调试的进程。这样可以确保在退出 GDB 后，被调试的进程也会被终止，避免出现进程僵死等问题。</p></blockquote><ul><li>如何用 gdb 调试 qemu<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">qemu-<span class="hljs-keyword">system</span>-x86_64 -s -S mbr.img<br></code></pre></td></tr></table></figure>-S： 把CPU暂停下来<br>-s： shorthand for -gdb tcp::1234       监听1234的端口</li></ul><p>所以我们可以启动一个 gdb </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span><br><span class="hljs-attribute">target</span> remote localhost::<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>这样就可以在gdb中调试这个qemu模拟器了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用和UNIX Shell</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ul><li>Shell</li><li>xv6 shell 代码讲解</li></ul><h3 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell"></a>什么是 shell</h3><ul><li>os &#x3D; API + 对象<blockquote><p>人不可能直接使用系统调用来使用操作系统，所以人和操作系统之间隔了一个应用程序，这个应用程序就叫 shell。shell 把内核的 API 和对象做一层封装，来帮助用户管理操作系统对象的一个<strong>应用程序</strong> 。<br>有 graphic shell 和 command line shell。</p></blockquote></li></ul><h3 id="shell-编程语言"><a href="#shell-编程语言" class="headerlink" title="shell 编程语言"></a>shell 编程语言</h3><ul><li>基于文本替换的快速工作流搭建<blockquote><p>再把 shell 命令构建成一棵树，解释为一组系统调用。</p></blockquote></li></ul><ol><li>重定向: cmd &gt; file &lt; file 2&gt; &#x2F;dev&#x2F;null</li><li>顺序结构: cmd1; cmd2, cmd1 &amp;&amp; cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量&#x2F;环境变量、控制流……</li></ol><ul><li>Job control<br>类比窗口管理器里的 “叉”、“最小化”<br>jobs, fg, bg, wait<br>(今天的 GUI 并没有比 CLI 多做太多事)<blockquote><p>例如用 jobs 查看所有的进程，用 fg 命令使该进程变成前台进程等等。</p></blockquote></li></ul><h3 id="复刻经典"><a href="#复刻经典" class="headerlink" title="复刻经典"></a>复刻经典</h3><p>一个简单地 shell 的实现<br>推荐阅读网站源代码。</p><h3 id="管道的一些细节"><a href="#管道的一些细节" class="headerlink" title="管道的一些细节"></a>管道的一些细节</h3><ul><li>在gdb中如何调试会产生子进程(多进程)的程序？</li></ul><ol><li>set follow-fork-mode child<blockquote><p>这可以在 fork 后直接切到子进程执行流。</p></blockquote></li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> follow-fork-mode <span class="hljs-comment">child</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">detach-on-fork off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">follow-exec-mode same</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">confirm off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">pagination off</span><br>source <span class="hljs-comment">visualize.py</span><br>break <span class="hljs-comment">_start</span><br>run<br>n <span class="hljs-comment">2</span><br>define <span class="hljs-comment">hook-stop</span><br>    pdump<br>end<br></code></pre></td></tr></table></figure><ol start="2"><li><p>info inferiors 命令查看 gdb中的进程</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Num  <span class="hljs-keyword">Description</span>       Executable<br><span class="hljs-number">1</span>    process <span class="hljs-number">1234</span>      <span class="hljs-regexp">/path/</span>to/parent<br><span class="hljs-number">2</span>    process <span class="hljs-number">5678</span>      <span class="hljs-regexp">/path/</span>to/child<br></code></pre></td></tr></table></figure></li><li><p>inferior 命令切换进程</p><blockquote><p>例如 inferior 1</p></blockquote></li></ol><ul><li><p>利用好工具，定制化的gdb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        <span class="hljs-built_in">print</span>()<br>    <br>        <span class="hljs-keyword">for</span> proc <span class="hljs-keyword">in</span> gdb.inferiors():<br>            pid = proc.pid<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(pid) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>    <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process <span class="hljs-subst">&#123;proc.num&#125;</span> (<span class="hljs-subst">&#123;pid&#125;</span>)&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">if</span> proc <span class="hljs-keyword">is</span> gdb.selected_inferior():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>()<br>    <br>            <span class="hljs-keyword">for</span> fd_desc <span class="hljs-keyword">in</span> subprocess.check_output(<br>                [<span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-string">&#x27;-l&#x27;</span>, <span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/fd&#x27;</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>            ).splitlines()[<span class="hljs-number">1</span>:]:<br>                perm, *_, fd, _, fname = fd_desc.split()<br>    <br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;rw&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;-&gt;&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;r&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;--&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;w&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;--&gt;&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;pipe:&#x27;</span> <span class="hljs-keyword">in</span> fname:<br>                    pipe_id = re.search(<span class="hljs-string">f&#x27;[0-9]+&#x27;</span>, fname).group()<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> [=== <span class="hljs-subst">&#123;pipe_id&#125;</span> ===]&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> <span class="hljs-subst">&#123;fname&#125;</span>&#x27;</span>)<br><br>ProcDump()<br><br><br></code></pre></td></tr></table></figure><blockquote><p>这个类继承自gdb.Command类，这个类是一个GDB命令的基类，用于创建新的GDB命令。在这个类的构造函数中，调用了父类的构造函数，并传入了三个参数，分别是”pdump”，gdb.COMMAND_DATA和gdb.COMPLETE_SYMBOL。其中，”pdump”是命令名称，gdb.COMMAND_DATA表示这是一个处理数据的命令，gdb.COMPLETE_SYMBOL表示这个命令需要在符号表中进行自动补全。<br>在你的代码中，你需要在ProcDump类中实现一个名为invoke的方法，这个方法将会被调用来执行pdump命令的实际功能。</p></blockquote></li><li><p>init.gdb脚本<br>init.gdb脚本是一个GDB初始化脚本，它会在GDB启动时自动执行。你可以在这个脚本中设置GDB的一些默认行为，例如设置别名、定义宏、加载符号表等。这个脚本可以包含任意数量的GDB命令，它们会按照在脚本中出现的顺序依次执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">gdb +x <span class="hljs-keyword">init</span>.gdb a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 &#x2F;dev&#x2F;pts ?</p><blockquote><p>&#x2F;dev&#x2F;pts是一个特殊的文件系统，它提供了一个伪终端（pseudo-terminal）接口，允许用户与计算机进行交互。当用户登录到计算机时，系统会为该用户分配一个伪终端，这个伪终端就会在&#x2F;dev&#x2F;pts目录下创建一个对应的设备文件。</p></blockquote></li></ul><p>echo hello &gt; &#x2F;dev&#x2F;pts&#x2F;8 会发生什么</p><blockquote><p>会在相应终端产生输出。使用 tty 命令可以查看当前 shell 终端对应的终端文件是哪一个。</p></blockquote><ul><li><p>说明<br>由于这里文件描述符的应用我在 MIT 6.S081 中的实验1中实现过类似的，所以在这里不再详细地描述调代码的细节。</p></li><li><p>关于 va_list</p><ol><li>va_start sets arg_ptr to the first optional argument in the list of arguments that’s passed to the function.</li><li>va_arg retrieves a value of type from the location that’s given by arg_ptr, and increments arg_ptr to point to the next argument in the list by using the size of type to determine where the next argument starts. </li><li>va_end resets the pointer to NULL</li></ol></li></ul><p>是不是似乎好像会实现 printf 函数了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统API</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FAPI/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FAPI/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入输出设备模型</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器"><a href="#IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器" class="headerlink" title="IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器"></a>IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器</h3><ul><li>就是“几组约定好功能的线”，通过握手信号从线上读出&#x2F;写入数据</li><li>每一组线都有自己的地址<blockquote><p>CPU可以直接使用指令(in&#x2F;out&#x2F;MMIO)和设备交换数据<br>CPU不管设备具体是如何实现的</p></blockquote></li></ul><h3 id="总线、中断控制器和DMA"><a href="#总线、中断控制器和DMA" class="headerlink" title="总线、中断控制器和DMA"></a>总线、中断控制器和DMA</h3><p>越来越多的IO设备，如何给未来留出一点空间？</p><ul><li>CPU只直接连接一个设备，这个IO设备实际上是一块板卡，板卡上有很多个小插槽(寄存器)。这个IO设备负责管理其他IO设备，这个设备就叫做总线。</li><li>甚至这个IO设备做得更彻底一点，我们的内存也连接在这个总线上，同一个地址空间，CPU只需要一个地址，就可以知道访问的是内存还是IO设备(统一编址)。</li></ul><h3 id="中断没能解决的"><a href="#中断没能解决的" class="headerlink" title="中断没能解决的"></a>中断没能解决的</h3><p>假设程序希望写入1GB的数据到磁盘</p><ul><li>即使磁盘已经准备好了，依然需要非常浪费时间的循环。<blockquote><p>DMA的出现：一个专门执行”memcpy”程序的CPU<br>通过增加一个CPU专门负责从内存到总线的数据搬运<br>memory-&gt;memory     device-&gt;memory    memory-&gt;device</p></blockquote></li></ul><h3 id="IO设备和计算机之间的边界逐渐模糊"><a href="#IO设备和计算机之间的边界逐渐模糊" class="headerlink" title="IO设备和计算机之间的边界逐渐模糊"></a>IO设备和计算机之间的边界逐渐模糊</h3><p>DMA不就是一个“只做一件特别事情的”CPU吗</p><ul><li>那么我们还可以有做各种事情的”CPU”啊, 例如显卡</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设备驱动程序</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课的主要内容"><a href="#本次课的主要内容" class="headerlink" title="本次课的主要内容"></a>本次课的主要内容</h2><ul><li>什么是设备驱动程序</li><li>Linux设备抽象</li></ul><h3 id="设备驱动程序原理"><a href="#设备驱动程序原理" class="headerlink" title="设备驱动程序原理"></a>设备驱动程序原理</h3><ul><li>设备其实是一组寄存器和一组协议，一个设备，一个协议</li></ul><p>设备可以分为两种</p><ol><li>字符设备：字节流，例如键盘</li><li>块设备：字节数组，例如磁盘</li></ol><h3 id="操作系统：设备-支持各类操作的对象（文件）"><a href="#操作系统：设备-支持各类操作的对象（文件）" class="headerlink" title="操作系统：设备&#x3D;支持各类操作的对象（文件）"></a>操作系统：设备&#x3D;支持各类操作的对象（文件）</h3><ul><li>read: 从设备某个指定的位置读出数据</li><li>write：向设备某个位置写入数据</li><li>ioctl: 读取&#x2F;设置设备的状态, ioctl是一个系统调用<br>上面为设备建立一个模型       <blockquote><p>也就是说，把上面这三个系统调用，也就是通用的API，经过设备驱动程序，翻译成设备能够听得懂的语言, 这段代码就是设备驱动程序。</p></blockquote></li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>把系统调用“翻译”成与设备寄存器的交互</p><ul><li>就是一段普通的内核代码</li><li>有可能这个设备驱动程序后面就是一个真实的设备，有可能没有设备，就是用设备驱动程序来模拟这个设备</li></ul><p>例如：&#x2F;dev&#x2F;中的对象</p><ol><li>&#x2F;dev&#x2F;null   null设备</li><li>&#x2F;dev&#x2F;random   随机数生成器</li></ol><h3 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h3><p>我们希望实现一个最简单的“软件定义核弹”</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核线程与进程、进程API</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="虚拟化：操作系统同时保存多个状态机"><a href="#虚拟化：操作系统同时保存多个状态机" class="headerlink" title="虚拟化：操作系统同时保存多个状态机"></a>虚拟化：操作系统同时保存多个状态机</h3><p>C程序 &#x3D; 状态机</p><ul><li>初始状态： main(argc, argv)</li><li>状态迁移： 指令的执行，包括syscall</li></ul><p>实际上，在 UNIX&#x2F;Linux 系统内核完成初始化后，只有一个 init 进程被启动，从此以后，操作系统内核就化身为了一个事件驱动的程序、状态机的管理者，仅在中断和系统调用发生时开始执行。</p><p>下面看一段小代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写出代码的运行结果。</p></blockquote><ul><li>.&#x2F;a.out</li><li>.&#x2F;a.out | cat</li></ul><ol><li>当执行.&#x2F;a.out时，会打印 6 个 Hello</li><li>当执行.&#x2F;a.out | wc -l 时，会打印 8 个 Hello ? 这是为什么呢？</li></ol><p>不妨用 strace 来看一下。<br>我们发现，</p><blockquote><p>我们的 printf 不总是打印到标准输出的。也就是说它根据标准输出连接的是终端还是管道，它会做不同的行为，这里连接到了管道，也就把输出放到一个缓冲区里面 。当第一个循环之后，缓冲区里面有一个 hello，有两个进程；第二次循环完毕后，缓冲区里面有 2 个 hello, 总共 4 个进程。所以打印 8 个。 </p></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>应用程序执行的环境。</p><ul><li>export: 告诉shell在创建子进程的时候设置环境变量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可执行程序</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="可执行文件：状态机的描述"><a href="#可执行文件：状态机的描述" class="headerlink" title="可执行文件：状态机的描述"></a>可执行文件：状态机的描述</h2><h3 id="一个描述了状态机初始状态-迁移的数据结构"><a href="#一个描述了状态机初始状态-迁移的数据结构" class="headerlink" title="一个描述了状态机初始状态 + 迁移的数据结构"></a>一个描述了状态机初始状态 + 迁移的<font color=#FF000 >数据结构</font></h3><ol><li>寄存器：大部分由ABI规定，操作系统负责设置。例如初始化pc。</li><li>地址空间：二进制文件+ABI共同决定。例如argv和envp的存储。</li><li>其他有用的信息（例如调试和core dump的信息）</li></ol><hr><h2 id="可执行文件里面应该有什么？"><a href="#可执行文件里面应该有什么？" class="headerlink" title="可执行文件里面应该有什么？"></a>可执行文件里面应该有什么？</h2><p>可执行程序描述了状态机重置后的状态，那状态有什么呢？</p><blockquote><p>无非就是寄存器和内存（地址空间）</p></blockquote><hr><h2 id="操作系统上的可执行程序"><a href="#操作系统上的可执行程序" class="headerlink" title="操作系统上的可执行程序"></a>操作系统上的可执行程序</h2><p>需要满足以下条件：</p><ol><li><p>具有执行(x)权限<br>执行.&#x2F;a.c命令 (出现permission denied错误)<br>但如果先执行 chmod +x a.c命令，会出现加载器不能正确识别题。    </p></li><li><p>加载器能够识别的可执行文件</p></li></ol><hr><h2 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h2><blockquote><p>就是操作系统里面的一个普通对象。</p></blockquote><h3 id="UNIX-Linux"><a href="#UNIX-Linux" class="headerlink" title="UNIX&#x2F;Linux"></a>UNIX&#x2F;Linux</h3><ul><li>a.out</li><li>ELF</li><li>She-bang<blockquote><p>She-bang是什么呢？其实就是一个“偷换参数”地execve。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">#!/usr/bin/python3               #这是一个可执行文件<br>print(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再执行命令 chmod +x a.c。上面这个文件就可以执行了。<br>如果加载器这样一个程序的时候，如果它发现一个#!开头的，就会在execve偷换一下，把#!后面的填入execve的第一个参数，该文件名填入第二个参数。</p><hr><h2 id="从C代码到二进制文件"><a href="#从C代码到二进制文件" class="headerlink" title="从C代码到二进制文件"></a>从C代码到二进制文件</h2><p>一段简单的C代码(main.c)：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    hello();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>gcc -O2 -c main.c得到main.o文件, 然后objdump -d main.o得到反汇编 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-number">0</span>:   f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa             endbr64 <br>   <span class="hljs-number">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>             sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">8</span>:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>   a:   e8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   f &lt;main+<span class="hljs-number">0xf</span>&gt;<br>   f:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>  <span class="hljs-number">11</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>             add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">15</span>:   c3                      ret    <br></code></pre></td></tr></table></figure><p>我们可以看到 0xa 地址处，由于不知道hello函数的地址，这里暂时填为 0</p><p>hello.c的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xa</span> + <span class="hljs-number">1</span>;   <span class="hljs-comment">//有上面汇编代码可以看出，代填 </span><br>               <span class="hljs-comment">//hello地址为 main 的地址加上偏移再加上1(操作码1个字节)</span><br>    <span class="hljs-type">int32_t</span> offset = *(<span class="hljs-type">int32_t</span>*)p;<br>    assert( (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xf</span> +offset == (<span class="hljs-type">char</span>*)hello);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下：在我们的main函数要调用hello函数时，此时pc会指向这条call指令的下一条指令的地址，也就是pc指针会是(char*)main + 0xf,由于是相对寻址(call指令的语义)，所以会跳转到pc + offset的位置，offset也就是待填地址处的值。而跳转后的地址要是hello的地址。</p></blockquote><p>我们 readelf -a main.o 来看一下有什么输出信息,其中有一部分是这样的（这里复制过来格式有点不正确）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Relocation</span> section &#x27;.rela.text.startup&#x27; at offset <span class="hljs-number">0</span>x1b8 contains <span class="hljs-number">1</span> entry:<br>  <span class="hljs-attribute">Offset</span>          Info       Type        Sym. Value    Sym. Name+Addend<br><span class="hljs-attribute">00000000000b</span>  <span class="hljs-number">000600000004</span> R_X86_64_PLT32 <span class="hljs-number">0000000000000000</span> hello - <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="重新理解编译、链接流程"><a href="#重新理解编译、链接流程" class="headerlink" title="重新理解编译、链接流程"></a>重新理解编译、链接流程</h2><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><blockquote><p>High-level semantics(高级C状态机) -&gt; Low-level semantics(汇编状态机)</p></blockquote><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><blockquote><p>Low-level semantics -&gt; Binary semantics(状态机的容器)</p></blockquote><ol><li>“一一对应”地翻译成二进制代码，sections, symbols, debug info……</li><li>不能决定的要留下“之后要怎么办”的信息(relocations重定位)</li></ol><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><blockquote><p>合并所有的容器，得到一个完整的状态机</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多处理器编程从入门到放弃</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：多处理器编程：从入门到放弃："><a href="#本讲内容：多处理器编程：从入门到放弃：" class="headerlink" title="本讲内容：多处理器编程：从入门到放弃："></a>本讲内容：多处理器编程：从入门到放弃：</h2><ul><li>入门：多线程编程库</li><li>放弃：原子性、可见性、顺序</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>每个线程都有自己的堆栈，如何确定各自的堆栈大小？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> low[<span class="hljs-number">64</span>];<br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> high[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_range</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">void</span> *ptr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ptr &lt; low[T]) low[T] = ptr;<br>    <span class="hljs-keyword">if</span> (ptr &gt; high[T]) high[T] = ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">probe</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">int</span> n)</span> &#123;<br>  update_range(T, &amp;n);<br>  <span class="hljs-type">long</span> sz = (<span class="hljs-type">uintptr_t</span>)high[T] - (<span class="hljs-type">uintptr_t</span>)low[T];<br>  <span class="hljs-keyword">if</span> (sz % <span class="hljs-number">1024</span> &lt; <span class="hljs-number">32</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack(T%d) &gt;= %ld KB\n&quot;</span>, T, sz / <span class="hljs-number">1024</span>);<br>  &#125;<br>  probe(T, n + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Infinite recursion</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tprobe</span><span class="hljs-params">(<span class="hljs-type">int</span> T)</span> &#123;<br>  low[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;<br>  high[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>  update_range(T, &amp;T);<br>  probe(T, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    create(Tprobe);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要 setbuf(stdout, NULL) 关闭缓冲区？</p><blockquote><p>有时候一个printf明明在crash前的代码运行了，但没有得到输出，原因是什么呢？<br>是因为printf先把输出放在缓冲区里。</p></blockquote><p>这段代码的核心思想就是无穷递归，利用函数参数存储在栈空间里估算栈的大小。</p><h2 id="放弃：原子性"><a href="#放弃：原子性" class="headerlink" title="放弃：原子性"></a>放弃：原子性</h2><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100000000</span><br><br><span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tsum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    sum++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  create(Tsum);<br>  create(Tsum);<br>  join();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %ld\n&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译优化 -O2得到答案 200000000</p><blockquote><p>编译器直接计算出答案，一条指令赋值给sum</p></blockquote><p>编译优化 -O1得到答案 100000000</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接和加载(2)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="动态链接与加载原理"><a href="#动态链接与加载原理" class="headerlink" title="动态链接与加载原理"></a>动态链接与加载原理</h2><h3 id="若干要素"><a href="#若干要素" class="headerlink" title="若干要素"></a>若干要素</h3><ol><li>编译成位置无关代码</li><li>对外部函数的调用是查表的</li><li>在运行（加载）的时候填表</li></ol><p>我们就发明了GOT(Global Offset Table)</p><blockquote><p>也就是table </p></blockquote><h3 id="有个有趣的问题"><a href="#有个有趣的问题" class="headerlink" title="有个有趣的问题"></a>有个有趣的问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>; <br></code></pre></td></tr></table></figure><p>编译器遇到函数调用，应该翻译成哪种指令？</p><ul><li>如果是同一个动态链接库    call foo   (因为如果是一个库的，链接的时候相对地址已经确定下来了)</li><li>如果是另外一个动态链接库  call TABLE(foo)</li></ul><p>这就需要PLT (Procedure Linkage Table)       </p><ul><li>函数太多，每个都标记区分太难看</li><li>编译器总是生成一个直接的call<blockquote><p>来自另一个动态链接库     call foo@plt            </p></blockquote></li></ul><h3 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h3><p>对于一个动态链接的二进制文件，execve后的第一条指令在哪里？</p><ul><li>what are the first a few steps executed after execve() of a ELF dynamic link binary?  (Chatgpt)</li></ul><blockquote><p>第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2   _start函数<br>也就是说，刚刚执行玩execve后，我们的pc指针指向了ld.so中的代码。</p></blockquote><ol><li>首先会加载这个ELF文件，把相关的段加载进地址空间中。</li><li>内核会根据查看程序头表(program header)中的PT_INTERP的判断是否需要动态链接。如果需要，内核就会把动态链接器(通常来说是ld-linux.so)加载进进程的地址空间中。</li><li>设置栈的初始状态。</li><li>把控制交给动态链接器：内核把pc指针设置为动态链接器的入口地址。</li><li>动态链接器的初始化，解析符号，重定位等。</li><li>把控制权交给程序(通常来说是_start函数)</li></ol><ul><li>How can I compile an ELF binary that use an alternative dynamic loader than the default ld.so?（能否替换这个加载器） <blockquote><p>gcc -o hello hello.c -Wl, –dynamic-linker&#x3D;&#x2F;path&#x2F;to&#x2F;my_ld.so<br>readelf -l hello | grep “program interpreter” 查看可执行文件的动态链接器</p></blockquote></li></ul><p>示例代码<br>ld.S  ——  将来链接成动态链接库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br>.globl _start<br>_start:<br>  movq $SYS_write, %rax   <span class="hljs-comment">// write(</span><br>  movq $<span class="hljs-number">1</span>,         %rdi   <span class="hljs-comment">//   fd=1,</span><br>  lea  <span class="hljs-title function_">st</span><span class="hljs-params">(%rip)</span>,   %rsi   <span class="hljs-comment">//   buf=st,</span><br>  movq $<span class="hljs-params">(ed - st)</span>, %rdx   <span class="hljs-comment">//   count=ed-st</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>  movq $SYS_exit,  %rax   <span class="hljs-comment">// exit(</span><br>  movq $1,         %rdi   <span class="hljs-comment">//   status=1</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>st:<br>  .ascii &quot;\033[01;<span class="hljs-number">31</span>mThis is a loader.\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m\n<span class="hljs-string">&quot;</span><br><span class="hljs-string">ed:</span><br></code></pre></td></tr></table></figure><p>hello.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld<span class="hljs-selector-class">.so</span>: ld<span class="hljs-selector-class">.S</span> hello<span class="hljs-selector-class">.c</span><br>gcc -fPIC -shared -c ld<span class="hljs-selector-class">.S</span><br>ld -shared ld<span class="hljs-selector-class">.o</span> -o ld<span class="hljs-selector-class">.so</span><br>gcc hello<span class="hljs-selector-class">.c</span> -Wl,<span class="hljs-attr">--dynamic-linker</span>=$(PWD)/ld.so<br></code></pre></td></tr></table></figure><ul><li>当我们输入make指令并执行 .&#x2F;a.out 时，我们看到，我们并没有输出Hello,而是输出了This is a loader. 这也就说明了我们的动态链接器确实换掉了，由于hello.c是动态链接的，所以内核会加载我们自己的动态链接器并执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接和加载(1)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课要回答的问题"><a href="#本次课要回答的问题" class="headerlink" title="本次课要回答的问题"></a>本次课要回答的问题</h2><ol><li>可执行文件是如何被操作系统加载的</li><li>什么是动态链接&#x2F;动态加载</li></ol><h2 id="静态ELF加载器：实现"><a href="#静态ELF加载器：实现" class="headerlink" title="静态ELF加载器：实现"></a>静态ELF加载器：实现</h2><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><ol><li>解析数据结构 + 复制到内存 + 跳转</li><li>创建进程运行时的初始状态(argv,envp,…)</li></ol><h3 id="loader-static-c"><a href="#loader-static-c" class="headerlink" title="loader-static.c"></a>loader-static.c</h3><ol><li>可以加载任何静态链接的代码, minimal.S, dfs-fork.c</li><li>并可以正确处理参数&#x2F;环境变量 env.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STK_SZ           (1 &lt;&lt; 20)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROUND(x, align)  (void *)(((uintptr_t)x) &amp; ~(align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD(x, align)    (((uintptr_t)x) &amp; (align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> push(sp, T, ...) (&#123; *((T*)sp) = (T)__VA_ARGS__; sp = (void *)((uintptr_t)(sp) + sizeof(T)); &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">execve_</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-comment">// WARNING: This execve_ does not free process resources.</span><br>  <span class="hljs-type">int</span> fd = open(file, O_RDONLY);<br>  assert(fd &gt; <span class="hljs-number">0</span>);<br>  Elf64_Ehdr *h = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  assert(h != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>  assert(h-&gt;e_type == ET_EXEC &amp;&amp; h-&gt;e_machine == EM_X86_64);<br><br>  Elf64_Phdr *pht = (Elf64_Phdr *)((<span class="hljs-type">char</span> *)h + h-&gt;e_phoff);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;e_phnum; i++) &#123;<br>    Elf64_Phdr *p = &amp;pht[i];<br>    <span class="hljs-keyword">if</span> (p-&gt;p_type == PT_LOAD) &#123;<br>      <span class="hljs-type">int</span> prot = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_R) prot |= PROT_READ;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_W) prot |= PROT_WRITE;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_X) prot |= PROT_EXEC;<br>      <span class="hljs-type">void</span> *ret = mmap(<br>        ROUND(p-&gt;p_vaddr, p-&gt;p_align),              <span class="hljs-comment">// addr, rounded to ALIGN</span><br>        p-&gt;p_memsz + MOD(p-&gt;p_vaddr, p-&gt;p_align),   <span class="hljs-comment">// length</span><br>        prot,                                       <span class="hljs-comment">// protection</span><br>        MAP_PRIVATE | MAP_FIXED,                    <span class="hljs-comment">// flags, private &amp; strict</span><br>        fd,                                         <span class="hljs-comment">// file descriptor</span><br>        (<span class="hljs-type">uintptr_t</span>)ROUND(p-&gt;p_offset, p-&gt;p_align)); <span class="hljs-comment">// offset</span><br>      assert(ret != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(p-&gt;p_vaddr + p-&gt;p_filesz), <span class="hljs-number">0</span>, p-&gt;p_memsz - p-&gt;p_filesz);<br>    &#125;<br>  &#125;<br>  close(fd);<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STK_SZ], rnd[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">void</span> *sp = ROUND(<span class="hljs-built_in">stack</span> + <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>) - <span class="hljs-number">4096</span>, <span class="hljs-number">16</span>);<br>  <span class="hljs-type">void</span> *sp_exec = sp;<br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// argc</span><br>  <span class="hljs-keyword">while</span> (argv[argc]) argc++;<br>  push(sp, <span class="hljs-type">intptr_t</span>, argc);<br>  <span class="hljs-comment">// argv[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= argc; i++)<br>    push(sp, <span class="hljs-type">intptr_t</span>, argv[i]);<br>  <span class="hljs-comment">// envp[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (; *envp; envp++) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strchr</span>(*envp, <span class="hljs-string">&#x27;_&#x27;</span>)) <span class="hljs-comment">// remove some verbose ones</span><br>      push(sp, <span class="hljs-type">intptr_t</span>, *envp);<br>  &#125;<br>  <span class="hljs-comment">// auxv[], AT_NULL-terminate</span><br>  push(sp, <span class="hljs-type">intptr_t</span>, <span class="hljs-number">0</span>);<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_RANDOM, .a_un.a_val = (<span class="hljs-type">uintptr_t</span>)rnd &#125; );<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_NULL &#125; );<br><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov $0, %%rdx;&quot;</span> <span class="hljs-comment">// required by ABI</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov %0, %%rsp;&quot;</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;jmp *%1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span>(sp_exec), <span class="hljs-string">&quot;b&quot;</span>(h-&gt;e_entry))</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s file [args...]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  execve_(argv[<span class="hljs-number">1</span>], argv + <span class="hljs-number">1</span>, envp);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下我们这里的loader(它是动态链接的): 给我们的loader传入一个参数,它执行到某一个状态的时候，把我们的ELF文件(argv[1])搬到我们的loader程序的状态上,相当于我们的程序被替换了,但这个过程并没有执行execve,只是简单地用mmap系统调用(当然操作系统加载loader这个程序的时候会用execve)。</p></blockquote></li></ol><h3 id="初始化堆栈"><a href="#初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><p>状态机是well-defined的。</p><table><thead><tr><th>表头</th><th>表头</th><th>长度(字节)</th></tr></thead><tbody><tr><td>其他信息</td><td></td><td>未知</td></tr><tr><td>Null auxiliary vector entry</td><td></td><td>1 eightbyte each</td></tr><tr><td>Auxiliary vector entries</td><td></td><td>2 eightbytes each</td></tr><tr><td>0</td><td></td><td>8</td></tr><tr><td>Environment pointers</td><td></td><td>8 bytes each</td></tr><tr><td>0</td><td>8 + 8*argc + %rsp</td><td>8</td></tr><tr><td>Argument pointers</td><td>8 + %rsp</td><td>argc 8</td></tr><tr><td>Argument count</td><td>%rsp</td><td>8</td></tr><tr><td>Undefined</td><td>Low Address</td><td></td></tr></tbody></table><h3 id="有趣之处"><a href="#有趣之处" class="headerlink" title="有趣之处"></a>有趣之处</h3><blockquote><p>这是在操作系统上实现的。用 open , mmap, close实现了一个 execve。     </p></blockquote><hr><h2 id="动态链接和加载"><a href="#动态链接和加载" class="headerlink" title="动态链接和加载"></a>动态链接和加载</h2><h3 id="为什么要动态加载"><a href="#为什么要动态加载" class="headerlink" title="为什么要动态加载"></a>为什么要动态加载</h3><ol><li>减少库函数的磁盘和内存拷贝</li></ol><ul><li>每个可执行文件里面都有所有的库函数拷贝那也太浪费了</li><li>只要遵守约定，不挑战库函数的版本(否则发布一个新版本就要重新编译全部程序)</li></ul><h3 id="这就有了”拆解应用程序”的需求"><a href="#这就有了”拆解应用程序”的需求" class="headerlink" title="这就有了”拆解应用程序”的需求"></a>这就有了”拆解应用程序”的需求</h3><blockquote><p>随着库函数越来越大，希望项目能够运行时链接。</p></blockquote><h3 id="动态链接，但不讲ELF-换一种方法。"><a href="#动态链接，但不讲ELF-换一种方法。" class="headerlink" title="动态链接，但不讲ELF,换一种方法。"></a>动态链接，但不讲ELF,换一种方法。</h3><ul><li>如果编译器、链接器、加载器都受你控制</li><li>那你怎么设计实现一个“最直观”的动态链接格式？</li><li>如何改进，就得到了ELF！</li><li>假设编译器可以为你生成位置无关代码(PIC)</li></ul><h3 id="来看一下蒋神的设计-main-part"><a href="#来看一下蒋神的设计-main-part" class="headerlink" title="来看一下蒋神的设计(main part)"></a>来看一下蒋神的设计(main part)</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul><li>dl.h(数据结构定义)</li></ul><h4 id="全家桶工具集"><a href="#全家桶工具集" class="headerlink" title="全家桶工具集"></a>全家桶工具集</h4><ul><li>dlbox.c(gcc, readdl, objdump, interp)</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>libc.S - 提供 putchar 和 exit</li><li>libhello.S - 调用 putchar, 提供 hello</li><li>main.S - 调用 hello, 提供 main</li></ul><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o dlbox dlbox<span class="hljs-selector-class">.c</span><br>./dlbox gcc libc<span class="hljs-selector-class">.S</span><br>./dlbox gcc libhello<span class="hljs-selector-class">.S</span><br>./dlbox gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.S</span><br>./dlbox readdl libc<span class="hljs-selector-class">.dl</span>         <span class="hljs-comment">//readelf</span><br></code></pre></td></tr></table></figure><blockquote></blockquote><p>会生成.dl格式的自定义可执行文件。这个可执行文件是不可以在操作系统上执行，需要自己的加载器。<br>并且我们的加载器是在当前目录中动态加载.dl文件(根据)的，如果先前没有生成所需要的.dl文件的话，我们的加载器会出现错误。</p><blockquote></blockquote><h4 id="演示一下下"><a href="#演示一下下" class="headerlink" title="演示一下下"></a><strong>演示一下下</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br>DL_HEAD<br><br><span class="hljs-title function_">LOAD</span><span class="hljs-params">(<span class="hljs-string">&quot;libc.dl&quot;</span>)</span><br><span class="hljs-title function_">IMPORT</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br><span class="hljs-title function_">EXPORT</span><span class="hljs-params">(hello)</span><br><br>DL_CODE<br><br>hello:<br>  lea <span class="hljs-title function_">str</span><span class="hljs-params">(%rip)</span>, %rdi<br>  mov <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span>, %eax<br>  push %rbx<br>  mov %rdi, %rbx<br>  inc %eax<br>  mov %eax, <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span><br>  add $0x30, %eax<br>  movb %al, 0<span class="hljs-title function_">x6</span><span class="hljs-params">(%rdi)</span><br>loop:<br>  <span class="hljs-title function_">movsbl</span> <span class="hljs-params">(%rbx)</span>,%edi<br>  test %dil,%dil<br>  je out<br>  call <span class="hljs-title function_">DSYM</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br>  inc  %rbx<br>  jmp loop<br>out:<br>  pop %rbx<br>  ret<br><br>str:<br>  .asciz &quot;Hello X\n&quot;<br><br>count:<br>  .<span class="hljs-type">int</span> 0<br><br>DL_END<br><br></code></pre></td></tr></table></figure><blockquote><p>这个文件需要使用外部的putchar函数,所以需要call DSYM(putchar), DSYM表示动态链接的，也需要手动指明putchar函数所在的库libc.dl。它定义有一个hello函数，所以需要导出。也就是EXPORT(hello).</p></blockquote><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><ol><li><p><strong>首先来看一下dl.h文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REC_SZ 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_MAGIC <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ASSEMBLER__</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_HEAD     __hdr: \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* magic */</span>    .ascii DL_MAGIC; \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* file_sz */</span>  .4byte (__end - __hdr); \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* code_off */</span> .4byte (__code - __hdr)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_CODE     .fill REC_SZ - 1, 1, 0; \</span><br><span class="hljs-meta">                      .align REC_SZ, 0; \</span><br><span class="hljs-meta">                      __code:</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_END      __end:</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> RECORD(sym, off, name) \</span><br><span class="hljs-meta">    .align REC_SZ, 0; \</span><br><span class="hljs-meta">    sym .8byte (off); .ascii name</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPORT(sym) RECORD(sym:,           0, <span class="hljs-string">&quot;?&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPORT(sym) RECORD(    , sym - __hdr, <span class="hljs-string">&quot;#&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOAD(lib)   RECORD(    ,           0, <span class="hljs-string">&quot;+&quot;</span> lib  <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DSYM(sym)   *sym(%rip)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> &#123;</span><br>    <span class="hljs-type">char</span> magic[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">uint32_t</span> file_sz, code_off;<br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> &#123;</span><br>    <span class="hljs-type">int64_t</span> offset;<br>    <span class="hljs-type">char</span> type, name[REC_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int64_t</span>) - <span class="hljs-number">1</span>];<br>  &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><blockquote><ol><li>__ASSEMBLER__是一个内置的宏，它由编译器预定义，用于判断当前代码是否为汇编代码。在编写汇编代码时，编译器会自动定义这个宏。</li><li>怎么用汇编语言定义结构体呢？ 为什么变量名前面要加.呢？这表示这是在当前偏移量下定义的。</li><li>RECORD宏定义：.align REC_SZ, 0 表示将当前位置对齐到 REC_SZ 字节边界。<br>这行代码定义了一个标签 sym，并将 off 表示的偏移量存储到该标签处。.8byte 指令告诉汇编器为该标签分配一个 8 字节的存储空间，即使用一个 64 位无符号整数来存储偏移量。<br>.ascii name 表示将 name 参数表示的记录名称作为 ASCII 字符串嵌入到汇编代码中。.ascii 指令用于将一个字符串常量嵌入到汇编代码中。</li><li>#define DSYM(sym)  这是间接跳转，先将 %rip 寄存器中存储的当前指令地址加上 hello 符号相对于当前指令的偏移量，得到函数地址，然后再根据这个地址的值进行跳转，而符号表结构体前八个字节就是函数的地址。</li></ol></blockquote></li><li><p><strong>dlbox.c文件</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">symtab</span>;</span> <span class="hljs-comment">// borrowed spaces from header</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><br><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br><span class="hljs-comment">// Implementation of binutils</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_readdl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DLIB file %s:\n\n&quot;</span>, h-&gt;path);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    LOAD  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  EXTERN  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: <span class="hljs-built_in">printf</span>(   <span class="hljs-string">&quot;%08lx  %s\n&quot;</span>, sym-&gt;offset, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_objdump</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">char</span> *hc = (<span class="hljs-type">char</span> *)h, cmd[<span class="hljs-number">64</span>];<br>  FILE *fp = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Disassembly of binary %s:\n&quot;</span>, h-&gt;path);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> *code = hc + h-&gt;hdr.code_off; code &lt; hc + h-&gt;hdr.file_sz; code++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>      <span class="hljs-keyword">if</span> (hc + sym-&gt;offset == code) &#123;<br>        <span class="hljs-type">int</span> off = code - hc - h-&gt;hdr.code_off;<br>        <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>        <span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">&quot;ndisasm - -b 64 -o 0x%08x\n&quot;</span>, off);<br>        fp = popen(cmd, <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%016x &lt;%s&gt;:\n&quot;</span>, off, sym-&gt;name);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fp) fputc(*code, fp);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>&#125;<br><br><span class="hljs-comment">// binutils: interpreter</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmd</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd;<br>  <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path);<br>&#125; commands[] = &#123;<br>  &#123; <span class="hljs-string">&quot;gcc&quot;</span>,     dl_gcc &#125;,<br>  &#123; <span class="hljs-string">&quot;readdl&quot;</span>,  dl_readdl &#125;,<br>  &#123; <span class="hljs-string">&quot;objdump&quot;</span>, dl_objdump &#125;,<br>  &#123; <span class="hljs-string">&quot;interp&quot;</span>,  dl_interp &#125;,<br>  &#123; <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-literal">NULL</span> &#125;,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;gcc|readdl|objdump|interp&#125; FILE...\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> cmd *cmd = &amp;commands[<span class="hljs-number">0</span>]; cmd-&gt;handler; cmd++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **path = &amp;argv[<span class="hljs-number">2</span>]; *path &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], cmd-&gt;cmd) == <span class="hljs-number">0</span>; path++) &#123;<br>      <span class="hljs-keyword">if</span> (path != argv + <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>      cmd-&gt;handler(*path);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Implementation of dlopen()</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">libs</span>[16], <span class="hljs-title">syms</span>[128];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(syms[i].name, name) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)syms[i].offset;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(libs); i++) &#123;<br>    <span class="hljs-keyword">if</span> (libs[i] &amp;&amp; <span class="hljs-built_in">strcmp</span>(libs[i]-&gt;name, sym-&gt;name) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// already loaded</span><br>    <span class="hljs-keyword">if</span> (!libs[i]) &#123;<br>      libs[i] = sym;<br>      dlopen(sym-&gt;name); <span class="hljs-comment">// load recursively</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="来解释一下-按顺序-："><a href="#来解释一下-按顺序-：" class="headerlink" title="来解释一下(按顺序)："></a>来解释一下(按顺序)：</h3><ol><li><p>首先需要dl_gcc各.S文件得到.dl。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原来命令行还可以这么写！ 前一句生成64位的位置无关代码，然后再把代码段拷贝成.dl文件。这里主要是一些宏替换，并且由于我们的汇编代码格式是很严格地按照dl_hdr的形式写的，所以我们得到的其实是一个dl_lib的结构体。更直观地来感受一下，我们使用命令gcc -E main.S,得到宏替换展开的文件(如下):</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 0 &quot;main.S&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot; 2</span><br><span class="hljs-comment"># 1 &quot;main.S&quot;</span><br><span class="hljs-comment"># 1 &quot;dl.h&quot; 1</span><br><span class="hljs-comment"># 2 &quot;main.S&quot; 2</span><br><br>__hdr: <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__end - __hdr)</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__code - __hdr)</span><br><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libc.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libhello.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; hello: <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(main - __hdr)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;#&quot;</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><br><span class="hljs-string">.fill</span> 32 - 1, 1, 0; <span class="hljs-string">.align</span> 32, 0; __code:<br><br>main:<br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  movq $0, %rax<br>  ret<br><br>__end:<br></code></pre></td></tr></table></figure><blockquote><p>xxd main.dl命令得到二进制文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dotnetcli">00000000: 0114 0514 e000 0000 c000 0000 0000 0000  ................<br>00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 2b6c 6962 632e 646c  ........+libc.dl<br>00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000040: 0000 0000 0000 0000 2b6c 6962 6865 6c6c  ........+libhell<br>00000050: 6f2e 646c 0000 0000 0000 0000 0000 0000  o.dl............<br>00000060: 0000 0000 0000 0000 3f68 656c 6c6f 0000  ........?hello..<br>00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000080: c000 0000 0000 0000 236d 6169 6e00 0000  ........#main...<br>00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000c0: ff15 9aff ffff ff15 94ff ffff ff15 8eff  ................<br>000000d0: ffff ff15 88ff ffff 48c7 c000 0000 00c3  ........H.......<br></code></pre></td></tr></table></figure><blockquote><p>libc.dl、libhello.dl、hello这三个符号都是填零的。只有main函数已经填上了正确的偏移。<br>可以反推，我们得到的.dl文件的格式是这样的：首先是__hdr头，这里有模数，文件的大小，以及代码段的偏移。 然后是符号表；符号表结束后，再32个字节填0作为分界线，然后是代码段。 妙哇妙哇！原来宏定义还可以这么用！</p></blockquote></li><li><p><strong>然后是dl_interp函数来解释执行</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>找到main函数，exit(entry()) 的作用就是在程序结束时执行 main 函数，并将其返回值作为程序的退出码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>这里要打开.dl文件，并且把这个文件用mmap函数映射到dlbox进程的地址空间，此时其他.dl文件的代码段就会映射到dlbox进程的地址空间中，也就可以确定函数的地址了，这也就和动态链接的链接时绑定思想不谋而合。打开这个可执行程序时，h-&gt;symtab &#x3D; (struct symbol *)((char *)h + REC_SZ);这里是初始化符号表。</li><li>如果遇到.dl作为符号表项(‘+’)，则用dlload递归加载，dlload则是调用dlopen实现的。</li><li>如果遇到符号表项的某一项标记位’?’,表示引用外部符号，我们通过查表dlsym函数来填表。</li><li>可以想象，这是一个递归的过程，递归地填表。如果变量是这个main程序的函数(‘#’),我们直接可以确定该函数的地址。也就是表头的地址加上偏移。</li><li>如果这个符号是个.dl文件，则需要调用dlopen把这个文件整体映射进进程的地址空间(递归)，映射完后，所有符号的地址都会被确定，然后我们就可以遍历来填sym表了。这个sym表记录了所有符号，也是一个结构体，一开始所有的项的name字段初始化为NULL。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>如果这个符号是外部的函数，由于我们先包含.dl的库文件，所以外部符号这时候都会解析完毕，我们就可以直接填入正确的地址。</li><li>上面的思想主要是：我们在装载动态库的时候，我们不像静态链接那样可以知道这个模块是装载在哪个位置的。我们的解决方法是通过间接跳转在本模块的某个位置(这是可以确定的)，这个位置就有这个函数的地址的信息。由于我们都是按模块装载的，所以这一点并不难实现，通过添加一个sym的全局变量结构数组，在每装载一个模块(.dl)时，就把该模块的所有这个模块的export类型的变量全部填入这个sym数组中。<br>然后，有了这个sym数组，就可以开始回填到每个模块的符号表中带有(‘?’)的符号offset字段了。</li></ol></blockquote></li></ol><hr><h3 id="反思与改进-最精彩的部分"><a href="#反思与改进-最精彩的部分" class="headerlink" title="反思与改进(最精彩的部分)"></a><strong>反思与改进(最精彩的部分)</strong></h3><h5 id="一些小缺陷"><a href="#一些小缺陷" class="headerlink" title="一些小缺陷"></a>一些小缺陷</h5><ul><li>存储保护和加载位置。允许将.dl中的一部分以某个指定的权限映射到内存的某个位置—&gt;程序头表</li><li>允许自由指定加载器—&gt;加入INTERP</li><li>空间浪费 —&gt;字符串存储在常量池，统一通过“指针”访问(这也是ELF难读的原因)</li></ul><h5 id="另一个大缺陷"><a href="#另一个大缺陷" class="headerlink" title="另一个大缺陷"></a>另一个大缺陷</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>一种写法，两种情况</p></blockquote><ul><li>来自于其他编译单元(静态链接)</li><li>动态链接库</li></ul><p>例如，有a.o和b.o静态链接再和lib.so动态链接,如果a.o中引用了一个外部符号foo,那么该如何判断这个符号究竟是属于哪个单元呢？如果只是简单地宏替换, call *foo(%rip),但其实这样是效率很低的。</p><h5 id="“发明”PLT-GOT"><a href="#“发明”PLT-GOT" class="headerlink" title="“发明”PLT &amp; GOT"></a>“发明”PLT &amp; GOT</h5><blockquote><p>先编译为相对于%rip的简单的call调用，在链接的时候，如果发现这是一个本单元的符号，直接相对于rip寻址；如果发现这是一个外部(动态链接)库的话，就需要plt这条entry,再把地址填上去。</p></blockquote><blockquote><p>我们的“符号表”就是Global Offset Table(GOT).</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000000011e0</span> &lt;printf@plt&gt;:<br>    <span class="hljs-attribute">11e0</span>:       f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa             endbr64<br>    <span class="hljs-attribute">11e4</span>:       f2 ff <span class="hljs-number">25</span> <span class="hljs-number">7</span>d <span class="hljs-number">2</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span>    bnd jmp *<span class="hljs-number">0</span>x2d7d(%rip)        # <span class="hljs-number">3</span>f68 &lt;printf@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span>&gt;<br>    <span class="hljs-attribute">11eb</span>:       <span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>咦，这条jmp指令不是有点熟悉吗？和我们的DSYM很相似。这不印证了我们的猜想吗？</p></blockquote><h5 id="最后一个问题：数据"><a href="#最后一个问题：数据" class="headerlink" title="最后一个问题：数据"></a>最后一个问题：数据</h5><blockquote><p>不管多少个静态库动态库，但我们的程序只有一个errno,environ,stdout。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux世界中的应用程序(构建最小的Linux)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/</url>
    
    <content type="html"><![CDATA[<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><ul><li><p>加载第一个进程 （init 应用程序）</p><blockquote><p>相当于在操作系统中放置一个位于初始状态的状态机</p></blockquote></li><li><p>包含一些进程可以操纵的操作系统对象</p></li><li><p>然后 Linux 变成一个中断(系统调用)处理程序</p></li></ul><p>systemd为什么是进程树的根 (init 进程并不是 systemd)</p><h2 id="Linux-Kernel-系统调用上的发行版和应用生态"><a href="#Linux-Kernel-系统调用上的发行版和应用生态" class="headerlink" title="Linux Kernel 系统调用上的发行版和应用生态"></a>Linux Kernel 系统调用上的发行版和应用生态</h2><ul><li>系统工具 coreutils, binutils, systemd, ….</li><li>桌面系统 </li><li>应用程序</li></ul><h2 id="构建最小的Linux"><a href="#构建最小的Linux" class="headerlink" title="构建最小的Linux"></a>构建最小的Linux</h2><p>目标：把Linux内核启动起来，把minimal.S的二进制文件加载，打印HelloWorld，然后就退出。</p><p>我们真正的壁垒</p><ol><li>怎么样提出问题</li><li>怎样回答问出的问题</li></ol><p>问题：  我希望用 QEMU 在给定的 Linux 内核完成初始化后，直接执行我自己编写的、静态链接的 init 二进制文件。我应该怎么做？</p><ol><li>需要编译一个静态链接的 init 二进制文件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ gcc -<span class="hljs-keyword">static</span> -o <span class="hljs-keyword">init</span> <span class="hljs-keyword">init</span>.c<br></code></pre></td></tr></table></figure></li><li>创建一个 initramfs 文件系统，其中包含您的 init 二进制文件和任何其他必需的文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">initramfs:<br><span class="hljs-comment"># Copy kernel and busybox from the host system</span><br>@<span class="hljs-built_in">mkdir</span> -p build/initramfs/bin<br>sudo bash -c <span class="hljs-string">&quot;cp /boot/vmlinuz build/ &amp;&amp; chmod 666 build/vmlinuz&quot;</span><br><span class="hljs-built_in">cp</span> init build/initramfs/<br><span class="hljs-built_in">cp</span> $(shell <span class="hljs-built_in">which</span> busybox) build/initramfs/bin/<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>什么是 cpio </p><blockquote><p>cpio 是一个类似于 tar 的工具，用于创建和提取归档文件。最终，归档文件将输出到名为 initramfs.cpio 的文件中。这个命令通常用于创建一个自定义的 initramfs 文件系统，以便在启动时加载自定义的软件和配置文件。</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> build/initramfs &amp;&amp; \<br>find . -print0 \<br>| cpio <span class="hljs-params">--null</span> -ov <span class="hljs-params">--format=newc</span> \<br>| gzip -9 &gt; <span class="hljs-string">../initramfs.cpio.gz</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 initramfs</p><blockquote><p>initramfs 是一个临时文件系统，它被加载到内存中，以便在 Linux 内核初始化后提供一个初始根文件系统。这个临时的根文件系统在根文件系统挂载之前执行必要的初始化任务。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-initrd build/initramfs.cpio.gz<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>然后，您需要在 QEMU 中将 initramfs 文件系统加载到内存中，并将 init 二进制文件设置为 init 进程。您可以使用以下命令启动 QEMU：<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">run:<br><span class="hljs-comment"># Run QEMU with the installed kernel and generated initramfs</span><br>qemu-system-x86_64 <span class="hljs-string">\</span><br>  -serial mon:stdio <span class="hljs-string">\</span><br>  -kernel build/vmlinuz <span class="hljs-string">\</span><br>  -initrd build/initramfs.cpio.gz <span class="hljs-string">\</span><br>  -machine accel=kvm:tcg <span class="hljs-string">\</span><br>  -append <span class="hljs-string">&quot;console=ttyS0 quiet rdinit=$(INIT)&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>rdinit&#x3D;init 是一个内核命令行参数，用于指定内核启动后应该运行哪个程序作为根文件系统的初始化进程。在 Linux 系统中，init 进程是所有进程的祖先进程，负责启动系统中的各种服务和进程。rdinit&#x3D;init 参数告诉内核在启动时运行名为 init 的程序作为 init 进程，这通常是指在 initramfs 文件系统中的程序。<br>如果这个init进程中途结束退出了的话，例如把这个init进程换成我们的一个minimal.S(简单的打印后退出)，那么由于init进程结束，系统会panic。init进程有着特殊的作用。</p></blockquote></li></ol><ul><li>什么是busybox<blockquote><p>Busybox是一个开源工具集，集成了许多常用的Unix工具，如ls、cat、grep、find等，可以在嵌入式系统中提供命令行界面的支持。Busybox的目标是提供一个小巧、高效的Unix工具集。</p></blockquote></li></ul><ol><li>busybox sh 就变成一个 shell</li><li>busybox ls 就执行 ls 命令</li></ol><ul><li>busybox 可以看成Linux所有程序的一个打包</li></ul><ul><li><p>init 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (2) Run a shell on the init console</span><br><span class="hljs-variable">$BB</span> sh<br></code></pre></td></tr></table></figure><p>把 init 程序换成这个脚本后，系统启动没有 kernel panic了。<br>make run启动后，得到了一个Linux的终端，但输入 ls 命令是没有反应的。</p><blockquote><p>回想一下：系统在启动以后，只有 init 和 busybox，系统并不认识 ls 命令。可以 &#x2F;bin&#x2F;busybox ls。</p></blockquote></li><li><p>那应该怎么办？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (3) Rock&#x27;n Roll!</span><br><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-variable">$BB</span> sh<br><br><span class="hljs-built_in">mkdir</span> -p /tmp<br><span class="hljs-built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc  none /proc<br><span class="hljs-built_in">mkdir</span> -p /sys  &amp;&amp; mount -t sysfs none /sys<br><span class="hljs-built_in">mknod</span> /dev/tty c 4 1<br>setsid /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1<br></code></pre></td></tr></table></figure></li><li><p>在 &#x2F;bin 目录下创建多个命令的快捷方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>最后回答什么是 systemd, 它为什么是进程树的根。</p><blockquote><p>在之后，会执行 &#x2F;usr&#x2F;sbin&#x2F;init<br>可以看到，这是个快捷方式，指向 &#x2F;lib&#x2F;systemd&#x2F;systemd</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码风格和定制化gdb调试</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ol><li>编程中的一些细节</li><li>调试工具的正确使用方法</li></ol><h3 id="软件的热更新DSU"><a href="#软件的热更新DSU" class="headerlink" title="软件的热更新DSU"></a>软件的热更新DSU</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOSTRING(s)  STRINGIFY(s)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">padding</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;.fill &quot;</span> TOSTRING(PADDING) <span class="hljs-string">&quot;, 1, 0x90&quot;</span></span><br><span class="hljs-params">  )</span>;<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In old function %s\n&quot;</span>, __func__);<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo_new</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In new function %s\n&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-comment">// 48 b8 (64-bit imm)   movabs $imm,%rax</span><br><span class="hljs-comment">// ff e0                jmpq   *%rax</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> PATCH[] = <span class="hljs-string">&quot;\x48\xb8--------\xff\xe0&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DSU</span><span class="hljs-params">(<span class="hljs-type">void</span> *func, <span class="hljs-type">void</span> *func_new)</span> &#123;<br>  <span class="hljs-type">int</span> flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;<br><br>  <span class="hljs-comment">// Grant write permission to the memory</span><br>  <span class="hljs-comment">// We must handle boundary cases</span><br>  <span class="hljs-type">uintptr_t</span> fn = (<span class="hljs-type">uintptr_t</span>)func;<br>  <span class="hljs-type">uintptr_t</span> base = fn &amp; ~<span class="hljs-number">0xfff</span>;<br>  <span class="hljs-keyword">if</span> (fn + <span class="hljs-keyword">sizeof</span>(PATCH) &gt; base + <span class="hljs-number">4096</span>) &#123;<br>    np = <span class="hljs-number">2</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    np = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;np = %d\n&quot;</span>, np);<br><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, flag);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>  <br>  <span class="hljs-comment">// Patch the first instruction (this is UB in C spec)</span><br>  <span class="hljs-built_in">memcpy</span>(func, PATCH, <span class="hljs-keyword">sizeof</span>(PATCH));<br>  <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span> *)func + <span class="hljs-number">2</span>, &amp;func_new, <span class="hljs-keyword">sizeof</span>(func_new));<br><br>  <span class="hljs-comment">// Revoke the write permission</span><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, PROT_READ | PROT_EXEC);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  foo();<br>  DSU(foo, foo_new);  <span class="hljs-comment">// Dynamic software update</span><br>  foo();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些编程小技巧"><a href="#一些编程小技巧" class="headerlink" title="一些编程小技巧"></a>一些编程小技巧</h4><ul><li><p>什么是 __func__？</p><blockquote><p><strong>func</strong> 是C语言中的一个内置宏，它返回当前函数的名称作为一个字符串常量。它可以用于调试和错误报告，以便在程序出错时能够更容易地确定错误发生在哪个函数中。<br>相当于：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">my_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __func__ <span class="hljs-string">&quot;my_func&quot;</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current function: %s\n&quot;</span>, __func__);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __func__ </span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 <strong>func</strong> 宏不需要包含任何头文件，因为它是C语言的内置宏，可以直接在代码中使用。</p></blockquote></li><li><p>使用 assert 断言</p><blockquote><p>有利于 bug 的定位</p></blockquote></li></ul><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><ul><li><p>为什么要把函数设置成 inline?<br>内联函数（inline function）是一种编译器提供的优化手段，它的本质是将函数在调用处展开，从而避免了函数调用的开销。也就是说，内联函数不是真正的函数调用，而是将函数的代码嵌入到调用处，类似于宏替换。</p></li><li><p>打一个小补丁</p><blockquote><p>我们知道，在调用一个函数的时候，首先 call foo, 把返回地址压栈，并跳转到foo函数处，然后再在foo函数那里给上一个补丁。</p></blockquote><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">movabs <span class="hljs-built_in">$imm</span> , <span class="hljs-built_in">%rax</span><br>jump *(rax)<br></code></pre></td></tr></table></figure><p>%rax是 foo_new函数的地址，因为foo_new函数最后也会调用 ret 指令，所以结束后返回到原来的地方。</p></li></ul><h3 id="用好工具"><a href="#用好工具" class="headerlink" title="用好工具"></a>用好工具</h3><ul><li>如何让gdb以更友好的方式帮我们打印相关的信息？<br>计算机公理3：让你感到不适的 tedious 工作，一定有办法提高效率。</li></ul><blockquote><p>用python写一个脚本，增加一个自定义的gdb命令</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>REGS = [<br>    <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;rbx&#x27;</span>, <span class="hljs-string">&#x27;rcx&#x27;</span>, <span class="hljs-string">&#x27;rdx&#x27;</span>,<br>    <span class="hljs-string">&#x27;rbp&#x27;</span>, <span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-string">&#x27;rsi&#x27;</span>, <span class="hljs-string">&#x27;rdi&#x27;</span>,<br>    <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-string">&#x27;r9&#x27;</span>, <span class="hljs-string">&#x27;r10&#x27;</span>, <span class="hljs-string">&#x27;r11&#x27;</span>,<br>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RegDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(RegDump, self).__init__(<br>            <span class="hljs-string">&quot;rdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, arg, _</span>):<br>        <span class="hljs-comment"># 得到变量 ctx 的值</span><br>        <span class="hljs-comment"># 每次输入 rdump 命令会执行 invoke 函数</span><br>        ctx = gdb.parse_and_eval(<span class="hljs-string">f&#x27;ctx&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(REGS):<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;r.upper():<span class="hljs-number">3</span>&#125;</span> = <span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(ctx[r]):016x&#125;</span>&#x27;</span>,<br>                end=[<span class="hljs-string">&#x27;  &#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>][i % <span class="hljs-number">2</span>]<br>            )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>RegDump()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_source_line</span>(<span class="hljs-params">address</span>):<br>    <span class="hljs-comment"># by GPT-4</span><br><br>    <span class="hljs-comment"># Find the source code line corresponding to the given address</span><br>    symtab_and_line = gdb.find_pc_line(address)<br><br>    <span class="hljs-comment"># Check if the source code line was found</span><br>    <span class="hljs-keyword">if</span> symtab_and_line.symtab <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Get the source file name and line number</span><br>        filename = symtab_and_line.symtab.filename<br>        line_number = symtab_and_line.line<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Path(filename).name&#125;</span>:<span class="hljs-subst">&#123;line_number&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Source code line not found&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        n = gdb.parse_and_eval(<span class="hljs-string">f&#x27;NTASK&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            tsk = gdb.parse_and_eval(<span class="hljs-string">f&#x27;tasks[<span class="hljs-subst">&#123;i&#125;</span>]&#x27;</span>)<br>            pc = <span class="hljs-built_in">int</span>(tsk[<span class="hljs-string">&#x27;context&#x27;</span>][<span class="hljs-string">&#x27;rip&#x27;</span>])<br>            is_current = <span class="hljs-built_in">int</span>(<br>                gdb.parse_and_eval(<span class="hljs-string">f&#x27;&amp;tasks[<span class="hljs-subst">&#123;i&#125;</span>] == current&#x27;</span>)<br>            )<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;Proc-<span class="hljs-subst">&#123;i&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&quot; *&quot;</span>[is_current]&#125;</span> &#x27;</span>,<br>                get_source_line(pc)<br>            )<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>ProcDump()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程地址空间</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux进程的地址空间"><a href="#Linux进程的地址空间" class="headerlink" title="Linux进程的地址空间"></a>Linux进程的地址空间</h2><p>有什么工具可以来查看进程的地址空间</p><ol><li>pmap</li><li>cat &#x2F;proc&#x2F; [pid] &#x2F; maps</li><li>gdb</li><li>readelf</li><li>objdump</li></ol><p>有的程序刚开始执行就结束了(比如打印一个东西就退出)，如果要查看这个进程的地址空间。那怎么办？</p><blockquote><p>使用gdb。<br>使用gdb命令 info inferiors得到进程的pid</p></blockquote><ul><li>该命令打印gdb当前管理的inferiors列表，每个inferior都有自己的不同地址空间，inferior与进程对应。</li></ul><ol><li><p>得到进程的pid后,使用命令 !pmap [pid], 在gdb中使用shell命令需要在前面加上 ！。</p></li><li><p>同样，在gdb中，还可以使用 !cat &#x2F;proc&#x2F; [pid] &#x2F;maps来查看进程的地址空间。</p></li></ol><ul><li>其实pmap就是使用系统中的 &#x2F;proc&#x2F;[pid]&#x2F;这个文件实现的。<br>怎么证明呢？<blockquote><p>使用 strace   strace pmap [pid]</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>gdb调试starti之后，查看进程的地址空间：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">8</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>     <span class="hljs-number">16</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>              <span class="hljs-number">416</span>K<br></code></pre></td></tr></table></figure><p>我们还发现，在按下starti后，有一条信息：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fe32b0 in _start () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>说明动态链接的第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2中，甚至在地址空间中此时也没有libc这个库。<br>在状态机在刚刚被初始化的一瞬间，在进程里面还没有printf。</p><blockquote><p>动态链接的ELF文件中，有一个INTERP, 就是这里的ld-linux-x86-64.so.2, 需要另外一个程序，才能执行现在这个程序，对于动态链接来说，这就是加载器。</p></blockquote><p>再在main函数上打个断点，continue后再打印一次进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555558000</span>      <span class="hljs-number">4</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7d7f000</span>     <span class="hljs-number">12</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7d82000</span>    <span class="hljs-number">160</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7daa000</span>   <span class="hljs-number">1620</span>K r-x-- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f3f000</span>    <span class="hljs-number">352</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f97000</span>     <span class="hljs-number">16</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9b000</span>      <span class="hljs-number">8</span>K rw--- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9d000</span>     <span class="hljs-number">52</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbb000</span>      <span class="hljs-number">8</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffd000</span>      <span class="hljs-number">8</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>             <span class="hljs-number">2644</span>K<br></code></pre></td></tr></table></figure><p>如上，我们发现libc已经有了。加载器也还在，未来可能还需要这个加载器加载其他动态链接库。</p><h4 id="其他小细节"><a href="#其他小细节" class="headerlink" title="其他小细节"></a>其他小细节</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> main&#123;<br><span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在库都加载完成后，用 !cat &#x2F;proc&#x2F;14776&#x2F;&#x2F;maps 查看该进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7ffff7fbd000</span>-<span class="hljs-number">7</span>ffff7fc1000 r--p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vvar]</span><br><br><span class="hljs-attribute">7ffff7fc1000</span>-<span class="hljs-number">7</span>ffff7fc3000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vdso]</span><br><br></code></pre></td></tr></table></figure><p>我们发现这两行， vvar 和 vdso 是什么？</p><blockquote><p>不进入内核的系统调用。<br>vvar is a memory region that contains kernel variables that are frequently accessed by user-space programs. These variables are read-only and can be accessed directly by the user-space programs without making a system call.<br>例如<br>当前的时间， 系统页面大小<br>vdso is a memory region that contains a small shared library provided by the kernel. This library contains a set of functions that are commonly used by user-space programs and can be excuted directly in user mode, without the need for a system call.</p></blockquote><h3 id="进程地址空间的管理"><a href="#进程地址空间的管理" class="headerlink" title="进程地址空间的管理"></a>进程地址空间的管理</h3><p>操作系统应该提供一个修改进程地址空间的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 映射</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br><br><span class="hljs-comment">// 修改映射权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>本质：在状态机状态上增加&#x2F;删除&#x2F;修改一段可访问的内存</p><ul><li>mmap: 可以用来申请内存 (MAP_ANONYMOUS)，也可以把文件 “搬到” 进程地址空间中</li></ul><p>一小段示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GiB * (1024LL * 1024 * 1024)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *p = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span> GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap: %lx\n&quot;</span>, (<span class="hljs-type">uintptr_t</span>)p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)p == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;cannot map&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  *(p + <span class="hljs-number">2</span> GiB) = <span class="hljs-number">1</span>;<br>  *(p + <span class="hljs-number">4</span> GiB) = <span class="hljs-number">2</span>;<br>  *(p + <span class="hljs-number">7</span> GiB) = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">4</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">6</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">7</span> GiB));<br>&#125;<br></code></pre></td></tr></table></figure><p>疑问：这个程序运行会不会需要很长的时间，因为它分配了那么多的内存？</p><blockquote><p>其实一瞬间就完成了。也就是说，在使用mmap的时候，只是在操作系统中标记了这个进程这么多的内存，这个进程中这些内存还并没有开始分配，只是在后面用到了才会产生缺页中断。</p></blockquote><h3 id="入侵地址空间"><a href="#入侵地址空间" class="headerlink" title="入侵地址空间"></a>入侵地址空间</h3><p>进程 (M,  R 状态机) 在 “无情执行指令机器” 上执行</p><ul><li>状态机是一个封闭世界</li><li>但如果允许一个进程对其他进程的地址空间有访问权？</li></ul><p>一些入侵地址空间的例子</p><ol><li>调试器(gdb)</li></ol><ul><li>gdb 可以任意观测和修改程序的状态</li></ul><ol start="2"><li>Profiler (perf)</li></ol><h4 id="入侵进程地址空间-1-金山游侠"><a href="#入侵进程地址空间-1-金山游侠" class="headerlink" title="入侵进程地址空间 (1): 金山游侠"></a>入侵进程地址空间 (1): 金山游侠</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_WATCH 65536</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <span class="hljs-comment">// Name of the binary</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-type">int</span> memfd;         <span class="hljs-comment">// Address space of the process</span><br>  <span class="hljs-type">int</span> bits;          <span class="hljs-comment">// Search bit-width (16, 32, or 64)</span><br>  <span class="hljs-type">bool</span> has_watch;    <span class="hljs-comment">// Watched values</span><br>  <span class="hljs-type">uintptr_t</span> watch[MAX_WATCH];<br>&#125;;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span>;<br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint32_t</span> val)</span> &#123;<br>  <span class="hljs-type">uintptr_t</span> start, kb;<br>  <span class="hljs-type">char</span> perm[<span class="hljs-number">16</span>];<br>  FILE *fp = popens(<span class="hljs-string">&quot;pmap -x $(pidof %s) | tail -n +3&quot;</span>, g-&gt;name);<br>  <span class="hljs-type">int</span> nmatch = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;start) == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%ld%*ld%*ld%s%*[^\n]s&quot;</span>, &amp;kb, perm);<br>    <span class="hljs-keyword">if</span> (perm[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Non-writable areas</span><br><br>    <span class="hljs-type">uintptr_t</span> size = kb * <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for brevity</span><br>    lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>    size = read(g-&gt;memfd, mem, size);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Scanning %lx--%lx\n&quot;</span>, start, start + size);<br><br>    <span class="hljs-keyword">if</span> (!g-&gt;has_watch) &#123;<br>      <span class="hljs-comment">// First-time search; scan all memory</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> off = <span class="hljs-number">0</span>; off &lt; size; off += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>        <span class="hljs-keyword">if</span> (v == val &amp;&amp; nmatch &lt; MAX_WATCH) &#123;<br>          g-&gt;watch[nmatch++] = start + off;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Search in the watched values</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>        <span class="hljs-type">intptr_t</span> off = g-&gt;watch[i] - start;<br>        <span class="hljs-keyword">if</span> (g-&gt;watch[i] &amp;&amp; <span class="hljs-number">0</span> &lt;= off &amp;&amp; off &lt; size) &#123;<br>          <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>          <span class="hljs-keyword">if</span> (v == val) nmatch++;<br>          <span class="hljs-keyword">else</span> g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(mem);<br>  &#125;<br>  pclose(fp);<br><br>  <span class="hljs-keyword">if</span> (nmatch &gt; <span class="hljs-number">0</span>) &#123;<br>    g-&gt;has_watch = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d match(es).\n&quot;</span>, nmatch);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">overwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint64_t</span> val)</span> &#123;<br>  <span class="hljs-type">int</span> nwrite = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++)<br>    <span class="hljs-keyword">if</span> (g-&gt;watch[i]) &#123;<br>      lseek(g-&gt;memfd, g-&gt;watch[i], SEEK_SET);<br>      write(g-&gt;memfd, &amp;val, g-&gt;bits / <span class="hljs-number">8</span>);<br>      nwrite++;<br>    &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d value(s) written.\n&quot;</span>, nwrite);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>    g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  g-&gt;has_watch = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Search for %d-bit values in %s.\n&quot;</span>, g-&gt;bits, g-&gt;name);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">load_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  FILE *pid_fp;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  g-&gt;name = name;<br>  g-&gt;bits = <span class="hljs-number">32</span>;<br>  reset(g);<br><br>  pid_fp = popens(<span class="hljs-string">&quot;pidof %s&quot;</span>, g-&gt;name);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(pid_fp, <span class="hljs-string">&quot;%d&quot;</span>, &amp;g-&gt;pid) != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Panic: fail to get pid of \&quot;%s\&quot;.\n&quot;</span>, g-&gt;name);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>release:<br>  <span class="hljs-keyword">if</span> (pid_fp) pclose(pid_fp);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &gt;= <span class="hljs-number">0</span>) &#123;<br>    close(g-&gt;memfd);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">long</span> val;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> <span class="hljs-title">game</span>;</span><br><br>  <span class="hljs-keyword">if</span> (load_game(&amp;game, argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (!feof(<span class="hljs-built_in">stdin</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s %d) &quot;</span>, game.name, game.pid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> release;<br><br>    <span class="hljs-keyword">switch</span> (buf[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-keyword">goto</span> release; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); game.bits = val; reset(&amp;game); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); scan(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); overwrite(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>: reset(&amp;game); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>release:<br>  close_game(&amp;game);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span> &#123;<br>  <span class="hljs-type">char</span> cmd[<span class="hljs-number">128</span>];<br>  va_list args;<br>  va_start(args, fmt);<br>  vsnprintf(cmd, <span class="hljs-keyword">sizeof</span>(cmd), fmt, args);<br>  va_end(args);<br>  FILE *ret = popen(cmd, <span class="hljs-string">&quot;r&quot;</span>);<br>  assert(ret);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span> &#123;<br>  <span class="hljs-type">uint64_t</span> val = *(<span class="hljs-type">uint64_t</span> *)(&amp;mem[off]);<br>  <span class="hljs-keyword">switch</span> (bits) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: val &amp;= <span class="hljs-number">0xffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: val &amp;= <span class="hljs-number">0xffffffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>: <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码导读</p><ul><li>va_list，va_start()、va_arg() 和 va_end() 是什么<blockquote><p>这可以使C语言实现变长参数。</p><blockquote><p>va_list 是一个类型，用于表示可变参数列表。<br>va_start() 宏用于初始化可变参数列表<br>va_arg() 宏用于访问可变参数列表中的下一个参数<br>va_end() 宏用于结束可变参数列表的访问</p></blockquote></blockquote></li><li>一段小例子<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> &#123;<br>    va_list ap;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;<br><br>    va_start(ap, count); <span class="hljs-comment">// 初始化可变参数列表</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        total += va_arg(ap, <span class="hljs-type">double</span>); <span class="hljs-comment">// 获取下一个参数</span><br>    &#125;<br><br>    va_end(ap); <span class="hljs-comment">// 结束可变参数列表</span><br><br>    <span class="hljs-keyword">return</span> total / count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> avg = average(<span class="hljs-number">5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;平均值为：%f\n&quot;</span>, avg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>popen函数</p><blockquote><p>popen()会调用fork()产生子进程，然后从子进程中调用&#x2F;bin&#x2F;sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。</p></blockquote></blockquote></li><li>也就是说，首先获取游戏进程的名字后，先创建一个子进程执行 pidof [name]的命令，可以获取游戏进程pid。然后fscanf(pid_fp, “%d”, &amp;g-&gt;pid) !&#x3D; 1读取该进程pid。<br>接着打开&#x2F;proc&#x2F;[pid]&#x2F;mem这个文件。g-&gt;memfd指向这个文件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br></code></pre></td></tr></table></figure></li><li>scan函数<br>在用pmap得到虚拟地址区域后，就可以把这个区域映射到入侵程序的地址空间中，并得到起始地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for </span><br></code></pre></td></tr></table></figure></li><li>之后把 &#x2F;proc&#x2F;pid&#x2F;mem的文件偏移设为虚拟地址区域起始处。</li></ul><ul><li>如果想要在&#x2F;proc&#x2F;pid&#x2F;mem 文件访问进程的虚拟地址 0x12345678，您需要将文件偏移量设置为 0x12345678。<br>并把这个区域的内存全部写入入侵进程的地址空间中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>size = read(g-&gt;memfd, mem, size);<br></code></pre></td></tr></table></figure></li></ul><ul><li>然后就可以根据偏移，可以把相应的地址对应起来了。大致意思就是在入侵地址里暴力寻找符合条件的地址，然后根据找的的符合条件的地址，由于偏移是一样的，也就可以把这个地址对应到被入侵进程的相应虚拟地址区域中了。</li></ul><h4 id="入侵进程地址空间-2-变速齿轮"><a href="#入侵进程地址空间-2-变速齿轮" class="headerlink" title="入侵进程地址空间 (2): 变速齿轮"></a>入侵进程地址空间 (2): 变速齿轮</h4><p>用修改程序系统调用的手段来欺骗程序对时间的认识，就可以实现游戏的加速和减速。</p><ul><li><p>简单的一段C程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> hp = <span class="hljs-number">10000</span>;<br><br>__attribute__((noinline)) <span class="hljs-type">int</span> <span class="hljs-title function_">hit</span><span class="hljs-params">(<span class="hljs-type">int</span> damage)</span> &#123;<br>  <span class="hljs-keyword">return</span> hp - damage;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    hp = hit(rand() % <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hp = %d\n&quot;</span>, hp);<br>    usleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">if</span> (hp &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>python 脚本</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(argv) &lt; <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Usage <span class="hljs-subst">&#123;argv[<span class="hljs-number">0</span>]&#125;</span> [--hp] [--fast] [--slow]&#x27;</span>)<br>    exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">addr, patch</span>):<br>    pid = <span class="hljs-built_in">int</span>(subprocess.check_output([<span class="hljs-string">&#x27;pidof&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/mem&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.seek(addr)<br>        fp.write(patch)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">symbol</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> subprocess.check_output([<span class="hljs-string">&#x27;nm&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]).splitlines():<br>        tokens = line.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).split()<br>        <span class="hljs-keyword">if</span> tokens[-<span class="hljs-number">2</span>:] == [<span class="hljs-string">&#x27;T&#x27;</span>, symbol]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tokens[<span class="hljs-number">0</span>], base=<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--hp&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># hit -&gt; mov $9999999, %eax; ret</span><br>    patch(name(<span class="hljs-string">&#x27;hit&#x27;</span>), <span class="hljs-string">b&#x27;\xb8\x7f\x96\x98\x00\xc3&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--slow&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shl $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xe7\x04&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--fast&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shr $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xef\x04&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork的应用</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul><li>fork状态机复制，包括持有的所有操作系统对象(如文件描述符)</li><li>execve重置状态机，但继承持有的所有操作系统的对象</li><li>例如在fork之前打开一个管道, 然后就可以把一部分计算的输出管道给另外一个进程的输入</li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><ul><li>RTFM: O_CLOEXEC : execve时文件描述符不应该被继承； O_APPEND：以追加的方式写该文件</li><li>对于数据文件，文件描述符会记住上次访问的位置</li><li>dup：复制一个文件描述符，进程有两个fd指向同一个文件，并且具有同一个offset</li></ul><h2 id="回到fork-复制，但又没有完全复制"><a href="#回到fork-复制，但又没有完全复制" class="headerlink" title="回到fork, 复制，但又没有完全复制"></a>回到fork, 复制，但又没有完全复制</h2><p>概念上状态机被复制，但实际上复制后内存都共享</p><ul><li>“Copy on Write”只有被写入的页面才会复制一份<ol><li>被复制后，整个地址空间都被标记位”只读”</li><li>操作系统捕获Page Fault后酌情复制页面</li><li>操作系统会维护每个页面的引用计数</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C标准库和实现</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="我们该如何学习-C-标准库"><a href="#我们该如何学习-C-标准库" class="headerlink" title="我们该如何学习 C 标准库?"></a>我们该如何学习 C 标准库?</h2><ul><li><del>直接调试 glibc (像我们上课那样)</del></li><li>寻找更好的替代品，一定有为嵌入式设备实现的简化 libc。<blockquote><p>选择 musl<br>musl是一个轻量级的C标准库，它专注于提供高效、可靠和安全的C语言运行时环境。musl库的设计目标是遵循POSIX标准，同时保持代码的简洁和易于维护。它主要用于嵌入式系统、轻量级容器和其他类似的应用程序中，因为它比其他标准库更小、更快、更安全，并且不包含任何专有代码或许可证限制。在某些情况下，它也可以用作替代glibc的标准库。</p></blockquote></li></ul><ul><li>那怎么编译一个 C 程序用 musl 作为 libc 而不是用 glibc呢 ？<ol><li>sudo apt-get install musl-tools</li><li>编写C程序，包含 stdio.h 头文件</li><li>musl-gcc -o hello hello.c</li></ol></li></ul><h2 id="libc-的基本功能"><a href="#libc-的基本功能" class="headerlink" title="libc 的基本功能"></a>libc 的基本功能</h2><ul><li>基础数据的体系结构无关抽象</li></ul><ul><li>inttypes.h</li></ul><ul><li>字符串和数组操作</li></ul><h2 id="操作系统对象与环境"><a href="#操作系统对象与环境" class="headerlink" title="操作系统对象与环境"></a>操作系统对象与环境</h2><ul><li><p>环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **env = environ; *env; env++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *env);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>environ是一个字符指针的指针。</p></li><li><p>environ是谁赋值的？</p></li></ul><p>gdb调试<br>第一条指令的时候 environ 还没有被赋值。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fc7bfe in _dlstart () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib/</span>ld-musl-x86_64.so.<span class="hljs-number">1</span><br>(gdb) p(<span class="hljs-keyword">char</span>*) environ<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>而在main函数的时候，environ是有正确的值的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>__libc_start_main函数<br>char **envp = argv + argc + <span class="hljs-number">1</span>;<br>.....<br>.....<br><span class="hljs-regexp">//</span>__init_libc函数<br>environ = envp<br></code></pre></td></tr></table></figure><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："><a href="#本讲内容：指令序列和高级语言的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："></a>本讲内容：指令序列和高级语言的状态机模型；回答以下问题：</h2><ul><li>什么是软件 (程序)？</li><li>如何在操作系统上构造最小&#x2F;一般&#x2F;图形界面应用程序？</li><li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li></ul><h2 id="构建一个最小的程序"><a href="#构建一个最小的程序" class="headerlink" title="构建一个最小的程序"></a>构建一个最小的程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcc-编译出来的文件一点也不小"><a href="#gcc-编译出来的文件一点也不小" class="headerlink" title="gcc 编译出来的文件一点也不小"></a>gcc 编译出来的文件一点也不小</h3><ol><li>objdump 工具可以查看对应的汇编代码</li><li>–verbose 可以查看所有编译选项 (真不少)</li><li>printf 变成了 puts@plt</li><li>-Wl,–verbose 可以查看所有链接选项 (真不少)<br>原来链接了那么多东西<br>还解释了 end 符号的由来</li><li>-static 会链接 libc (大量的代码)<blockquote><p>gcc a.c 和 gcc a.c -static 有什么区别？</p></blockquote></li></ol><h3 id="强行构造最小的-Hello-World？"><a href="#强行构造最小的-Hello-World？" class="headerlink" title="强行构造最小的 Hello, World？"></a>强行构造最小的 Hello, World？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c hello<span class="hljs-selector-class">.c</span>    -&gt; hello<span class="hljs-selector-class">.o</span> <br>ld hello<span class="hljs-selector-class">.o</span> -e <span class="hljs-selector-tag">main</span>   -&gt; <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>执行a.out,会发生Segmentation Fault.</p><p>如果改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再继续执行上面的编译命令，发现程序可以正常执行了（死循环）。</p><blockquote><p>查看汇编语言，猜测程序返回时的 ret 出现了错误。</p></blockquote><h3 id="解决异常退出"><a href="#解决异常退出" class="headerlink" title="解决异常退出"></a>解决异常退出</h3><blockquote><p>解决办法：用一条特殊的指令请操作系统帮忙</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">movq $SYS_exit,  %rax   <span class="hljs-comment"># exit(</span><br>movq $1,         %rdi   <span class="hljs-comment">#   status=1</span><br><span class="hljs-keyword">syscall</span>                 <span class="hljs-comment"># );</span><br></code></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<ul><li>程序把控制权完全交给操作系统</li><li>操作系统可以改变程序状态甚至终止程序</li></ul></li></ul><h2 id="理解高级编程语言程序"><a href="#理解高级编程语言程序" class="headerlink" title="理解高级编程语言程序"></a>理解高级编程语言程序</h2><blockquote><p>编程语言也是一个状态机</p></blockquote><ul><li>非递归的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> pc, n;<br>  <span class="hljs-type">char</span> from, to, via;<br>&#125; Frame;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ret()     (&#123; top--; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  Frame stk[<span class="hljs-number">64</span>], *top = stk - <span class="hljs-number">1</span>;<br>  call(n, from, to, via);<br>  <span class="hljs-keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;<br>    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;<br>    <span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <br>      <span class="hljs-comment">// 为什么goto(4)只是设置pc为3，是因为循环会++</span><br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>什么叫函数调用<blockquote><p>函数是由很多个栈帧组成的，每一个栈帧都有一个PC</p></blockquote></li></ul><p>什么是函数调用？</p><blockquote><p> 函数调用就是在栈帧的顶部再加上一个栈帧，这个栈帧的PC是0，然后把参数放到栈上</p></blockquote><p>什么是函数返回</p><blockquote><p>  把顶部的栈给抹掉</p></blockquote><p>什么是执行一条语句</p><blockquote><p>  取最顶上栈帧PC上的语句执行</p></blockquote><ul><li>代码讲解<br>这是递归版的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    hanoi(n - <span class="hljs-number">1</span>, from, via, to);<br>    hanoi(<span class="hljs-number">1</span>,     from, to,  via);<br>    hanoi(n - <span class="hljs-number">1</span>, via,  to,  from);<br>  &#125;<br>  <span class="hljs-comment">// return 省略了</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据上面的思想，把整个hanoi函数理解成一个栈帧，每一个栈帧有一个PC，还需要参数信息</p></blockquote></li></ul><p><strong>可以理解成函数体每一条语句都是一条PC指针</strong><br>每一次循环，都会取最顶上的栈帧来操作<br>这也就是下部分的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作系统上的软件-应用程序"><a href="#操作系统上的软件-应用程序" class="headerlink" title="操作系统上的软件 (应用程序)"></a>操作系统上的软件 (应用程序)</h2><blockquote><p>任何程序 &#x3D; minimal.S &#x3D; 调用 syscall 的状态机</p></blockquote><p>可执行文件是操作系统中的对象</p><ul><li><p>与大家日常使用的文件 (a.c, README.txt) 没有本质区别</p></li><li><p>操作系统提供 API 打开、读取、改写 (都需要相应的权限)</p></li></ul><p>查看可执行文件</p><ul><li>vim, cat, xxd 都可以直接 “查看” 可执行文件</li><li>vim 中二进制的部分无法 “阅读”，但可以看到字符串常量</li><li>使用 xxd 可以看到文件以 “\x7f” “ELF” 开头</li><li>Vscode 有 binary editor 插件</li></ul><p>在 Vim 中输入 %!xxd 命令会将当前编辑的文件转换成十六进制表示，并在 Vim 中显示。这个命令的作用是将当前编辑的文件作为输入传递给 xxd 命令(%表示对整个文件执行操作)，xxd 命令会将其转换成十六进制格式，并将结果输出到标准输出流，此时 Vim 会将其读取并显示在编辑器中。</p><h2 id="动手实验：观察程序的执行"><a href="#动手实验：观察程序的执行" class="headerlink" title="动手实验：观察程序的执行"></a>动手实验：观察程序的执行</h2><p>工具程序代表：编译器 (gcc)</p><ul><li>主要的系统调用：execve, read, write</li><li>strace -f gcc a.c (gcc 会启动其他进程， -f选项会追踪所有子进程)<ul><li>可以管道给编辑器 vim -</li><li>编辑器里还可以 %!grep (细节&#x2F;技巧)</li></ul></li></ul><p>grep 命令的 -e 选项用于指定一个或多个匹配模式，这些模式可以是正则表达式或普通字符串。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">strace <span class="hljs-keyword">ls</span> |&amp; <span class="hljs-keyword">grep</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">read</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">write</span><br></code></pre></td></tr></table></figure><p>图形界面程序代表：编辑器 (xedit)</p><ul><li>主要的系统调用：poll, recvmsg, writev</li><li>strace xedit<ul><li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li><li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/02/hello-world/"/>
    <url>/2023/08/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
