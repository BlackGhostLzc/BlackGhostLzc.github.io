<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS144-lab1</title>
    <link href="/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab1/"/>
    <url>/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>背景介绍<br>在这个实验中和下一个实验中，我们需要实现TCP receiver。它接收数据报，把它们转成可靠的字节流，以供socket读取。<br>TCP sender把字节流分成不同的segments，每个segment都封装成数据报。但是网络传送可能会丢失，重复或失序，这就需要TCP receiver重新组合，还原最初的字节流。</li><li>实验目的<br>完成一个数据结构<code>StreamReassembler</code>。它接收一些子串（字节流），以及每个子串第一个字节所在字节流的索引。<br><code>StreamReassembler</code>有一个成员<code>ByteStream</code>，只要<code>StreamReassembler</code>知道了字节流的下一个字节，就会把数据写入<code>ByteStream</code>中。</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><img src="https://s1.ax1x.com/2022/10/19/xsG8nP.png" alt="capacity.png" style="zoom:67%;" />如上图所示，`capacity`是整个缓存的大小，也就是`ByteStream`的大小，蓝色部分表示已经写入并被`ByteStream`读出来的部分；绿色部分表示已经写入`ByteStream`还没有被读的部分；红色部分是需要我们在一个buffer中缓存起来的部分，就是接收到的字节流，但这一部分字节流只是已经被缓存，但还没有重组，等到连续时一并写入`ByteSream`中。我们还记得，也就是`ByteStream`中有下面几个成员：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> capacity_;<br><span class="hljs-type">size_t</span> read_size_;     <span class="hljs-comment">//总共读取的字节数</span><br><span class="hljs-type">size_t</span> write_size_;    <span class="hljs-comment">//总共写入的字节数</span><br><span class="hljs-type">bool</span> end_input_;       <span class="hljs-comment">//能否再写</span><br></code></pre></td></tr></table></figure><p>所以就是说：</p><ul><li>上图中的first unread是<code>read_size_</code></li><li>上图的first unassembled是<code>write_size_</code>，表示第一个可以写到<code>ByteStream</code>中的字节</li><li>上图的first unacceptable是<code>read_size_ + capacity_</code></li></ul><p>所以有以下几种可能性：</p><ol><li>如果子字节流的<code>index</code>落在first unacceptable之后，那么这个substring应该被丢弃。</li><li>如果子字节流全部落在[0, first unassembled - 1]中，那么这个substring已经写入了<code>ByteStream</code>中，也应该丢弃</li><li>除此之外，应该截断子字节流，使之完全落在[first unassembled - 1, first unacceptable - 1]中</li></ol><p>完成了上述操作后，应该处理字节流区间重复的问题，必须要保证<code>set&lt;Segment&gt; _buffer</code>中每个<code>Segment</code>都必须彼此不重复，具体思路见代码。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先定义<code>Segment</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// stream_reassembler.hh</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segment</span>&#123;</span><br>  public:<br>    <span class="hljs-type">size_t</span> idx_;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data_;<br>  <br>    Segment():idx_(<span class="hljs-number">0</span>),data_(<span class="hljs-string">&quot;&quot;</span>)&#123;&#125;<br>    Segment(<span class="hljs-type">size_t</span> idx, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data):idx_(idx), data_(data)&#123;&#125;<br><br>    <span class="hljs-type">bool</span> operator&lt;(<span class="hljs-type">const</span> Segment&amp; seg) <span class="hljs-type">const</span> &#123;<br>      <span class="hljs-keyword">return</span> this-&gt;idx_ &lt; seg.idx_;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为<code>StreamReassembler</code>添加成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt; _buffer;<br><span class="hljs-type">bool</span> _eof;<br><span class="hljs-type">size_t</span> _eof_idx;<br><span class="hljs-type">size_t</span> _unassembled_bytes; <br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handle_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">handle_overlap</span><span class="hljs-params">(Segment&amp; seg)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">adjustment</span><span class="hljs-params">(Segment&amp; seg, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator &amp;it)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">buffer_erase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator &amp;it)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">buffer_insert</span><span class="hljs-params">(Segment&amp; seg)</span>;<br></code></pre></td></tr></table></figure><blockquote><p> 上面的 <code>_buffer</code> 只存储位于上图中红色的区间<code>Segment</code>，红色区间的大小就为<code>_unassembled_bytes</code>。</p><p> <code>_eof_idx</code>就是当最后一个结束符号的索引，当 <code>_output</code>写的字节数(<code>bytes_written()</code>)等于 <code>_eof_idx</code> 时，应该结束输入，调用 <code>_output.end_input()</code>函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stream_reassembler.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a stream reassembler.</span><br><br><span class="hljs-comment">// For Lab 1, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab1`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `stream_reassembler.hh`</span><br><br>template &lt;typename... Targs&gt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> &#123;&#125;<br>using namespace <span class="hljs-built_in">std</span>;<br><br>StreamReassembler::StreamReassembler(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <br>    _output(capacity), <br>    _capacity(capacity), <br>    _buffer(),<br>    _eof(<span class="hljs-literal">false</span>),<br>    _eof_idx(<span class="hljs-number">0</span>),<br>    _unassembled_bytes(<span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="hljs-comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span><br><span class="hljs-comment">//! contiguous substrings and writes them into the output stream in order.</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::handle_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index)</span>&#123;<br>    <br>    <span class="hljs-keyword">auto</span> seg = Segment&#123;index, data&#125;;<br><br>    <span class="hljs-comment">// 范围是[read_size_ , read_size_ + _capacity - 1],第一个不可以被写入的索引是 read_size_ + _capacity</span><br>    <span class="hljs-comment">//      [index, index + data.length() - 1]</span><br><br>    <span class="hljs-comment">// seg落在可写区域的外面 ok</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ &gt;= _output.bytes_read() + _capacity)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// seg.data_右端如果超出了右边界</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ &lt; _output.bytes_read() + _capacity &amp;&amp;<br>       seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span> &gt;= _output.bytes_read() + _capacity)&#123;<br>        <span class="hljs-comment">// [seg.idx_, read_size_ + _capacity - 1]</span><br>        seg.data_ = seg.data_.substr(<span class="hljs-number">0</span>, _output.bytes_read() + _capacity - seg.idx_);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果seg.data_都已经写入了ByteSream中 ok</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span> &lt; _output.bytes_written())&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果seg.data_有一部分已被写入，另一部分没有被写入</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ &lt; _output.bytes_written() &amp;&amp; <br>       seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span> &gt;= _output.bytes_written())&#123;<br>        seg.data_ = seg.data_.substr(_output.bytes_written() - seg.idx_);<br>        seg.idx_ = _output.bytes_written();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(_buffer.empty())&#123;<br>        buffer_insert(seg);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    handle_overlap(seg);<br>&#125;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::adjustment</span><span class="hljs-params">(Segment&amp; seg, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator&amp; it)</span>&#123;<br>    <span class="hljs-comment">// [it_l , it_r]</span><br>    <span class="hljs-type">size_t</span> it_l = it-&gt;idx_;<br>    <span class="hljs-type">size_t</span> it_r = it-&gt;idx_ + it-&gt;data_.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// [seg_l, seg_r]</span><br>    <span class="hljs-type">size_t</span> seg_l = seg.idx_;<br>    <span class="hljs-type">size_t</span> seg_r = seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 1. 如果 seg 全包含 it 的范围     </span><br>    <span class="hljs-comment">// _buffer去除 it</span><br>    <span class="hljs-keyword">if</span>(seg_l &lt;= it_l &amp;&amp; seg_r &gt;= it_r)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 如果it全包含 seg 的范围</span><br>    <span class="hljs-comment">// seg 变为 it, _buffer删除 it </span><br>    <span class="hljs-keyword">if</span>(it_l &lt;= seg_l &amp;&amp; it_r &gt;= seg_r)&#123;<br>        seg.idx_ = it_l;<br>        seg.data_ = it-&gt;data_;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 如图下：</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        seg:           _________</span><br><span class="hljs-comment">        it:        _______</span><br><span class="hljs-comment">    */</span><br>   <br>    <span class="hljs-keyword">if</span>(seg_l &gt;= it_l &amp;&amp; seg_r &gt; it_r)&#123;<br>        seg.data_ = it-&gt;data_ + seg.data_.substr(it-&gt;idx_ + it-&gt;data_.length() - seg.idx_);<br>        seg.idx_ = it-&gt;idx_;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br><br><br>    <span class="hljs-comment">// 4. 如下图：</span><br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">        seg:      _________</span><br><span class="hljs-comment">        it:            ________</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-keyword">if</span>(it_l &gt; seg_l &amp;&amp; it_r &gt;= seg_r)&#123;<br>        seg.data_ = seg.data_.substr(<span class="hljs-number">0</span>, it-&gt;idx_ - seg.idx_) + it-&gt;data_;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::handle_overlap</span><span class="hljs-params">(Segment&amp; seg)</span>&#123;<br>    <span class="hljs-comment">// 保证插入的和原本存在的没有重叠部分</span><br>    <span class="hljs-keyword">auto</span> it = _buffer.begin();<br>    <span class="hljs-keyword">for</span>(; it != _buffer.end();)&#123;<br>        <span class="hljs-type">size_t</span> it_l = it-&gt;idx_;<br>        <span class="hljs-type">size_t</span> it_r = it-&gt;idx_ + it-&gt;data_.length() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">size_t</span> seg_l = seg.idx_;<br>        <span class="hljs-type">size_t</span> seg_r = seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 两条线段有重叠</span><br>        <span class="hljs-keyword">if</span>((it_l &gt;= seg_l &amp;&amp; it_l &lt;= seg_r) || (seg_l &gt;= it_l &amp;&amp; seg_l &lt;= it_r))&#123;<br>            adjustment(seg, it);<br>            buffer_erase(it++);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            it++;<br>        &#125;<br>    &#125;<br><br>    buffer_insert(seg);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::buffer_erase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator&amp; it)</span>&#123;<br>    <span class="hljs-comment">// 如果删除了，那么 _unassembled_bytes 就要减</span><br>    _unassembled_bytes -= it-&gt;data_.length();<br>    _buffer.erase(it);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::buffer_insert</span><span class="hljs-params">(Segment&amp; seg)</span>&#123;<br>    _unassembled_bytes += seg.data_.length();<br>    _buffer.insert(seg);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(!data.empty())&#123;<br>        handle_substring(data, index);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查 _buffer 中是否有连续的可写入 ByteStream 的部分</span><br>    <span class="hljs-comment">// 第一个可以写入的字节是 written_size_</span><br>    <span class="hljs-keyword">while</span>(!_buffer.empty() &amp;&amp; _buffer.begin()-&gt;idx_ == _output.bytes_written())&#123;<br>        <span class="hljs-keyword">auto</span> it = _buffer.begin();<br>        _output.write(it-&gt;data_);<br>        buffer_erase(it);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(eof)&#123;<br>        _eof = <span class="hljs-literal">true</span>;<br>        _eof_idx = index + data.length();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(_eof &amp;&amp; _output.bytes_written() == _eof_idx)&#123;<br>        _output.end_input();<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> _unassembled_bytes;<br>&#125;<br><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> _buffer.empty();<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-lab0</title>
    <link href="/2023/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab0/"/>
    <url>/2023/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>获取实验指导书：<a href="https://vixbob.github.io/cs144-web-page/assignments/lab0.pdf">Lab Checkpoint 0: networking warmup</a><br>个人CS144实验地址：<a href="https://github.com/BlackGhostLzc/CS144.git">github</a></p><h2 id="2-telnet手动访问网页"><a href="#2-telnet手动访问网页" class="headerlink" title="2.telnet手动访问网页"></a>2.telnet手动访问网页</h2><p>Telnet协议是TCP&#x2F;IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用<code>telnet</code>程序，用它连接到服务器。终端使用者可以在<code>telnet</code>程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。</p><p>使用 <code>telnet cs144.keithw.org http</code>命令以连接远程网页服务器，之后在终端键入以下内容:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/hello</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>cs144.keithw.org<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br></code></pre></td></tr></table></figure><p>之后看到远程服务器会返回网页的内容并展示再终端上。</p><h2 id="3-实现webget-cc"><a href="#3-实现webget-cc" class="headerlink" title="3. 实现webget.cc"></a>3. 实现webget.cc</h2><p>实验指导书上也有提示，需要借助<code>libsponge</code>库中的<code>TCPSocket</code>和<code>Address</code>两个类来实现。</p><p>注意：</p><ol><li>HTTP头部每一行都以<code>\r\n</code>结尾，而不是<code>\n</code></li><li>需要包含<code>Connection: close</code></li><li>借助<code>eof</code>函数接收服务器的发送数据</li></ol><p>其余部分按照上面的<code>telnet</code>命令仿写即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_URL</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> &#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <br>    Address <span class="hljs-title function_">addr</span><span class="hljs-params">(host, <span class="hljs-string">&quot;http&quot;</span>)</span>;<br>    TCPSocket http_socket;<br>    <br>    http_socket.connect(addr);<br>    http_socket.write(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>    http_socket.write(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>    http_socket.write(<span class="hljs-string">&quot;Connection: close\r\n&quot;</span>);<br>    http_socket.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><br>    <span class="hljs-keyword">while</span>(!http_socket.eof())&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;http_socket.read();<br>    &#125;<br><br>    http_socket.close();<br>    <span class="hljs-comment">// You will need to connect to the &quot;http&quot; service on</span><br>    <span class="hljs-comment">// the computer whose name is in the &quot;host&quot; string,</span><br>    <span class="hljs-comment">// then request the URL path given in the &quot;path&quot; string.</span><br><br>    <span class="hljs-comment">// Then you&#x27;ll need to print out everything the server sends back,</span><br>    <span class="hljs-comment">// (not just one call to read() -- everything) until you reach</span><br>    <span class="hljs-comment">// the &quot;eof&quot; (end of file).</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现ByteStream"><a href="#实现ByteStream" class="headerlink" title="实现ByteStream"></a>实现ByteStream</h2><p>要求实现一个在内存中的有序可靠字节流。</p><p>注意：</p><ul><li>字节流可以从写入端写入，并以相同的顺序，从读取端读取</li><li>字节流是有限的，写入者可以终止写入</li><li>缓冲区是有大小限制的，缓冲区满的时候，写入者不允许再写入</li><li>ByteStream流的字节可能比缓冲区要大的多</li><li>单线程环境，不考虑竞态条件</li></ul><p>我们考虑用<code>deque</code>数据结构来实现这个字节流。<br>需要为ByteStream添加数据成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// byte_stream.hh文件</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-type">char</span>&gt; dq_;<br><span class="hljs-type">size_t</span> capacity_;<br><span class="hljs-type">size_t</span> read_size_;     <span class="hljs-comment">//总共读取的字节数</span><br><span class="hljs-type">size_t</span> write_size_;    <span class="hljs-comment">//总共写入的字节数</span><br><span class="hljs-type">bool</span> end_input_;       <span class="hljs-comment">//能否再写</span><br></code></pre></td></tr></table></figure><p>具体函数也不难实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// byte_stream.cc文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a flow-controlled in-memory byte stream.</span><br><br><span class="hljs-comment">// For Lab 0, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab0`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `byte_stream.hh`</span><br><br>template &lt;typename... Targs&gt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> &#123;&#125;<br><br>using namespace <span class="hljs-built_in">std</span>;<br><br>ByteStream::ByteStream(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity):dq_(), capacity_(capacity), read_size_(<span class="hljs-number">0</span>), write_size_(<span class="hljs-number">0</span>),end_input_(<span class="hljs-number">0</span>) &#123; <br>    <br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;data)</span> &#123;<br>    <span class="hljs-keyword">if</span>(end_input_)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 把 data 写进 dq_中</span><br>    <span class="hljs-type">size_t</span> write_sz = <span class="hljs-built_in">std</span>::min(data.size(), capacity_ - dq_.size());<br>    write_size_ += write_sz;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; write_sz; i++)&#123;<br>        dq_.push_back(data[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> write_sz;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-built_in">string</span> <span class="hljs-title function_">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">// dq_中的内容不会被清除</span><br>    <span class="hljs-type">size_t</span> pop_size = min(len, dq_.size());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(dq_.begin(), dq_.begin() + pop_size);<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> &#123; <br>    <span class="hljs-comment">//dq_中的内容会被清除</span><br>    <span class="hljs-type">size_t</span> pop_size = min(len, dq_.size());<br>    read_size_ += pop_size;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pop_size; i++)&#123;<br>        dq_.pop_front();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">ByteStream::read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ret = peek_output(len);<br>    pop_output(len);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ByteStream::end_input</span><span class="hljs-params">()</span> &#123;<br>    end_input_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> end_input_;    <br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> dq_.size();<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> dq_.size() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> dq_.size() == <span class="hljs-number">0</span> &amp;&amp; input_ended();    <br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> write_size_;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> read_size_;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> capacity_ - dq_.size();    <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tinyhttpd</title>
    <link href="/2023/09/08/%E9%A1%B9%E7%9B%AE/Tinyhttpd/Tinyhttpd/"/>
    <url>/2023/09/08/%E9%A1%B9%E7%9B%AE/Tinyhttpd/Tinyhttpd/</url>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这是一个简单的轻量HTTP服务器，能够让我们理解服务器工作的流程与本质。<br><a href="https://github.com/BlackGhostLzc/Tinyhttpd.git">我的GitHub地址</a>。<br>对代码我做了一点更改，例如再服务器进程中打印一些报文的内容以及做了比较详细的注释，还有更改了<code>simpleclient.c</code>文件使得这个程序也可以与<code>http</code>进行非<code>GET</code>非<code>POST</code>的通信。</p><h2 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h2><p>编译好项目后，首先运行<code>http</code>程序，<code>http.c</code>文件中位服务器指定了一个端口，然后可以打开浏览器，输入<code>localhost:端口号</code>或者<code>127.0.0.1:端口号</code>就可以连接到服务器。<br>在输入框中输入一个颜色，点击提交，得到下面的效果图。<br><img src="https://pic4.zhimg.com/80/v2-c0f3f89359dc034bf5597b83caa42243_1440w.webp" alt="img" style="zoom:50%;" /></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>当我们在浏览器（客户端）输入一个网址，浏览器就会向服务器发出一个HTTP报文。<br>这里并不讲HTTP报文的格式，只介绍<code>Tinyhttpd</code>用到的的请求方法：</p><ol><li><code>GET</code>: 请求指定的页面信息，并返回实体主体。</li><li><code>POST</code>:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code> 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li></ol><h3 id="CGI脚本"><a href="#CGI脚本" class="headerlink" title="CGI脚本"></a>CGI脚本</h3><p>CGI不是一门编程语言。它是网页的表单和你写的程序之间通信的一种协议。<br>典型的CGI脚本做了如下的事情：</p><ol><li>读取用户提交表单的信息。</li><li>处理这些信息（也就是实现业务）。</li><li>输出，返回html响应（返回处理完的数据）<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#!/usr/bin/perl -Tw</span><br><br><span class="hljs-keyword">use</span> strict;<br><span class="hljs-keyword">use</span> CGI;<br><br><span class="hljs-keyword">my</span>($cgi) = new CGI;<br><br><span class="hljs-keyword">print</span> $cgi-&gt;header;<br><span class="hljs-keyword">my</span>($color) = <span class="hljs-string">&quot;blue&quot;</span>;<br>$color = $cgi-&gt;param(<span class="hljs-string">&#x27;color&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-keyword">defined</span> $cgi-&gt;param(<span class="hljs-string">&#x27;color&#x27;</span>);<br><br><span class="hljs-keyword">print</span> $cgi-&gt;start_html(<span class="hljs-string">-title =&gt;</span> <span class="hljs-keyword">uc</span>($color),<br>                       <span class="hljs-string">-BGCOLOR =&gt;</span> $color);<br><span class="hljs-keyword">print</span> $cgi-&gt;h1(<span class="hljs-string">&quot;This is $color&quot;</span>);<br><span class="hljs-keyword">print</span> $cgi-&gt;end_html;<br></code></pre></td></tr></table></figure>上面这个CGI脚本就生成了一个html格式的文件，服务器进程创建的子进程会运行这个脚本，通过管道，服务器进程向子进程传入执行这个脚本需要的一些参数，也就是客户端提交的表单，而子进程也通过管道把脚本执行内容传给服务器进程，再由服务器发送给客户端，这样实现了动态解析。</li></ol><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p><code>Tinyhttpd</code>有下面这几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">accept_request</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//处理从套接字上监听到的一个 HTTP 请求</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bad_request</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//返回给客户端这是个错误请求，400响应码</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cat</span><span class="hljs-params">(<span class="hljs-type">int</span>, FILE *)</span>;<span class="hljs-comment">//读取服务器上某个文件写到 socket 套接字</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cannot_execute</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//处理发生在执行 cgi 程序时出现的错误</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_die</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//把错误信息写到 perror </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">execute_cgi</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//运行cgi脚本，这个非常重要，涉及动态解析</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_line</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//读取一行HTTP报文</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">headers</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//返回HTTP响应头</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">not_found</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//返回找不到请求文件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serve_file</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//调用 cat 把服务器文件内容返回给浏览器。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">startup</span><span class="hljs-params">(u_short *)</span>;<span class="hljs-comment">//开启http服务，包括绑定端口，监听，开启线程处理链接</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unimplemented</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</span><br></code></pre></td></tr></table></figure><h3 id="accept-request函数"><a href="#accept-request函数" class="headerlink" title="accept_request函数"></a>accept_request函数</h3><p>相关代码逻辑在注释中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">accept_request</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int</span> client = (<span class="hljs-type">intptr_t</span>)arg;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">size_t</span> numchars;<br>    <span class="hljs-type">char</span> method[<span class="hljs-number">255</span>];<br>    <span class="hljs-type">char</span> url[<span class="hljs-number">255</span>];<br>    <span class="hljs-type">char</span> path[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">size_t</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-type">int</span> cgi = <span class="hljs-number">0</span>;      <span class="hljs-comment">/* becomes true if server decides this is a CGI</span><br><span class="hljs-comment">                       * program */</span><br>    <span class="hljs-type">char</span> *query_string = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 获取请求报文的第一行</span><br>    numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    i = <span class="hljs-number">0</span>; j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First line: %s&quot;</span>, buf);<br><br>    <span class="hljs-comment">// 获取请求报文的方法，是GET还是POST方法</span><br>    <span class="hljs-keyword">while</span> (!ISspace(buf[i]) &amp;&amp; (i &lt; <span class="hljs-keyword">sizeof</span>(method) - <span class="hljs-number">1</span>))<br>    &#123;<br>        method[i] = buf[i];<br>        i++;<br>    &#125;<br>    j=i;<br>    method[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果不是这两种方法，那就只能是simpleclient程序</span><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>))<br>    &#123;<br>        buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-comment">// 向simpleclient发送一个字符</span><br>        write(client, buf, <span class="hljs-number">1</span>);<br>        unimplemented(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是POST方法，那么需要执行cgi脚本</span><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>) == <span class="hljs-number">0</span>)<br>        cgi = <span class="hljs-number">1</span>;<br><br><br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; numchars))<br>        j++;<br>    <br>    <span class="hljs-comment">// 获取url</span><br>    <span class="hljs-keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="hljs-keyword">sizeof</span>(url) - <span class="hljs-number">1</span>) &amp;&amp; (j &lt; numchars))<br>    &#123;<br>        url[i] = buf[j];<br>        i++; j++;<br>    &#125;<br>    url[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果是GET方法，这里的url是  / </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;url: %s\n&quot;</span>, url);<br><br><span class="hljs-comment">// url还需要进行拼接操作，把htdocs目录下的index.html发送给客户端</span><br><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 如果有查询参数</span><br>        query_string = url;<br>        <span class="hljs-keyword">while</span> ((*query_string != <span class="hljs-string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="hljs-string">&#x27;\0&#x27;</span>))<br>            query_string++;<br>        <span class="hljs-keyword">if</span> (*query_string == <span class="hljs-string">&#x27;?&#x27;</span>)<br>        &#123;<br>            cgi = <span class="hljs-number">1</span>;<br>            *query_string = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            query_string++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">sprintf</span>(path, <span class="hljs-string">&quot;htdocs%s&quot;</span>, url);<br>    <span class="hljs-comment">// 如果是GET方法：  path:htdocs/</span><br>    <span class="hljs-comment">// 如果是POST方法： path:htdocs/color.cgi</span><br><br><br>    <span class="hljs-keyword">if</span> (path[<span class="hljs-built_in">strlen</span>(path) - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-built_in">strcat</span>(path, <span class="hljs-string">&quot;index.html&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;path: %s\n&quot;</span>, path);<br>    <span class="hljs-comment">// 如果是GET方法：    path: htdocs/index.html</span><br>    <span class="hljs-comment">// 如果是POST方法：   path: htdocs/color.cgi</span><br><br>    <span class="hljs-comment">// 把path文件与st关联起来</span><br>    <span class="hljs-keyword">if</span> (stat(path, &amp;st) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">while</span> ((numchars &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;\n&quot;</span>, buf))  <span class="hljs-comment">/* read &amp; discard headers */</span><br>            numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        not_found(client);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 如果路径是个目录，那就将主页进行显示</span><br>        <span class="hljs-keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)<br>            <span class="hljs-built_in">strcat</span>(path, <span class="hljs-string">&quot;/index.html&quot;</span>);<br>        <span class="hljs-keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||<br>                (st.st_mode &amp; S_IXGRP) ||<br>                (st.st_mode &amp; S_IXOTH)    )<br>            cgi = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!cgi)<br>            <span class="hljs-comment">// 为客户端发送静态网页</span><br>            serve_file(client, path);<br>        <span class="hljs-keyword">else</span><br>            execute_cgi(client, path, method, query_string);<br>    &#125;<br><br>    close(client);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="execute-cgi函数"><a href="#execute-cgi函数" class="headerlink" title="execute_cgi函数"></a>execute_cgi函数</h3><p>这个函数是进行动态解析的核心函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">execute_cgi</span><span class="hljs-params">(<span class="hljs-type">int</span> client, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,</span><br><span class="hljs-params">        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *method, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *query_string)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get into execute_cgi\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> cgi_output[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> cgi_input[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> numchars = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> content_length = <span class="hljs-number">-1</span>;<br><br>    buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>; buf[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果是GET请求，就不断的读取并丢弃头信息</span><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> ((numchars &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;\n&quot;</span>, buf))  <span class="hljs-comment">/* read &amp; discard headers */</span><br>            numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">/*POST*/</span><br>    &#123;<br>        <span class="hljs-comment">// POST请求</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a POST method\n&quot;</span>); <br>        numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">        ....</span><br><span class="hljs-comment">        Content-Length: 9</span><br><span class="hljs-comment">        ....</span><br><span class="hljs-comment">        空一行 \n</span><br><span class="hljs-comment">        内容(color=red)</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-keyword">while</span> ((numchars &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;\n&quot;</span>, buf))<br>        &#123;<br>            buf[<span class="hljs-number">15</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-comment">// 得到消息体的长度是多少</span><br>            <span class="hljs-keyword">if</span> (strcasecmp(buf, <span class="hljs-string">&quot;Content-Length:&quot;</span>) == <span class="hljs-number">0</span>)<br>                content_length = atoi(&amp;(buf[<span class="hljs-number">16</span>]));<br>            numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (content_length == <span class="hljs-number">-1</span>) &#123;<br>            bad_request(client);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">/*HEAD or other*/</span><br>    &#123;<br>    &#125;<br><br><span class="hljs-comment">// 初始化管道</span><br>    <span class="hljs-keyword">if</span> (pipe(cgi_output) &lt; <span class="hljs-number">0</span>) &#123;<br>        cannot_execute(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pipe(cgi_input) &lt; <span class="hljs-number">0</span>) &#123;<br>        cannot_execute(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( (pid = fork()) &lt; <span class="hljs-number">0</span> ) &#123;<br>        cannot_execute(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);<br>    send(client, buf, <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* child: CGI script */</span><br>    &#123;<br>        <span class="hljs-comment">// 子进程来执行 cgi 脚本</span><br>        <span class="hljs-type">char</span> meth_env[<span class="hljs-number">255</span>];<br>        <span class="hljs-type">char</span> query_env[<span class="hljs-number">255</span>];<br>        <span class="hljs-type">char</span> length_env[<span class="hljs-number">255</span>];<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程执行%s程序\n&quot;</span>, path);<br><br><span class="hljs-comment">// 操作文件描述符，使得执行cgi脚本的时候，print打印直接交给管道的写端</span><br>        dup2(cgi_output[<span class="hljs-number">1</span>], STDOUT);<br>        dup2(cgi_input[<span class="hljs-number">0</span>], STDIN);<br>        close(cgi_output[<span class="hljs-number">0</span>]);<br>        close(cgi_input[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-built_in">sprintf</span>(meth_env, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, method);<br>        putenv(meth_env);<br>        <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(query_env, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, query_string);<br>            putenv(query_env);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">/* POST */</span><br>            <span class="hljs-built_in">sprintf</span>(length_env, <span class="hljs-string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);<br>            putenv(length_env);<br>        &#125;<br><br>        <span class="hljs-comment">// 执行 cgi 脚本，cgi脚本中的 print 都会通过管道重定向给父进程</span><br>        execl(path, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">/* parent */</span><br>        close(cgi_output[<span class="hljs-number">1</span>]);<br>        close(cgi_input[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程接受到的消息内容是:\n&quot;</span>);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; content_length; i++) &#123;<br>                recv(client, &amp;c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 父进程把收到的消息内容传递给子进程，也就是 “color=red” 这条信息，由cgi生成新的html文件</span><br>                <span class="hljs-comment">// 再由父进程（服务器）转交给客户端</span><br>                write(cgi_input[<span class="hljs-number">1</span>], &amp;c, <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,c);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程通过管道接收到的：\n&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (read(cgi_output[<span class="hljs-number">0</span>], &amp;c, <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>)&#123;<br>            send(client, &amp;c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        我把父进程接收到子进程的字符写进了new.html文件中，可以发现这就是一个网页</span><br><span class="hljs-comment">        */</span><br>        close(cgi_output[<span class="hljs-number">0</span>]);<br>        close(cgi_input[<span class="hljs-number">1</span>]);<br>        waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，把服务器进程通过管道收到的CGI脚本输出内容再发送给客户端，html文件如下所示，这也正是点击提交后再浏览器上展示的网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span></span><br><span class="hljs-meta">    <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en-US&quot;</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>RED<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=iso-8859-1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is red<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这个项目，清楚了HTTP是如何响应和处理客户端请求的，明白了HTTP服务器的工作机制，也对CGI脚本有了一点了解。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始socket</title>
    <link href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%9D%E8%AF%86socket/"/>
    <url>/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%9D%E8%AF%86socket/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1.什么是socket"></a>1.什么是socket</h2><p>socket 的原意是“插座”，是一种操作系统提供的进程间通信机制。</p><p>在UNIX&#x2F;Linux系统中，一切皆文件，网络连接也是一个文件，它也有文件描述符。<br>我们可以通过 <code>socket()</code> 函数来创建一个网络连接，或者说打开一个网络文件，<code>socket()</code> 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：</p><ul><li>用 <code>read()</code> 读取从远程计算机传来的数据；</li><li>用 <code>write()</code> 向远程计算机写入数据。</li></ul><p>还有一个比较重要的就是网络字节序。<br>网络字节序一般都是大端表示的，而主机字节序一般是小端表示的，所以需要包含一段这两者之间的转换函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<br><span class="hljs-comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;<br><br><span class="hljs-comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span><br><span class="hljs-comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;<br></code></pre></td></tr></table></figure><p>而对于IP地址，我们一般见到的表示形式都是点分十进制，把这种点分十进制转换为网络字节序需要函数<code>inet_pton()</code>,<code>inet_ntop</code>将大端的整形数, 转换为小端的点分十进制的IP地址。</p><h2 id="2-TCP通信流程"><a href="#2-TCP通信流程" class="headerlink" title="2.TCP通信流程"></a>2.TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p><h3 id="2-1服务器端通信流程"><a href="#2-1服务器端通信流程" class="headerlink" title="2.1服务器端通信流程"></a>2.1服务器端通信流程</h3><p>一般而言，服务器需要一个监听套接字和多个通信套接字，监听套接字负责与客户端建立连接，通信套接字则是与客户端进行数据传送。</p><ol><li>调用<code>socket()</code>函数创建用于监听的套接字，得到一个文件描述符。</li><li>将得到的监听文件描述符和本地的IP端口进行绑定，<code>bind()</code>函数。</li><li><code>listen()</code>函数设置监听。</li><li><code>accept()</code>函数等待客户端的连接请求，会返回一个用于与客户端通信的文件描述符，如果没有请求就会堵塞。</li><li><code>read()</code>或<code>recv()</code>接受数据，<code>write()</code>或<code>send()</code>发送数据。</li><li><code>close()</code>断开连接，关闭套接字。</li></ol><ul><li>注意：服务端需要绑定一个特定的端口，不能随意分配。这是因为客户端在请求与服务器端进行连接的时候，需要指定IP地址以及端口，所以服务器的端口对于客户端来说是已知的。<br>例如，当我们输入网址<code>https://www.bilibili.com</code>，其实https的默认端口就是443，所以相当于我们省略了端口，输入<code>https://www.bilibili.com:443</code>也是一样的。再讲一句题外话，我们按下F12，点击网络，也会得到远程服务器的IP地址和端口，发现端口也是443，前提是你要关闭vpn代理。</li></ul><h3 id="2-2-客户端的通信流程"><a href="#2-2-客户端的通信流程" class="headerlink" title="2.2 客户端的通信流程"></a>2.2 客户端的通信流程</h3><p>一般来说客户端通信的文件描述符只有一个，不需要坚挺的文件描述符。</p><ol><li><code>socket()</code>函数创建一个套接字，返回文件描述符。</li><li><code>connect()</code>函数连接服务器，需要知道服务器绑定的IP和端口。</li><li><code>read()</code>或<code>recv()</code>函数接受数据，<code>write()</code>或<code>send()</code>发送数据。</li><li><code>close()</code>断开连接。</li></ol><h2 id="3-基本API"><a href="#3-基本API" class="headerlink" title="3.基本API"></a>3.基本API</h2><ul><li><code>int socket(int domain, int type, int protocol)</code>：<br>参数：<br><code>domain</code>地址族，常见的有AF_INET（IPv4）和AF_INET6（IPv6）。<br><code>type</code> 套接字类型,常见的有SOCK_STREAM（用于TCP协议）和SOCK_DGRAM（用于UDP协议）。<br><code>protocal</code>协议，通常置为0，根据前两个参数自动选择合适的协议。</li></ul><p>返回值是一个文件描述符。</p><ul><li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>参数：<br><code>sockfd</code>需要绑定的套接字文件描述符。<br><code>addr</code>:存放了服务端用于通信的地址和端口。<br><code>addrlen</code>:结构体addr的大小。</li></ul><p><code>sockaddr_in</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin_family;<span class="hljs-comment">/* 地址族协议: AF_INET */</span><br>    <span class="hljs-type">in_port_t</span> sin_port;         <span class="hljs-comment">/* 端口, 2字节-&gt; 大端  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>    <span class="hljs-comment">/* IP地址, 4字节 -&gt; 大端  */</span><br>    <span class="hljs-comment">/* 填充 8字节 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sin_zero[<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> sockaddr) - <span class="hljs-keyword">sizeof</span>(sin_family) -<br>               <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">in_port_t</span>) - <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> in_addr)];<br>&#125;;  <br></code></pre></td></tr></table></figure><ul><li><p><code>int listen(int sockfd, int backlog)</code><br>参数：<br><code>sockfd</code>: 文件描述符, 可以通过调用<code>socket()</code>得到，在监听之前必须要绑定 <code>bind()</code><br><code>backlog</code>: 同时能处理的最大连接要求，最大值为128</p></li><li><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>参数：<br><code>sockfd</code>: 监听的文件描述符<br><code>addr</code>: <strong>传出参数</strong>, 里边存储了建立连接的客户端的地址信息,如客户端的端口和IP。<br><code>addrlen</code>: 传入传出参数，用于存储addr指向的内存大小</p></li></ul><p>这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</p><ul><li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>参数：<br><code>sockfd</code>: 通信的文件描述符, 通过调用socket()函数就得到了<br><code>addr</code>: 存储了要连接的服务器端的地址信息: IP 和 端口，这个IP和端口也需要转换为大端然后再赋值<br><code>addrlen</code>: <code>addr</code>指针指向的内存的大小 <code>sizeof(struct sockaddr)</code></li></ul><p>至于发送接受数据的函数，这个是内核来维护的，内核决定多久发送出去就多久发送出去，多久从缓冲区获取数据就多久获取。同时，如果缓冲区满了，<code>write</code>或<code>send</code>函数就会被阻塞。</p><h2 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4.示例代码"></a>4.示例代码</h2><p>在我们的示例代码中，服务器端我们要使用多线程，每当一个客户端发过来一个请求时，服务器端都需要创建一个线程去处理这个请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sys_err</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>&#123;<br>    perror(str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERV_PORT 9527</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 256</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">client_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *socket_desc)</span> &#123;<br>    <span class="hljs-type">int</span> client_socket = *(<span class="hljs-type">int</span> *)socket_desc;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        ret = read(client_socket, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        write(STDOUT_FILENO, buf, ret);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)&#123;<br>            buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>        &#125;<br><br>        write(client_socket, buf, ret);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-number">0</span>, cfd = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> buf[BUFSIZE];<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>, <span class="hljs-title">clit_addr</span>;</span><br>    <span class="hljs-type">pthread_t</span> thread_id;<br><br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_port = htons(SERV_PORT);<br>    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br><br><br>    lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>)&#123;<br>        sys_err(<span class="hljs-string">&quot;socket error&quot;</span>);<br>    &#125;<br><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr));<br><br>    listen(lfd, <span class="hljs-number">128</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">socklen_t</span> clit_addr_len = <span class="hljs-keyword">sizeof</span>(clit_addr);<br>        cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clit_addr, &amp;clit_addr_len);<br><br>        <span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;Accept failed&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Client connected\n&quot;</span>);<br><br>        <span class="hljs-type">int</span> *new_sock = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>        *new_sock = cfd;<br><br>        <span class="hljs-keyword">if</span> (pthread_create(&amp;thread_id, <span class="hljs-literal">NULL</span>, client_handler, (<span class="hljs-type">void</span> *)new_sock) &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;Could not create thread&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    close(lfd);<br>    close(cfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</code><br>这行代码的意思是可以绑定本地的任何一个IP地址，服务器端自动地读网卡的实际IP，并与这个实际IP进行绑定。<br>现在我们还没有客户端的代码，但我们仍然可以对服务器代码进行测试。<br>首先编译并运行服务器端代码，然后另外开几个终端，输入<code>nc 127.0.0.1 9527</code>命令。</p><blockquote><p>Linux中的nc命令是一个功能强大的网络工具，也被称为netcat，可以实现TCP&#x2F;UDP端口的侦听，127.0.0.1代表本地主机，9527端口是服务器监听套接字绑定了的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU_15445：Buffer Pool Manager</title>
    <link href="/2023/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Project1/"/>
    <url>/2023/08/16/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Project1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断和设备驱动程序</title>
    <link href="/2023/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/5.%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/5.%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p>中断对应的场景很简单，就是硬件想要得到操作系统的关注。<br>操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。这里的保存和恢复工作，与我们之前看到的系统调用过程非常相似。所以系统调用，page fault，中断，都使用相同的机制。</p><ul><li><strong>中断与系统调用的区别</strong></li></ul><ol><li>asynchronous（异步性）：当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。而系统调用会发生在运行进程的context下。</li><li>concurrency（并发）：CPU和设备之间是真正的并行的。</li><li>program device：设备需要被编程。</li></ol><ul><li><strong>PLIC</strong></li></ul><p>所有的设备都连接到处理器上，处理器上是通过Platform Level Interrupt Control，简称PLIC来处理设备中断。PLIC会路由这些中断,PLIC会将中断路由到某一个CPU的核。如果所有的CPU核都正在处理中断，PLIC会保留中断直到有一个CPU核可以用来处理中断。</p><h2 id="什么是设备驱动"><a href="#什么是设备驱动" class="headerlink" title="什么是设备驱动"></a>什么是设备驱动</h2><p>通常来说，管理设备的代码称为驱动，所有的驱动都在内核中。我们今天要看的是UART设备的驱动，代码在uart.c文件中。</p><blockquote><p>大部分驱动都分为两个部分，bottom 和 top。</p></blockquote><ul><li><p>bottom部分<br>通常是Interrupt handler。中断处理程序并不运行在任何特定进程的上下文  中，它只是处理中断。</p></li><li><p>top部分<br>是用户进程，或者内核的其他部分调用的接口。例如 <code>read</code> 和 <code>write</code></p></li></ul><p>通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和CPU解耦开来。</p><ul><li>memory mapped I&#x2F;O<br>I&#x2F;O设备的寄存器被映射到系统内存地址空间的一段地址范围内，程序可以通过读写内存地址的方式来进行对I&#x2F;O设备的控制和访问。</li></ul><h2 id="在xv6中设置中断"><a href="#在xv6中设置中断" class="headerlink" title="在xv6中设置中断"></a>在xv6中设置中断</h2><h3 id="Console-input"><a href="#Console-input" class="headerlink" title="Console input"></a>Console input</h3><p>当用户输入一个字符后，UART硬件将产生一个中断，这个中断将触发xv6进入trap，随后调用<code>devintr</code>来通过<code>scause</code>寄存器判断是外部设备触发了这个中断，然后硬件将调用PLIC判断是哪个外部设备触发了这个外部中断，如果是UART触发的,<code>devintr</code>将调用<code>uartintr</code>。<code>uartintr</code>将读取从UART硬件中写入的字符然后将其传送给<code>consoleintr</code>，<code>consoleintr</code>将积累这些字符直到整行都已经被读取，然后将唤醒仍在sleep的<code>consoleread</code>。当<code>consoleread</code>被唤醒后，将这一行命令复制给user space然后返回。</p><h3 id="Console-output"><a href="#Console-output" class="headerlink" title="Console output"></a>Console output</h3><p>对console上的文件描述符进行<code>write</code> system call，最终到达kernel&#x2F;uart.c的<code>uartputc</code>函数。输出的字节将缓存在<code>uart_tx_buf</code>中，这样写入进程就不需要等待UART硬件完成字节的发送，只要当这个缓存区满了的情况下<code>uartputc</code>才会等待。当UART完成了一个字符的发送之后，将产生一个中断，<code>uartintr</code>将调用<code>uartstart</code>来判断设备是否确实已经完成发送，然后将下一个需要发送的字符发送给UART。因此让UART传送多个字符时，第一个字符由<code>uartputc</code>对<code>uartstart</code>的调用传送，后面的字符由<code>uartintr</code>对<code>uartstart</code>的调用进行传送。</p><h3 id="UART驱动的top部分"><a href="#UART驱动的top部分" class="headerlink" title="UART驱动的top部分"></a>UART驱动的top部分</h3><p>当XV6启动时，Shell会输出提示符“$ ”，如果我们在键盘上输入ls，最终可以看到“$ ls”。我们接下来通过研究Console是如何显示出“$ ls”，来看一下设备中断是如何工作的。</p><p>首先，系统启动后运行第一个进程init,这个进程会创建一个Console设备。然后再进行两次dup后，文件描述符0,1,2都指向了这个Console设备。随后这个进程会fork，然后子进程进入shell。</p><p>在shell的<code>getcmd</code>函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;$ &quot;</span>);<br></code></pre></td></tr></table></figure><p>执行write系统调用，<code>sys_write</code>函数又会调用file.c中的<code>filewrite</code>函数。<br>这个<code>filewrite</code>函数判断文件的类型，(这里还会用到<code>argfd</code>函数，用一个<code>struct file*</code>的类型获取fd的文件描述符指向的文件)。<br><code>filewrite</code>函数发现这个文件类型是属于一个设备后，就会为这个特定的设备执行相应的<code>write</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>,addr,n);<br></code></pre></td></tr></table></figure><p>因为设备是Console，所以会调用console.c中的<code>consolewrite</code>函数。</p><blockquote><p>consolewrite是UART驱动的top部分</p></blockquote><p><code>consolewrite</code>会调用<code>uartputc</code>函数，首先把数据存在一个缓冲区里<code>uart_tx_buf</code>中。</p><p>再然后会调用<code>uartstart</code>函数，通知UART设备执行操作。取出数据放入THR发送寄存器。<br>一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。与此同时，UART设备会将数据送出。</p><blockquote><p>UART连接了两个设备，一个是键盘，另一个是显示设备，也就是Console。</p></blockquote><p>然后呢。。。会发生中断。</p><h3 id="UART驱动的bottom部分"><a href="#UART驱动的bottom部分" class="headerlink" title="UART驱动的bottom部分"></a>UART驱动的bottom部分</h3><p>trap.c的<code>devintr</code>函数中，首先会通过<code>SCAUSE</code>寄存器判断当前中断是否是来自于外设的中断。如果是的话，再调用plic_claim函数来获取中断。如果是UART中断，那么会调用<code>uartintr</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uartintr(<span class="hljs-type">void</span>)&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> c = uartgetc();<br><span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>consoleintr();<br>&#125;<br>acquire(&amp;uart_tx_lock);<br>uartstart();<br>release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们没有在键盘上敲下任何一个键(这里纯粹说一下”$”是如何被处理的)，所以会直接执行uartsatrt函数。</p><ul><li>小疑问：为什么interrupt和write都会调用了uartstart函数？<blockquote><p>首先，如果是write多个字节的话，第一次通过uartputc调用uartstart，把第一个字节发送出去。第一个字节发送完成后，会产生中断，紧接着把余下的字节都发送出去。<br>A general pattern to note is the decoupling of device activity from process activity via buffering and interrupts.</p></blockquote></li></ul><blockquote><p>Interrupt handler，也就是uartintr函数，在这个场景下是consumer，每当有一个中断，并且读指针落后于写指针，uartintr函数就会从读指针中读取一个字符再通过UART设备发送，并且将读指针加1。当读指针追上写指针，也就是两个指针相等的时候，buffer为空，这时就不用做任何操作。</p></blockquote><h3 id="UART读取键盘输入"><a href="#UART读取键盘输入" class="headerlink" title="UART读取键盘输入"></a>UART读取键盘输入</h3><p>类似的，shell会调用<code>read</code>从键盘读取字符。再会调用<code>fileread</code>函数，如果文件类型是设备，在这里是<code>console</code>设备，所以会调用<code>consoleread</code>函数。这里也有一个Buffer。<br>大体流程如下：<br>假设用户通过键盘输入了“l”，这会导致“l”被发送到主板上的UART芯片，产生中断之后再被PLIC路由到某个CPU核，之后会触发<code>devintr</code>函数，<code>devintr</code>可以发现这是一个UART中断，然后通过<code>uartgetc</code>函数获取到相应的字符，之后再将字符传递给<code>consoleintr</code>函数。<br>默认情况下，字符会通过<code>consputc</code>，输出到console上给用户查看。之后，字符被存放在buffer中。在遇到换行符的时候，唤醒之前sleep的进程，也就是Shell，再从buffer中将数据读出。<br>所以这里也是通过buffer将consumer和producer之间解耦，这样它们才能按照自己的速度，独立的并行运行。如果某一个运行的过快了，那么buffer要么是满的要么是空的，consumer和producer其中一个会sleep并等待另一个追上来。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的实现</title>
    <link href="/2023/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/6.%E9%94%81/"/>
    <url>/2023/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/6.%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="自旋锁（Spin-lock）的实现"><a href="#自旋锁（Spin-lock）的实现" class="headerlink" title="自旋锁（Spin lock）的实现"></a>自旋锁（Spin lock）的实现</h2><ul><li>什么是自旋锁<br>自旋锁是一种忙等待的锁机制。锁的特性就是只有一个进程可以获取锁，在任何时间点都不能有超过一个锁的持有者。<br>在<code>acquire</code>里面有一个死循环，循环中判断锁对象的locked字段是否为0，如果为0那表明当前锁没有持有者，当前对于<code>acquire</code>的调用可以获取锁。之后我们通过设置锁对象的<code>locked</code>字段为1来获取锁。最后返回。</li></ul><blockquote><p>但两个进程可能同时读到 locked 字段为 0.</p></blockquote><p>这就需要原子指令 <code>test-and-set</code>，在RISC-V上，这个特殊的指令就是<code>amoswap</code>（atomic memory swap）。这个指令接收3个参数，分别是address，寄存器r1，寄存器r2。这条指令会先锁定住address，将address中的数据保存在一个临时变量中（tmp），之后将r1中的数据写入到地址中，之后再将保存在临时变量中的数据写入到r2中，最后再对于地址解锁。</p><ul><li>代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mutual exclusion lock.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>  uint locked;       <span class="hljs-comment">// Is the lock held?</span><br><br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>;</span>   <span class="hljs-comment">// The cpu holding the lock.</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  push_off(); <span class="hljs-comment">// disable interrupts to avoid deadlock.</span><br>  <span class="hljs-keyword">if</span>(holding(lk))<br>    panic(<span class="hljs-string">&quot;acquire&quot;</span>);<br><br>  <span class="hljs-comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span><br>  <span class="hljs-comment">//   a5 = 1</span><br>  <span class="hljs-comment">//   s1 = &amp;lk-&gt;locked</span><br>  <span class="hljs-comment">//   amoswap.w.aq a5, a5, (s1)</span><br>  <span class="hljs-keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    ;<br><br>  <span class="hljs-comment">// Tell the C compiler and the processor to not move loads or stores</span><br>  <span class="hljs-comment">// past this point, to ensure that the critical section&#x27;s memory</span><br>  <span class="hljs-comment">// references happen strictly after the lock is acquired.</span><br>  <span class="hljs-comment">// On RISC-V, this emits a fence instruction.</span><br>  __sync_synchronize();<br><br>  <span class="hljs-comment">// Record info about lock acquisition for holding() and debugging.</span><br>  lk-&gt;cpu = mycpu();<br>&#125;<br></code></pre></td></tr></table></figure>由于关闭了中断，所以这一个进程还是在同一个CPU核上运行的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">holding</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-type">int</span> r;<br>  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>__sync_synchronize() 函数的作用是创建一个内存屏障（memory barrier）或者称为内存栅栏（memory fence）。内存屏障是一种同步机制，用于确保在屏障之前的所有内存访问操作都在屏障之前完成，并且在屏障之后的所有内存访问操作都在屏障之后执行。<br>告诉编译器和处理器在该点之前和之后的内存操作不能被重排序或优化。这样可以确保在自旋锁的临界区代码执行之前，所有对临界区相关的内存访问都已经完成，而在临界区代码执行之后，所有对临界区相关的内存访问都已经生效。</p></blockquote></li></ul><h2 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h2><p>xv6中还有一种锁比较有趣，叫做睡眠锁。<br>首先我们得知道自旋锁的缺点有什么。</p><blockquote><p>持有锁的进程不会主动出让CPU,其他进程要获取锁，长时间的自旋也会引起长时间的浪费。</p></blockquote><p>这里有一种矛盾，当持有锁的时候让出CPU给其他线程(<code>sched</code>)是违法的，因为其他线程如果也要<code>acquire</code>获取这把锁,就会导致死锁。同时，这种做法同样也违反了当自旋锁被持有的时候中断必须关闭的要求。<br>所以，我们就要设计一种锁，它在被<code>acquire</code>等待的时候能够让出CPU,以及允许持有这种锁的时候让出和中断的锁。</p><h3 id="错误的设计："><a href="#错误的设计：" class="headerlink" title="错误的设计："></a>错误的设计：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span><br>&#123;<br>    acquire(&amp;s-&gt;lock);<br>    s-&gt;count += <span class="hljs-number">1</span>;<br>    wakeup(s);             <span class="hljs-comment">// change this</span><br>    release(&amp;s-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (s-&gt;count == <span class="hljs-number">0</span>)<br>        sleep(s);          <span class="hljs-comment">// change this</span><br>    acquire(&amp;s-&gt;lock);<br>    s-&gt;count -= <span class="hljs-number">1</span>;<br>    release(&amp;s-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，存在一个问题，就是当一个线程发现<code>count</code>为0时，还没执行<code>sleep</code>函数时，另一个线程执行了V操作，<code>count</code>加了1，<code>wakeup</code>再把所有的<code>chan</code>为<code>s</code>的线程的<code>state</code>从<code>sleeping</code>改为<code>runable</code>。接着P进程接着执行<code>sleep</code>函数，把自己的<code>state</code>改为<code>sleeping</code>。<br>所以这就存在一个问题，P进程可能永远不会被唤醒，除非V进程再次调用了<code>wakeup</code>。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面问题的根源就是P只在<code>s-&gt;count==0</code>时睡眠的不变量被正在运行的V给破坏了。<br>但是又不能在P<code>while</code>循环前面申请锁，这样很明显会造成死锁。<br>正确实现：</p><blockquote><p>修改sleep接口来修复上述方案：调用者必须传递一个条件锁给sleep，使得其可以在睡眠调用的进程并在睡眠通道上等待时释放锁。锁会强制并行的V等待直到P将它自己睡眠，因此wakeup会找到一个正在睡眠的消费者并唤醒它。一旦消费者被唤醒，sleep就需要在返回前再次获取锁。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Long-term locks for processes</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> &#123;</span><br>  uint locked;      / Is the lock held?<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lk</span>;</span> <span class="hljs-comment">// spinlock protecting this sleep lock</span><br>  <br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process holding lock</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，<code>sleeplock</code>有两把锁。</p><p>在这之前，先简单了解一下<code>sleep</code>函数和<code>wakeup</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//DOC: sleeplock1</span><br>  release(lk);<br><br>  <span class="hljs-comment">// Go to sleep.</span><br>  p-&gt;chan = chan;<br>  p-&gt;state = SLEEPING;<br><br>  sched();<br><br>  <span class="hljs-comment">// Tidy up.</span><br>  p-&gt;chan = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Reacquire original lock.</span><br>  release(&amp;p-&gt;lock);<br>  acquire(lk);<br>&#125;<br><br><span class="hljs-comment">// Wake up all processes sleeping on chan.</span><br><span class="hljs-comment">// Must be called without any p-&gt;lock.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-keyword">if</span>(p != myproc())&#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;<br>        p-&gt;state = RUNNABLE;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在xv6的<code>proc</code>结构体中，有一个<code>chan</code>字段用于实现进程的等待通道的。当一个进程需要等待某一个事件时，需要把<code>chan</code>字段设置为相应的通道或条件。</p><p>下面看<code>acquiresleep</code>和<code>releasesleep</code>函数的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acquiresleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span><br>&#123;<br>  acquire(&amp;lk-&gt;lk);<br>  <span class="hljs-keyword">while</span> (lk-&gt;locked) &#123;<br>    sleep(lk, &amp;lk-&gt;lk);<br>  &#125;<br>  lk-&gt;locked = <span class="hljs-number">1</span>;<br>  lk-&gt;pid = myproc()-&gt;pid;<br>  release(&amp;lk-&gt;lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">releasesleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span><br>&#123;<br>  acquire(&amp;lk-&gt;lk);<br>  lk-&gt;locked = <span class="hljs-number">0</span>;<br>  lk-&gt;pid = <span class="hljs-number">0</span>;<br>  wakeup(lk);<br>  release(&amp;lk-&gt;lk);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>acquiresleep</code>函数首先会申请<code>lk-&gt;lk</code>这把锁，这使得在执行<code>while</code>语句的时候不会有其他线程的<code>wakeup</code>操作。<br><code>sleeplock</code>有一个字段<code>locked</code>表示这把锁是否被获取了，如果被获取了，直接<code>sleep</code>睡眠。<code>sleeplock</code>的<code>lk</code>字段就是用来保护共享资源<code>locked</code>的，只有在获取了<code>lk-&gt;lk</code>这把锁后才能对<code>locked</code>字段进行修改。<br>在进入<code>sleep</code>函数的时候，就可以释放<code>lk-&gt;lk</code>这把锁，其他线程可能会尝试调用<code>wakeup</code>,但进入<code>sleep</code>的线程会事先<code>aquire(&amp;myproc-&gt;lock)</code>,<code>wakeup</code>也会尝试获取线程的锁，所以这样不会引起唤醒丢失。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sleep&amp;wakeup</title>
    <link href="/2023/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/8.sleep&amp;wakeup/"/>
    <url>/2023/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/8.sleep&amp;wakeup/</url>
    
    <content type="html"><![CDATA[<h2 id="Sleep-wakeup"><a href="#Sleep-wakeup" class="headerlink" title="Sleep &amp; wakeup"></a>Sleep &amp; wakeup</h2><p><code>sleep</code>是当一个进程在等待某一个事件时陷入休眠状态，当这个事件发生时另外一个进程唤醒它。陷入休眠状态可以让这个进程不在等待的时候占用CPU资源</p><p><code>sleep(chan)</code>让这个进程睡眠在<code>chan</code>这个wait channel上，<code>wakeup(chan)</code>将所有睡眠在<code>chan</code>上的进程全部唤醒。</p><p>lost wake-up problem：当一个进程A即将睡眠时，另外一个进程B发现已经满足了唤醒它的条件进行了唤醒，但是这时还没有进程睡眠在<code>chan</code>上，当进程A开始进入睡眠后，进程B可能不会再对进程A进行唤醒，进程A永远进入睡眠状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//DOC: sleeplock1</span><br>  release(lk);<br><br>  <span class="hljs-comment">// Go to sleep.</span><br>  p-&gt;chan = chan;<br>  p-&gt;state = SLEEPING;<br><br>  sched();<br><br>  <span class="hljs-comment">// Tidy up.</span><br>  p-&gt;chan = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Reacquire original lock.</span><br>  release(&amp;p-&gt;lock);<br>  acquire(lk);<br>&#125;<br><br><span class="hljs-comment">// Wake up all processes sleeping on chan.</span><br><span class="hljs-comment">// Must be called without any p-&gt;lock.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-keyword">if</span>(p != myproc())&#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;<br>        p-&gt;state = RUNNABLE;<br>       &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>sleep</code>函数调用前，首先要获取<code>lk</code>这把锁，这把锁是用来保护访问的共享资源的。<code>sleep</code>最后调用<code>acquire(lk)</code>也是为了在进程需要被唤醒时，能够安全地访问之前释放的共享资源。</p><p>下面直接看<code>sleep</code>和<code>wakeup</code>运用的场景。</p><h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><p>每一个<code>pipe</code>都有一个<code>struct pipe</code>，包括了一个<code>lock</code>和一个<code>data</code>缓冲数组。此外，还有一个读和一个写的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">char</span> data[PIPESIZE];<br>  uint nread;     <span class="hljs-comment">// number of bytes read</span><br>  uint nwrite;    <span class="hljs-comment">// number of bytes written</span><br>  <span class="hljs-type">int</span> readopen;   <span class="hljs-comment">// read fd is still open</span><br>  <span class="hljs-type">int</span> writeopen;  <span class="hljs-comment">// write fd is still open</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>pipewrite()</code>往管道中写入n个字节。</p><p>首先需要获取<code>pipe</code>的锁，这是为了保护<code>pi</code>结构体里面的共享资源。<br>通过<code>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE</code>判断缓冲区是否已经满了，如果已经满了就唤醒睡在<code>&amp;pi-&gt;nread</code>上的<code>piperead</code>进程对缓冲区进行读取，自己睡在<code>&amp;pi-&gt;nwrite</code>等待唤醒，否则就从user space的<code>addr</code>中<code>copyin</code>到内核态中的<code>pi</code>缓冲区内，完成n字节的读取之后将<code>piperead</code>进程唤醒，释放<code>&amp;pi-&gt;lock</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">pipewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(pi-&gt;readopen == <span class="hljs-number">0</span> || pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; <span class="hljs-comment">//DOC: pipewrite-full</span><br>      wakeup(&amp;pi-&gt;nread);<br>      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">char</span> ch;<br>      <span class="hljs-keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">break</span>;<br>      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;<br>      i++;<br>    &#125;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nread);<br>  release(&amp;pi-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>piperead</code>从管道中读取n个字节。</p><p>也要先获取<code>pi-&gt;lock</code>，判断当前缓冲区内是不是空的，如果是空的就进入睡眠，等待<code>pipewrite</code>进行写入并唤醒，否则循环读取n字节缓冲区数据，将缓冲区的数据<code>copyout</code>到用户空间的<code>addr</code>地址中，待n字节数据全部读取完成之后将<code>pipewrite</code>唤醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">piperead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br>  <span class="hljs-type">char</span> ch;<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>    <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>  &#125;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">//DOC: piperead-copy</span><br>    <span class="hljs-keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)<br>      <span class="hljs-keyword">break</span>;<br>    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];<br>    <span class="hljs-keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nwrite);  <span class="hljs-comment">//DOC: piperead-wakeup</span><br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Code-wait-exit"><a href="#Code-wait-exit" class="headerlink" title="Code: wait &amp; exit"></a>Code: wait &amp; exit</h2><h3 id="wait代码实现"><a href="#wait代码实现" class="headerlink" title="wait代码实现"></a>wait代码实现</h3><p><code>wait</code>中是一个无限循环，每个循环中先对所有的进程循环查找自己的子进程，当发现有子进程并且子进程的状态为<code>ZOMBIE</code>时，将子进程的退出状态<code>np-&gt;xstate</code> <code>copyout</code>到<code>wait</code>传入的用户空间的<code>addr</code>中，然后释放掉子进程占用的所有的内存空间，返回子进程的pid。如果没有发现任何<code>ZOMBIE</code>子进程，睡眠在<code>p</code>上以等待子进程<code>exit</code>时唤醒<code>p</code>。</p><blockquote><p>exit函数会调用wakeup(p-&gt;parent)唤醒父进程。</p></blockquote><p><strong>注意</strong>：<br><code>wait()</code>先要获取调用进程的<code>p-&gt;lock</code>作为<code>sleep</code>的condition lock，然后在发现<code>ZOMBIE</code>子进程后获取子进程的<code>np-&gt;lock</code>，因此xv6中必须遵守先获取父进程的锁才能获取子进程的锁这一个规则。因此在循环查找<code>np-&gt;parent == p</code>时，不能先获取<code>np-&gt;lock</code>，因为<code>np</code>很有可能是自己的父进程，这样就违背了先获取父进程锁再获取子进程锁这个规则，可能造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">wait</span><span class="hljs-params">(uint64 addr)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-type">int</span> havekids, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Scan through table looking for exited children.</span><br>    havekids = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;<br>      <span class="hljs-keyword">if</span>(np-&gt;parent == p)&#123;<br>        <span class="hljs-comment">// make sure the child isn&#x27;t still in exit() or swtch().</span><br>        acquire(&amp;np-&gt;lock);<br><br>        havekids = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(np-&gt;state == ZOMBIE)&#123;<br>          <span class="hljs-comment">// Found one.</span><br>          pid = np-&gt;pid;<br>          <span class="hljs-keyword">if</span>(addr != <span class="hljs-number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;np-&gt;xstate,<br>                                  <span class="hljs-keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="hljs-number">0</span>) &#123;<br>            release(&amp;np-&gt;lock);<br>            release(&amp;wait_lock);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>          &#125;<br>          freeproc(np);<br>          release(&amp;np-&gt;lock);<br>          release(&amp;wait_lock);<br>          <span class="hljs-keyword">return</span> pid;<br>        &#125;<br>        release(&amp;np-&gt;lock);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// No point waiting if we don&#x27;t have any children.</span><br>    <span class="hljs-keyword">if</span>(!havekids || p-&gt;killed)&#123;<br>      release(&amp;wait_lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Wait for a child to exit.</span><br>    sleep(p, &amp;wait_lock);  <span class="hljs-comment">//DOC: wait-sleep</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exit代码实现"><a href="#exit代码实现" class="headerlink" title="exit代码实现"></a>exit代码实现</h3><p><code>exit</code>关闭所有打开的文件，将自己的子进程reparent给<code>init</code>进程，因为<code>init</code>进程永远在调用<code>wait</code>，这样就可以让自己的子进程在<code>exit</code>后由<code>init</code>进行<code>freeproc</code>等后续的操作。然后获取进程锁，设置退出状态和当前状态为<code>ZOMBIE</code>，进入<code>scheduler</code>中并且不再返回。</p><p>注意：在将<code>p-&gt;state</code>设置为<code>ZOMBIE</code>之后才能释放掉<code>wait_lock</code>，否则<code>wait()</code>的进程被唤醒之后发现了<code>ZOMBIE</code>进程之后直接将其释放，此时<code>ZOMBIE</code>进程还没运行完毕。</p><p><code>exit</code>是让自己的程序进行退出，<code>kill</code>是让一个程序强制要求另一个程序退出。<code>kill</code>不能立刻终结另一个进程，因为另一个进程可能在执行敏感命令，因此kill仅仅设置了<code>p-&gt;killed</code>为1，且如果该进程在睡眠状态则将其唤醒。当被<code>kill</code>的进程进入<code>usertrap</code>之后，将会查看<code>p-&gt;killed</code>是否为1，如果为1则将调用<code>exit</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  begin_op();<br>  iput(p-&gt;cwd);<br>  end_op();<br>  p-&gt;cwd = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Give any children to init.</span><br>  reparent(p);<br><br>  <span class="hljs-comment">// Parent might be sleeping in wait().</span><br>  wakeup(p-&gt;parent);<br>  <br>  acquire(&amp;p-&gt;lock);<br><br>  p-&gt;xstate = status;<br>  p-&gt;state = ZOMBIE;<br><br>  release(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Jump into the scheduler, never to return.</span><br>  sched();<br>  panic(<span class="hljs-string">&quot;zombie exit&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用和trap</title>
    <link href="/2023/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/4.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Ctrap/"/>
    <url>/2023/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/4.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Ctrap/</url>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>这篇笔记主要帮助回顾xv6是如何经过trap陷入到内核去的，介绍相关的代码的重要的细节。</p><ul><li>重要的寄存器</li></ul><ol><li><code>SATP</code>（Supervisor Address Translation and Protection）：它包含了指向page table的物理内存地址</li><li><code>STVEC</code>（Supervisor Trap Vector Base Address Register）：它指向了内核中处理trap的指令的起始地址。</li><li><code>SEPC</code>（Supervisor Exception Program Counter）：在trap的过程中保存程序计数器的值。</li><li><code>SSRATCH</code>（Supervisor Scratch Register）寄存器：在ecall指令前指向的是进程trapframe的地址<blockquote><p>trapframe在虚拟地址空间中位于trampoline的上一页(地址低于trampoline)。</p></blockquote></li></ol><ul><li>trap 调用的函数<blockquote><p>uservec -&gt; usertrap -&gt; usertrapret -&gt; userret.</p></blockquote></li></ul><h2 id="ecall指令做了什么？"><a href="#ecall指令做了什么？" class="headerlink" title="ecall指令做了什么？"></a>ecall指令做了什么？</h2><ol><li><code>ecall</code>将代码从user mode改到supervisor mode。</li><li><code>ecall</code>将程序计数器的值保存在了SEPC寄存器。</li><li><code>ecall</code>会跳转到STVEC寄存器指向的指令<blockquote><p>ecall并没有切换到内核的页表。也没有找到一个内核栈(C代码的执行需要栈)</p></blockquote></li></ol><h2 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h2><p>执行完<code>ecall</code>指令，会跳转到<code>STVEC</code>所指向的地址处，这是位于<code>trampoline</code>页面的第一条地址。</p><blockquote><p>内核已经事先设置好了STVEC寄存器的内容为0x3ffffff000。</p></blockquote><ol><li><p>首先交换<code>a0</code>和<code>SSRATCH</code>寄存器的值</p><blockquote><p>腾出一个通用寄存器, a0指向trapframe,注意此时还没有切换页表。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">csrrw a0, sscratch, a0<br></code></pre></td></tr></table></figure></li><li><p>将各种寄存器的值保存在trapframe中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">sd ra, 40(a0)<br>sd sp, 48(a0)<br>.....<br></code></pre></td></tr></table></figure></li><li><p>在trapframe中获取一些相关的信息，比如说<code>usertrap</code>的地址， kernel stack， current hartid</p></li><li><p>切换到内核的页表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">ld t1, 0(a0)<br>csrw satp, t1<br></code></pre></td></tr></table></figure></li><li><p>然后跳转到<code>usertrap</code>函数中。</p></li></ol><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>这时候已经在内核的页表中了。</p><ol><li><p>更改<code>stvec</code>寄存器的值,获取当前进程</p><blockquote><p>trap如果从内核空间发起，将会是一个非常不同的处理流程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">w_stvec((uint64)kernelvec);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br></code></pre></td></tr></table></figure><blockquote><p>myproc函数实际上会查找一个根据当前CPU核的编号索引的数组，CPU核的编号是hartid，如果你还记得，我们之前在uservec函数中将它存在了tp寄存器。这是myproc函数找出当前运行进程的方法。</p></blockquote></li><li><p>保存pc</p><blockquote><p>中途可能切换到另一个进程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br></code></pre></td></tr></table></figure></li><li><p>检查trap的原因，并执行相应的操作。例如如果是系统调用就调用syscall函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br></code></pre></td></tr></table></figure><blockquote><p>epc还需要+4，是因为在RISC-V中，存储在SEPC寄存器中的程序计数器，是用户程序中触发trap的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是ecall之后的一条指令。</p></blockquote></li><li><p>调用<code>usertrapret</code>函数</p></li></ol><h2 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h2><p>返回到用户空间之前内核要做的工作.</p><ol><li>关闭了中断,stvec指向用户空间的trap处理代码</li><li>设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</li><li>跳转到函数userret。<blockquote><p>这个跳转有一点细节</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 fn = TRAMPOLINE + (userret - trampoline);<br>((<span class="hljs-type">void</span> (*)(uint64, uint64))fn)(TRAPFRAME, satp);<br></code></pre></td></tr></table></figure><blockquote><p>首先计算出 userret 在trampoline页面的地址，然后再进行一次函数跳转<br>此时<strong>a0寄存器的值为 TRAPFRAME</strong>,<strong>a1寄存器的值为进程的satp</strong>。</p></blockquote></li></ol><h2 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h2><blockquote><p>这段代码也在trampoline页中,所以切换页表后pc并不会出现错误。</p></blockquote><ol><li><p>切换page table。</p></li><li><p>恢复寄存器现场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm"># put the saved user a0 in sscratch, so we<br># can swap it with our a0 (TRAPFRAME) in the last step.<br>ld t0, 112(a0)<br>csrw sscratch, t0<br><br># restore all but a0 from TRAPFRAME<br>ld ra, 40(a0)<br>ld sp, 48(a0)<br>ld gp, 56(a0)<br>.....<br></code></pre></td></tr></table></figure><p>此时<code>sscratch</code>寄存器的值是系统调用的返回值。<br>回顾一下，在<code>syscall</code>函数中有下面一行,系统调用的返回值覆盖了我们保存在<code>trapframe</code>中的<code>a0</code>寄存器的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/syscall.c</span><br>p-&gt;trapframe-&gt;a0 = syscalls[num]();<br></code></pre></td></tr></table></figure></li><li><p>交换a0和sscratch的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm"># restore user a0, and save TRAPFRAME in sscratch<br>csrrw a0, sscratch, a0<br></code></pre></td></tr></table></figure><p>这样<code>a0</code>就是系统调用的返回值了。<code>sscratch</code>就指向<code>trapframe</code>的地址了。</p></li><li><p>最后调用<code>sret</code>指令</p></li></ol><ul><li>程序会切换回user mode</li><li>SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）</li><li>重新打开中断</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程切换</title>
    <link href="/2023/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/7.%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <url>/2023/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/7.%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="xv6中的线程"><a href="#xv6中的线程" class="headerlink" title="xv6中的线程"></a>xv6中的线程</h2><p>一个线程可以认为是串行执行代码的单元。</p><ol><li>内核线程的概念，对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存。</li><li>每一个用户进程都有独立的内存地址空间，并且包含了一个线程，这个线程控制了用户进程代码指令的执行。所以XV6中的用户线程之间没有共享内存，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。XV6中的进程不会共享内存。<blockquote><p>在一些其他更加复杂的系统中，例如Linux，允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间</p></blockquote></li></ol><hr><h2 id="xv6线程调度"><a href="#xv6线程调度" class="headerlink" title="xv6线程调度"></a>xv6线程调度</h2><p><strong>每个CPU核都创建了一个线程调度器</strong>。<br>对于运算密集型线程，线程调度可以利用定时器中断。定时器中断处理程序会自愿的将CPU让出(yield)给线程调度器，让其他线程运行。<br>线程状态：</p><ol><li>RUNNING，线程当前正在某个CPU上运行</li><li>RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行</li><li>SLEEPING，这个状态意味着线程在等待一些I&#x2F;O事件，它只会在I&#x2F;O事件发生了之后运行</li></ol><hr><h2 id="xv6线程切换"><a href="#xv6线程切换" class="headerlink" title="xv6线程切换"></a>xv6线程切换</h2><p>用户程序在运行时，实际上是用户进程中的一个用户线程在运行。如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的<code>trapframe</code>中，同时属于这个用户程序的内核线程被激活。<br>如果XV6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中第一个进程的内核线程会被切换到第二个进程的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回到用户空间也是通过恢复<code>trapframe</code>完成的。</p><p>完整过程（以时钟切换为例）：</p><ol><li>定时器中断强迫CPU从用户空间切换到内核，用户空间的代码保存在<code>trapframe</code>中。</li><li>内核运行<code>usertrap</code>，这时候运行的是进程1的内核线程。</li><li>调用<code>swtch</code>函数，保存进程1的内核线程寄存器到<code>context</code>对象，在<code>proc</code>结构体中有一个<code>context</code>。(用户寄存器在<code>trapframe</code>，内核线程寄存器在<code>context</code>)。</li><li><code>swtch</code>函数恢复原来在这个CPU上的调度器线程保存的寄存器和stack pointer,<code>swtch</code>函数返回后，CPU寄存器被设置为调度器线程的上下文，然后就在调度下线程的context下执行<code>scheduler</code>函数。</li><li><code>scheduler</code>函数把P1设置成RUNABLE状态，查找下一个RUNABLE进程，再次调用<code>swtch</code>函数, <code>swtch</code>函数完成后，返回到了新线程的上下文中。<blockquote><p>整个xv6中一个CPU核对应一个内核调度线程，它在系统启动时创建。这个内核调度线程是一个死循环，它不断地选择可运行的进程并进行上下文切换，以实现多进程并发。XV6的start.s文件，可以看到为每个CPU核设置好调度器线程。</p></blockquote></li></ol><hr><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><h3 id="yield函数"><a href="#yield函数" class="headerlink" title="yield函数"></a>yield函数</h3><p><code>yield</code>是线程切换的第一步。当触发时钟中断时，会调用<code>yield</code>函数，当前进程会出让CPU并让另一个进程运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);<br>  p-&gt;state = RUNNABLE;<br>  sched();<br>  release(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要内容是加锁，防止一个线程在多个CPU核上被调度。将进程的状态改为RUNABLE，表示让出CPU，随后执行<code>sched</code>函数。</p><h3 id="sched函数"><a href="#sched函数" class="headerlink" title="sched函数"></a>sched函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> intena;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(!holding(&amp;p-&gt;lock))<br>    panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br>  <span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;<br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  mycpu()-&gt;intena = intena;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="swtch函数"><a href="#swtch函数" class="headerlink" title="swtch函数"></a>swtch函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">.globl swtch<br>swtch:<br>        sd ra, 0(a0)<br>        ....省略<br><br>        ld ra, 0(a1)<br>        ....省略<br>        ret<br></code></pre></td></tr></table></figure><blockquote><p>a0是p-&gt;context的地址，a1是cpu中的context结构体地址</p></blockquote><ol><li>会将当前的内核线程的寄存器(ra,sp,s0等)保存到p-&gt;context中,proc结构体中的context字段就是用来保存该进程内核线程寄存器的。</li><li>然后会把cpu中的context赋值给(ra,sp,s0)等寄存器<blockquote><p><strong>CPU结构体中的context保存了当前CPU核的调度器线程的寄存器!!!</strong><br>内核调度线程没有进程与之对应，并且一个CPU核只有一个内核调度线程，所以把它所需要的context直接放到了cpu的context结构体中保存。而cpu中context结构体中有一个返回地址一定就是scheduler函数的某一条指令。</p></blockquote></li></ol><ul><li><p>swtch函数中只保存并恢复了14个寄存器</p><blockquote><p><strong>switch是按照一个普通函数来调用的</strong>，对于有些寄存器，<code>swtch</code>函数的调用者默认<code>swtch</code>函数会做修改，所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以<code>swtch</code> 函数里只需要保存Callee Saved Register就行。</p></blockquote></li><li><p>返回地址的妙用</p><blockquote><p>正因为switch是按照一个普通函数来调用的，在这里，所以<code>ra</code>寄存器存储的是内核线程1的返回地址，随后<code>ld ra, 0(a1)</code>指令，<strong>把返回地址给换了</strong>，换成了CPU处理器调度器线程的返回地址，以及后面的一些上下文。随后<code>swtch</code>函数完成后，返回到了<code>scheduler</code>函数。</p></blockquote></li></ul><h3 id="scheduler函数"><a href="#scheduler函数" class="headerlink" title="scheduler函数"></a>scheduler函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br><br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (;;)<br>  &#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    intr_on();<br><br>    <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)<br>    &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span> (p-&gt;state == RUNNABLE)<br>      &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调度器线程在<code>scheduler</code>函数中也会调用了<code>swtch</code>函数，同样的，它把CPU上寄存器换成了新线程的，并把调度器线程的寄存器保存到了<code>mycpu()-&gt;context</code>中。所以我们从<code>swtch</code>函数返回时，如果不考虑调度器线程在里面的作用，实际上是返回到了对于<code>switch</code>的另一个调用，而不是调度器线程中的调用。<strong>我们返回到的是调度到的新进程在很久之前对于switch的调用</strong>。这就是线程切换的核心。</p><blockquote><p>在课程的示例中，P1线程由于定时器的中断而被调度，执行<code>yield</code>函数，<code>sched</code>函数，<code>swtch</code>函数后而被阻塞。假设P2线程正在执行，随后P2线程也经过同样的过程再执行调度线程，再执行P1,P1被唤醒的刚开始执行指令的地址就是<code>sched</code>函数中的<code>swtch</code>的返回地址。<br>如果不是因为定时器中断发生的切换，ra寄存器可能指向其他位置。</p></blockquote><p>scheduler函数又会调用swtch函数，但参数稍有不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;state = RUNNING;<br>c-&gt;proc = p;<br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br></code></pre></td></tr></table></figure><blockquote><p>这样就把当前调度器线程的寄存器传入cpu的context结构体中。再把寄存器的值换成调度的新进程的内核线程的context。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统层级结构</title>
    <link href="/2023/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/9.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/"/>
    <url>/2023/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/9.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-文件系统组织架构"><a href="#1-文件系统组织架构" class="headerlink" title="1.文件系统组织架构"></a>1.文件系统组织架构</h2><p><img src="https://fanxiao.tech/img/posts/MIT_6S081/image-20210207194130429.png" alt="image-20210207194130429"></p><ul><li><p><code>disk</code>层：对硬盘上的块进行读写操作</p></li><li><p><code>buffer cache</code>层：在内存中对磁盘块进行缓存，并确保只有1个内核进程能在一段时间内修改文件块上存储的数据。</p></li><li><p><code>logging</code>层：让更高的层级能够将对文件块的所有<code>update</code>打包到一个<code>transaction</code>中，从而能保证所有文件块能够在将要崩溃时原子地进行<code>update</code></p></li><li><p><code>inode</code>层：为每个文件提供独一无二的inode number</p></li><li><p><code>directory</code>层：每个文件夹也作为一个特殊的inode结构体，不过内容是一条一条的entry</p></li><li><p><code>pathname</code>层：将文件夹组织为层级，解析路径、</p></li><li><p><code>file descriptor</code>层：将所有的资源都抽象为<code>struct file</code>,如设备，文本文件，管道等</p><hr></li></ul><h2 id="2-Disk-层"><a href="#2-Disk-层" class="headerlink" title="2.Disk 层"></a>2.Disk 层</h2><p>xv6文件系统的磁盘块布局如下：</p><p><img src="https://fanxiao.tech/img/posts/MIT_6S081/image-20210207200046544.png" alt="image-20210207200046544"></p><ul><li><p><code>block 0</code>：启动区域，文件系统不会使用，包含了操作系统启动所需要的代码</p></li><li><p><code>blcok 1</code>: <code>superblock</code>，存储了文件系统的元数据（block的大小、block的数目、inode的数目等），里面有一个mkfs的程序，用来构建初始的文件系统</p></li><li><p><code>block 2-31</code>：<code>log block</code></p></li><li><p><code>block 32-44</code>: <code>inode</code>，一个<code>inode</code>的大小为64字节，一个<code>block</code>的大小为1024字节，因此<code>block32</code>为<code>inode 1-16</code>，block33为<code>inode 17-32</code></p></li><li><p><code>block 45 bitmap block</code>，用来跟踪哪些<code>block</code>是在使用</p></li><li><p>最后从<code>block 46</code>开始是<code>data block</code>，要么是在<code>bitmap</code>中被标记为空闲状态，要么存储了文件&#x2F;文件夹的内容</p><hr></li></ul><h2 id="3-Buffer-cache层"><a href="#3-Buffer-cache层" class="headerlink" title="3.Buffer cache层"></a>3.Buffer cache层</h2><h3 id="buffer-cache层的作用"><a href="#buffer-cache层的作用" class="headerlink" title="buffer cache层的作用"></a>buffer cache层的作用</h3><ol><li>将对磁盘块的访问权限进行同步，保证内存中只保存一个该磁盘块的拷贝，且一次只有一个内核线程访问这个拷贝，但同时可以有多个对这个<code>block</code>的引用</li><li>将被频繁访问的块缓存到内存中(局部性原理)</li></ol><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p><code>bcache</code>就是内存中对硬盘<code>block</code>的缓冲，<code>head</code>的作用是把<code>bcache</code>组织为一个链表，缓冲区的使用早晚就是通过<code>head</code>来判断的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br></code></pre></td></tr></table></figure><p>buffer cache有两个接口，分别是<code>bread()</code>和<code>bwrite()</code>。<br><code>bread</code>通过<code>bget</code>获取一个指定了设备<code>dev</code>和<code>blockno</code>的<code>buf *</code>，这是从硬盘指定的块中获取的一个缓冲数据结构体。<code>valid</code>表示的是内存中的某个<code>block</code>有无磁盘块的一份拷贝，如果没有就要调用<code>virtio_disk_rw</code>函数从磁盘写到内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，可以允许多个文件指向内存中同一个<code>buffer</code>，这里的替换算法也是相当简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为什么要<code>acquiresleep</code>?<blockquote><p>获取这个锁之后立即让这个进程进入睡眠，一旦这个锁可用，该线程就会立刻被唤醒。</p></blockquote></li></ul><p><code>bwrite</code>是向硬盘指定块写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>brelse</code>是释放操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>  <br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-Block-层"><a href="#4-Block-层" class="headerlink" title="4.Block 层"></a>4.Block 层</h2><p>block allocator为磁盘的是否空闲的状态准备了一个bitmap，每一位对应一个磁盘块，0表示空闲1表示正在使用，<code>mkfs</code>负责设置这些位。</p><p><code>sb</code>是一个super block,它记录了文件系统一些基本信息。<br><code>BBLOCK</code>宏是判断某个逻辑块号的信息在哪个<code>bitmap</code>块中。<br>一个<code>bitmap</code>块中，总共用<code>BSIZE</code>个字节，也就是<code>BPB</code>个bit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPB           (BSIZE*8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span><br></code></pre></td></tr></table></figure><p>下面的代码中<code>bp</code>是获取到的<code>bitmap</code>块，一个<code>bitmap</code>的每一个bit都用来标记该<code>blockno</code>是不是空闲的。<code>b</code>是遍历到的位图的第0个bit表示的逻辑块号。<code>bi</code>就是偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">balloc</span><span class="hljs-params">(uint dev)</span><br>&#123;<br>  <span class="hljs-type">int</span> b, bi, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  bp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(b = <span class="hljs-number">0</span>; b &lt; sb.size; b += BPB)&#123;<br>    bp = bread(dev, BBLOCK(b, sb));<br>    <span class="hljs-keyword">for</span>(bi = <span class="hljs-number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;<br>      m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// Is block free?</span><br>        bp-&gt;data[bi/<span class="hljs-number">8</span>] |= m;  <span class="hljs-comment">// Mark block in use.</span><br>        log_write(bp);<br>        brelse(bp);<br>        bzero(dev, b + bi);<br>        <span class="hljs-keyword">return</span> b + bi;<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;balloc: out of blocks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样还需要<code>bfree</code>函数释放硬盘块。</p><hr><h2 id="5-Inode-层"><a href="#5-Inode-层" class="headerlink" title="5.Inode 层"></a>5.Inode 层</h2><p>这里就开始涉及文件是如何组织的了。</p><ol><li><code>inode</code>:内存中的结构，用于文件描述。</li><li><code>dinode</code>:硬盘中的结构，64字节大小，例如<code>inode block</code>中就是存放这些结构体的。它们在硬盘中占据连续的一些块。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-type">short</span> major;<br>  <span class="hljs-type">short</span> minor;<br>  <span class="hljs-type">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// File type</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> nlink;          <span class="hljs-comment">// Number of links to inode in file system</span><br>  uint size;            <span class="hljs-comment">// Size of file (bytes)</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>也就是说内存中的inode是active inodes，即内存中有C指针指向这个inode,ref是指向这个inode指针的数量。ref为0时要删除这个inode</p></blockquote></li></ol><p><code>NDIRECT</code>个<code>addr</code>叫做direct blocks，最后一个<code>addr</code>给出了indirect block的地址，因此一个文件的前12kB（<code>NDIRECT</code> x <code>BSIZE</code>）可以从inode中的direct block <code>addr</code>直接读取，后256kB（<code>NINDIRECT</code> x<code>BSIZE</code>）可以通过indirect block addr翻译得到。因此xv6支持的最大的文件大小为268kB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">inode</span>[<span class="hljs-title">NINODE</span>];</span><br>&#125; itable;<br></code></pre></td></tr></table></figure><p>内存中的itable也是对<code>dinode block</code>的缓存,也就是<code>inode cache</code> ,<code>inode</code>中的valid就是对这个缓存是否有效的标记。<br><code>iget</code>函数和<code>iput</code>函数在此之上实现对inode指针的获取和释放。<br>典型用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ip = iget(dev, inum);<br>ilock(ip);<br>...examine and modify ip-&gt;xxx<br><span class="hljs-title function_">iunlock</span><span class="hljs-params">(ip)</span>;<br>iput(ip);<br></code></pre></td></tr></table></figure><p><code>iget</code>返回了一个直到调用<code>iput</code>都有效的<code>inode</code>，任何代码均可同时访问，因此可以有很多指针指向同一个<code>inode</code>。</p><p><code>ialloc</code>负责从硬盘上的inode blocks中寻找空闲的inode，当找到之后将新的type写入到disk中然后通过调用<code>iget</code>返回一个内存中的inode（将这个inode写入到inode cache）中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">ialloc</span><span class="hljs-params">(uint dev, <span class="hljs-type">short</span> type)</span><br>&#123;<br>  <span class="hljs-type">int</span> inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.ninodes; inum++)&#123;<br>    bp = bread(dev, IBLOCK(inum, sb));<br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;<br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-built_in">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      log_write(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      brelse(bp);<br>      <span class="hljs-keyword">return</span> iget(dev, inum);<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>iget</code>在inode cache中查找和传入的device、inode no相同的active entry，如果找到了这个entry就返回对这个inode的一个新的指针，否则找到一个空的entry将其dev、inum等设置为对应的数值，并设置valid为0待后续从block中读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">iget</span><span class="hljs-params">(uint dev, uint inum)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// Is the inode already cached?</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;icache.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;icache.lock);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode cache entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;icache.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>bmap()</code>负责获取inode中的第n块data block的地址。当<code>bn&lt;NDIRECT</code>时直接返回<code>ip-&gt;addrs[bn]</code>，如果没有这个地址就调用<code>balloc</code>分配一个data block。当<code>NDIRECT&lt;bn&lt;NINDIRECT</code>时先<code>bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT])</code>，然后获取<code>bp-&gt;data[bn-NDIRECT]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-Directory层"><a href="#6-Directory层" class="headerlink" title="6.Directory层"></a>6.Directory层</h2><p>和文件类似，只不过这个inode结构体类型为T_DIR,数据部分是<code>directory entry</code>,每一个<code>entry</code>数据类型为<code>struct dirent</code>,因为每一个<code>entry</code>仍旧是一个条目，所以还应该包含一个<code>inode number</code>.<br><code>dirlookup</code> 是在directoy中查找名称为<code>name</code>的<code>directoy entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">dirlookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)</span><br>&#123;<br>  uint off, inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    panic(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(namecmp(name, de.name) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// entry matches path element</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> iget(dp-&gt;dev, inum);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>readi</code>函数就是在<code>struct inode* ip</code>的文件读取<code>off</code>偏移的内容，这里需要用到<code>bmap</code>函数来打开逻辑块号，再把内容复制到内核空间中或者用户空间(根据<code>user_dst</code>为1或者为0) 中地址为<code>dst</code>的地方去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readi</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span> (off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (off + n &gt; ip-&gt;size)<br>    n = ip-&gt;size - off;<br><br>  <span class="hljs-keyword">for</span> (tot = <span class="hljs-number">0</span>; tot &lt; n; tot += m, off += m, dst += m)<br>  &#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off / BSIZE));<br>    m = min(n - tot, BSIZE - off % BSIZE);<br>    <span class="hljs-keyword">if</span> (either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="hljs-number">-1</span>)<br>    &#123;<br>      brelse(bp);<br>      tot = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dirlink</code>讲一个新的<code>directory entry</code>写入文件夹<code>dp</code>中，查找<code>dp</code>中尚未分配的<code>entry</code>,如果找到就要用<code>writei</code>在文件中写入内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">dirlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint inum)</span><br>&#123;<br>  <span class="hljs-type">int</span> off;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// Check that name is not present.</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Look for an empty dirent.</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);<br>  de.inum = inum;<br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-Pathname-层"><a href="#7-Pathname-层" class="headerlink" title="7.Pathname 层"></a>7.Pathname 层</h2><p><code>namei</code>函数对pathname进行解析，返回<code>inode</code>。<code>namei</code>调用了<code>namex</code>函数，<code>namex</code>函数传入参数<code>nameiparent</code>,当为1是返回的<code>inode</code>是传入path的父文件夹。<br>例如，如果path地第一个字符为&#x2F;,则表示这是绝对路径，那么首先需要得到<code>ROOTINO</code>的<code>inode</code>；否则就是相对路径，则要把<code>myproc-&gt;cwd</code>的引用计数加1,<code>proc</code>中的<code>cwd</code>类型是<code>struct inode*</code>。<br>然后不断用<code>skipelem</code>函数解析path中的&#x2F;,不断查找下一级的<code>inode</code>,最后<code>namei</code>返回目标<code>inode</code>。<br>主要内容见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namex</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    ip = iget(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span><br>    ip = idup(myproc()-&gt;cwd);<br><br>  <span class="hljs-keyword">while</span>((path = skipelem(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// Stop one level early.</span><br>      iunlock(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((next = dirlookup(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    iunlockput(ip);<br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-File-descriptor层"><a href="#8-File-descriptor层" class="headerlink" title="8.File descriptor层"></a>8.File descriptor层</h2><p>File descriptor层让UNIX中所有的资源，包括设备都可以同一表示为文件。每个打开的文件都可以用<code>struct file</code>来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-type">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-type">char</span> readable;<br>  <span class="hljs-type">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-type">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>open</code>可以增加文件，一个进程打开的文件都保存在结构体<code>proc</code>中的<code>struct file *ofile[NOFILE]</code>数组中。<br>所有打开的文件都保存在global file table，即<code>ftable</code>中。<br><code>filealloc</code>负责在file table中分配一个文件，在<code>ftable</code>中扫描<code>ref==0</code>的file，增加<code>ref</code>后返回这个<code>file *</code>。<br><code>filedup</code>负责对这个file descriptor的<code>ref++</code>并返回这个文件的<code>file *</code>。<br><code>fileclose</code>负责对file descriptor的<code>ref–</code>，当<code>ref==0</code>时根据这个file的类型释放掉<code>pipe</code>或者<code>inode</code>。</p><hr><h2 id="9-相关系统调用"><a href="#9-相关系统调用" class="headerlink" title="9.相关系统调用"></a>9.相关系统调用</h2><p><code>sys_link</code>和<code>sys_unlink</code>这两个系统调用实现对<code>inode</code>的增加或者删除引用。<br><code>sys_link</code>传入一个参数<code>old</code>和一个参数<code>new</code>,<code>new</code>是需要链接到<code>old</code>的路径。<code>sys_link</code>首先增加<code>struct inode* ip</code>的<code>nlink</code>,然后调用<code>nameiparent</code>查找<code>new</code>的父文件夹，调用<code>dirlink</code>在父文件夹中创建一个名为<code>new</code>的<code>directory entry</code>。<br>主要内容见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_link</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">dp</span>, *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, old, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, new, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((ip = namei(old)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ilock(ip);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ip-&gt;nlink++;<br>  iupdate(ip);<br>  iunlock(ip);<br><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(new, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  ilock(dp);<br>  <span class="hljs-keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    <span class="hljs-keyword">goto</span> bad;<br>  &#125;<br>  iunlockput(dp);<br>  iput(ip);<br><br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad:<br>  ilock(ip);<br>  ip-&gt;nlink--;<br>  iupdate(ip);<br>  iunlockput(ip);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>系统调用<code>open</code>可能会调用<code>create</code>函数。<br><code>create</code>首先调用<code>nameiparent</code>获取父文件夹，然后调用<code>dirlookup</code>来查看这个文件夹下是否已经存在同名的inode，如果存在且调用这个<code>create</code>的是<code>open</code>来创建一个文件的话，那么直接返回这个inode。如果这个名称不存在，则调用ialloc。如果是<code>mkdir</code>调用的<code>create</code>（即<code>type==T_DIR</code>)，则要创建<code>..</code>和<code>.</code>作为对父级inode和当前inode的引用，最终将当前的<code>name</code> <code>dirlink</code>到当前inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">dp</span>;</span><br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  ilock(dp);<br><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip;<br>    iunlockput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  ilock(ip);<br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  iupdate(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    iupdate(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-keyword">if</span>(dirlink(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || dirlink(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  iunlockput(dp);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU_15445：Project C++ Primer</title>
    <link href="/2023/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Project0/"/>
    <url>/2023/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Project0/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>书到用时方恨少，这个Project虽说前缀树我在之前就学过，但C++的基础知识还是很不牢固，所以先把一些需要用的知识点要在这里再记一下。</p><h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><ul><li>左值是可以放在赋值号左边的，左值必须要在内存中有实体。</li><li>右值出现在赋值号右边；右值可以在寄存器也可以在内存中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = num;<br><span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>上面。<code>num</code>有地址是左值，<code>b</code>是对<code>num</code>的引用，所以这是左值引用。而10是右值，所以<code>c</code>是右值引用，这里是错误的。<br>但这样又是可以的：<br><code>const int&amp; c =10</code>,允许使用常量左值引用操作右值。<br>实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><h4 id="右值引用介绍"><a href="#右值引用介绍" class="headerlink" title="右值引用介绍"></a>右值引用介绍</h4><p>右值引用也必须立即进行初始化操作，且<strong>使用右值进行初始化</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>上面的操作都是正确的。<br>右值引用 引用 右值，会使右值被存储到特定的位置。</p><ul><li>左值引用的短板<br>传值传参和传值返回都会产生拷贝，有的甚至是深拷贝，代价很大。而左值引用的实际意义在于做参数和做返回值都可以减少拷贝，从而提高效率。但是，左值引用的短板是不能够<strong>引用局部变量</strong>。</li></ul><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 接收一个 std::vector&lt;int&gt; 的右值引用参数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">processVector</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; vec)</span> &#123;<br>    <span class="hljs-comment">// 对右值引用进行操作，而不进行拷贝</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// 将 nums 作为右值传递给函数</span><br>    processVector(<span class="hljs-built_in">std</span>::move(nums));<br><br>    <span class="hljs-comment">// 此时 nums 已被移动，不再可用</span><br>    <span class="hljs-comment">// 这里访问 nums 将导致未定义的行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>右值引用的特性是可以绑定到临时对象（右值）上的引用，而临时对象在表达式求值后就会被销毁。因此，当我们将<code>nums</code>通过<code>std::move()</code>转换为右值引用后，它的值类别变为右值，而不再是左值。<br>在函数参数中接收到右值引用 vec 后，我们可以直接操作它，而不需要进行对象拷贝。这是因为右值引用的特性允许我们“窃取”临时对象的资源，而不是进行拷贝。在这种情况下，我们可以直接使用 <code>vec</code> 的资源（例如 <code>std::vector</code> 中的数据），而不需要进行额外的拷贝操作。</p><h4 id="move移动语义"><a href="#move移动语义" class="headerlink" title="move移动语义"></a>move移动语义</h4><p>作用是将一个左值强制转化为右值，以实现移动语义。左值被 move 后变为右值，于是右值引用可以引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> t = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int&amp;&amp; rrt = t; // 编译报错，不能直接引用左值</span><br><br><span class="hljs-comment">// 2.但是右值引用可以引用被move的左值</span><br><span class="hljs-type">int</span>&amp;&amp; rrt = <span class="hljs-built_in">std</span>::move(t);  <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>右值引用意义和移动构造函数:<br>右值做参数，那么就会调用移动构造，而调用移动构造就会减少拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次移动构造就会少做一次深拷贝。</p><h4 id="forward完美转发"><a href="#forward完美转发" class="headerlink" title="forward完美转发"></a>forward完美转发</h4><p>有了<code>move</code>函数之后，我们又遇到了一个新的问题：</p><p>按照上面的写法，处理临时变量用右值引用<code>T&amp;&amp;</code>，处理普通变量用<code>const</code>引用<code>const T&amp;</code>，我们需要分别建立两个函数，然后入参使用不同的类型，每个函数都要写两遍。<br>那么能不能避免重复，将<code>T &amp;&amp;</code>类型和<code>const T &amp;</code>类型合二为一呢？</p><blockquote><p>答案就是：<code>forward</code>函数，<code>std::forward</code>也被称为完美转发，即：保持原来的值属性不变：</p></blockquote><ul><li>如果原来的值是左值，经<code>std::forward</code>处理后该值还是左值。</li><li>如果原来的值是右值，经<code>std::forward</code>处理后它还是右值。<br>这样一来，我们就可以使用<code>forward</code>函数对入参进行封装，从而保证了入参的统一性，从而可以实现一个方法处理两种类型！<br>正因为如此，<code>forward</code>函数被大量用在了入参值类型情况不确定的C++模板中！</li></ul><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><code>std::unique_ptr</code>是一个智能指针类模板，用于管理动态分配的对象。它提供了独占所有权的语义，意味着一个<code>unique_ptr</code>指针可以拥有对一个对象的唯一所有权，并负责在其生命周期结束时自动释放该对象。</p><ul><li><code>move</code>: 转移所有权，将原指针置空。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">ptr1</span><span class="hljs-params">(new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; ptr2 = <span class="hljs-built_in">std</span>::move(ptr1); <span class="hljs-comment">// 移动所有权</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>vec.push_back(<span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>)); <span class="hljs-comment">// 移动 unique_ptr 到容器中</span><br></code></pre></td></tr></table></figure><ul><li><code>reset</code>:更改所有权。</li></ul><ol><li><code>ptr.reset()</code>:销毁对象，指针置空。</li><li><code>ptr.reset(new_ptr)</code>:智能指针指向新的对象，原对象销毁。</li></ol><ul><li><code>get</code>：<code>get()</code>是<code> unique_ptr</code>类的成员函数，它返回指向<code>unique_ptr</code>所拥有的对象的指针，即原始指针。</li></ul><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说了这么多，如果感觉还不是很懂，就直接来看代码吧。<br>我这里只介绍一些比较重要的函数。</p><h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">TrieNode(TrieNode &amp;&amp;other_trie_node) noexcept &#123;<br>    key_char_ = other_trie_node.key_char_;<br>    is_end_ = other_trie_node.is_end_;<br>    children_.swap(other_trie_node.children_);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这就是移动构造函数。<br>调用<code> children_.swap(other_trie_node.children_)</code>，使用<code> std::swap</code>函数将 <code>other_trie_node</code> 的 <code>children_</code> 成员变量与当前对象的 <code>children_</code>成员变量进行交换。这样做可以实现高效的移动操作，避免不必要的复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *<span class="hljs-title function_">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; &amp;&amp;child)</span> &#123;<br>    <span class="hljs-keyword">if</span> (HasChild(key_char) || key_char != child-&gt;key_char_) &#123;<br>      <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    children_[key_char] = <span class="hljs-built_in">std</span>::move(child);<br>    <span class="hljs-keyword">return</span> &amp;children_[key_char];<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *<span class="hljs-title function_">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> &#123;<br>    <span class="hljs-keyword">auto</span> node = children_.find(key_char);<br>    <span class="hljs-keyword">if</span> (node != children_.end()) &#123;<br>      <span class="hljs-keyword">return</span> &amp;(node-&gt;second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>为什么返回的都是智能指针的指针？</p><blockquote><p>因为智能指针对一个对象有唯一的所有权,如果我们在字典树的操作中需要不断迭代的话，需要移动指针，那就需要用到智能指针的指针了。</p></blockquote></li><li><p>为什么要<code>children_[key_char] = std::move(child)</code>?</p><blockquote><p>child 是一个右值引用的 std::unique_ptr<TrieNode>，应该直接将其移动给 children_[key_char]。child 的所有权转移给 children_[key_char]，而不是重新构造一个新的 std::unique_ptr。这样做可以避免不必要的内存分配和析构，并正确地转移所有权。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RemoveChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> &#123;<br>    <span class="hljs-keyword">auto</span> node = children_.find(key_char);<br>    <span class="hljs-keyword">if</span> (node != children_.end()) &#123;<br>      node-&gt;second.reset();<br>      children_.erase(key_char);<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="TrieNodeWithValue"><a href="#TrieNodeWithValue" class="headerlink" title="TrieNodeWithValue"></a>TrieNodeWithValue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value) : TrieNode(<span class="hljs-built_in">std</span>::forward&lt;TrieNode&gt;(trieNode)) &#123;<br>    value_ = value;<br>    SetEndNode(<span class="hljs-literal">true</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>移动构造函数，把<code>trieNode</code>作为右值传递给<code>TrieNodeWithValue</code>，实现资源的转移。</p><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br>  <span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key, T value)</span> &#123;<br>     <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    latch_.WLock();<br>    <span class="hljs-keyword">auto</span> cur = &amp;root_;<br>    <span class="hljs-comment">// latch_.WLock();</span><br>    <span class="hljs-keyword">auto</span> c = key.begin();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">auto</span> x = c++;<br>      <span class="hljs-keyword">if</span> (c == key.end()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cur-&gt;get()-&gt;HasChild(*x)) &#123;<br>        cur = cur-&gt;get()-&gt;GetChildNode(*x);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur = cur-&gt;get()-&gt;InsertChildNode(*x, <span class="hljs-built_in">std</span>::make_unique&lt;TrieNode&gt;(*x));<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">char</span> ch = key.back();<br>    <span class="hljs-keyword">auto</span> end_node = cur-&gt;get()-&gt;GetChildNode(ch);<br><br>    <span class="hljs-keyword">if</span> (end_node != nullptr &amp;&amp; end_node-&gt;get()-&gt;IsEndNode()) &#123;<br>      latch_.WUnlock();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (end_node != nullptr) &#123;<br>      <span class="hljs-keyword">auto</span> new_node = new TrieNodeWithValue&lt;T&gt;(<span class="hljs-built_in">std</span>::move(*(end_node-&gt;get())), value);<br>      end_node-&gt;reset(new_node);<br><br>      latch_.WUnlock();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果为空</span><br>    cur = cur-&gt;get()-&gt;InsertChildNode(ch, <span class="hljs-built_in">std</span>::make_unique&lt;TrieNode&gt;(ch));<br>    <span class="hljs-comment">// 现在还是一个中间节点，还不是TrieNodeWithValue</span><br>    <span class="hljs-keyword">auto</span> new_node = new TrieNodeWithValue&lt;T&gt;(<span class="hljs-built_in">std</span>::move(**cur), value);<br>    cur-&gt;reset(new_node);<br>    latch_.WUnlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    latch_.WLock();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *&gt; storage;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *node = &amp;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key) &#123;<br>      storage.emplace_back(node);<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *next = node-&gt;get()-&gt;GetChildNode(ch);<br><br>      <span class="hljs-keyword">if</span> (next == nullptr) &#123;<br>        latch_.WUnlock();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      node = next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node-&gt;get()-&gt;HasChildren()) &#123;<br>      <span class="hljs-comment">// node = node-&gt;get()-&gt;GetChildNode(key[key.size()-1]);</span><br>      node-&gt;get()-&gt;SetEndNode(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = storage.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 想一下， root 节点是不记录字符的</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *pre = storage[i];<br>        <span class="hljs-keyword">if</span> ((i &lt; static_cast&lt;<span class="hljs-type">int</span>&gt;(key.size() - <span class="hljs-number">1</span>)) &amp;&amp; (node-&gt;get()-&gt;IsEndNode() || node-&gt;get()-&gt;HasChildren())) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pre-&gt;get()-&gt;RemoveChildNode(key[i]);<br>        node = pre;<br>      &#125;<br>    &#125;<br><br>    latch_.WUnlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br>  T <span class="hljs-title function_">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key, <span class="hljs-type">bool</span> *success)</span> &#123;<br>    *success = <span class="hljs-literal">true</span>;<br>    latch_.RLock();<br>    <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> cur = &amp;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key) &#123;<br>      <span class="hljs-keyword">if</span> (cur-&gt;get()-&gt;HasChild(ch)) &#123;<br>        cur = cur-&gt;get()-&gt;GetChildNode(ch);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        *success = <span class="hljs-literal">false</span>;<br>        latch_.RUnlock();<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!cur-&gt;get()-&gt;IsEndNode()) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      latch_.RUnlock();<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> flag_node = dynamic_cast&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur-&gt;get());<br>    <span class="hljs-keyword">if</span> (flag_node == nullptr) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      latch_.RUnlock();<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    latch_.RUnlock();<br>    <span class="hljs-keyword">return</span> flag_node-&gt;GetValue();<br>  &#125;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池的C语言实现</title>
    <link href="/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1.任务队列"></a>1.任务队列</h2><p>线程池结构体就是存储任务队列的。很明显，任务中需要有执行函数的函数地址和传入的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> (*function)(<span class="hljs-type">void</span> *arg);<br>    <span class="hljs-type">void</span> *arg;<br>&#125; Task;<br></code></pre></td></tr></table></figure><p>在这里，我们的<code>function</code>函数只接受单个参数。</p><ul><li>如果需要多个参数呢？我在github上给出了一小段实现代码。<br><a href="https://github.com/BlackGhostLzc/ThreadPool.git">这是我的github仓库</a><br>其实就是需要一个参数结构体<code>MyParam</code>，<code>function</code>中传入的<code>arg</code>类型转换为<code>MyParam</code>就行了。</li></ul><hr><h2 id="2-线程池定义"><a href="#2-线程池定义" class="headerlink" title="2.线程池定义"></a>2.线程池定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadPool</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 任务队列</span><br>    Task *taskQ;<br>    <span class="hljs-type">int</span> queueCapacity;<br>    <span class="hljs-type">int</span> queueSize; <span class="hljs-comment">// 当前任务个数</span><br>    <span class="hljs-type">int</span> queueFront;<br>    <span class="hljs-type">int</span> queueRear;<br><br>    <span class="hljs-type">pthread_t</span> managerID;  <span class="hljs-comment">// 管理者线程ID</span><br>    <span class="hljs-type">pthread_t</span> *threadIDs; <span class="hljs-comment">// 工作的线程ID</span><br><br>    <span class="hljs-type">int</span> minNum;  <span class="hljs-comment">// 最小线程数</span><br>    <span class="hljs-type">int</span> maxNum;  <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-type">int</span> busyNum; <span class="hljs-comment">// 忙的线程数</span><br>    <span class="hljs-type">int</span> liveNum; <span class="hljs-comment">// 存活的线程数</span><br>    <span class="hljs-type">int</span> exitNum; <span class="hljs-comment">// 要杀死的线程个数</span><br><br>    <span class="hljs-type">pthread_mutex_t</span> mutexPool; <span class="hljs-comment">// 锁整个线程池</span><br>    <span class="hljs-type">pthread_mutex_t</span> mutexBusy; <span class="hljs-comment">// 锁busyNum变量</span><br><br>    <span class="hljs-type">pthread_cond_t</span> notFull; <span class="hljs-comment">// 任务队列是否是满的</span><br>    <span class="hljs-type">pthread_cond_t</span> notEmpty;<br><br>    <span class="hljs-type">int</span> shutdown; <span class="hljs-comment">// 是否销毁线程池</span><br>&#125; ThreadPool;<br></code></pre></td></tr></table></figure><hr><h2 id="3-函数申明"><a href="#3-函数申明" class="headerlink" title="3.函数申明"></a>3.函数申明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建线程池</span><br>ThreadPool *<span class="hljs-title function_">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span>;<br><span class="hljs-comment">// 销毁线程池</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolDestroy</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// 往等待队列中添加任务,threadPool中的TaskQ</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadPoolAdd</span><span class="hljs-params">(ThreadPool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 忙碌线程的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// 存活线程的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// manager线程处理函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 存活线程处理函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 线程退出</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadExit</span><span class="hljs-params">(ThreadPool *pool)</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-函数代码实现"><a href="#4-函数代码实现" class="headerlink" title="4.函数代码实现"></a>4.函数代码实现</h2><h3 id="threadPoolCreate"><a href="#threadPoolCreate" class="headerlink" title="threadPoolCreate"></a>threadPoolCreate</h3><p>体会一下<code>do... while(0)</code>的妙用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c">ThreadPool *<span class="hljs-title function_">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ThreadPool));<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadpool fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        pool-&gt;threadIDs = (<span class="hljs-type">pthread_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadIDs fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(pool-&gt;threadIDs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        pool-&gt;minNum = min;<br>        pool-&gt;maxNum = max;<br>        pool-&gt;busyNum = <span class="hljs-number">0</span>;<br>        pool-&gt;liveNum = min; <span class="hljs-comment">// 和最小个数相等</span><br>        pool-&gt;exitNum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_cond_init(&amp;pool-&gt;notFull, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mutex or condition init fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 任务队列</span><br>        pool-&gt;taskQ = (Task *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Task) * queueSize);<br>        pool-&gt;queueCapacity = queueSize;<br>        pool-&gt;queueSize = <span class="hljs-number">0</span>;<br>        pool-&gt;queueFront = <span class="hljs-number">0</span>;<br>        pool-&gt;queueRear = <span class="hljs-number">0</span>;<br><br>        pool-&gt;shutdown = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 创建线程</span><br>        pthread_create(&amp;pool-&gt;managerID, <span class="hljs-literal">NULL</span>, manager, pool);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; min; ++i)<br>        &#123;<br>            pthread_create(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs)<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    <span class="hljs-keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ)<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    <span class="hljs-keyword">if</span> (pool)<br>        <span class="hljs-built_in">free</span>(pool);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadPoolDestroy"><a href="#threadPoolDestroy" class="headerlink" title="threadPoolDestroy"></a>threadPoolDestroy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolDestroy</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br><br>    <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭线程池</span><br>    pool-&gt;shutdown = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 阻塞回收管理者线程</span><br>    pthread_join(pool-&gt;managerID, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 唤醒阻塞的消费者线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;liveNum; ++i)<br>    &#123;<br>        pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>    &#125;<br>    <span class="hljs-comment">// 释放堆内存</span><br>    <span class="hljs-keyword">if</span> (pool-&gt;taskQ)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;threadIDs)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    &#125;<br><br>    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);<br>    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);<br>    pthread_cond_destroy(&amp;pool-&gt;notEmpty);<br>    pthread_cond_destroy(&amp;pool-&gt;notFull);<br><br>    <span class="hljs-built_in">free</span>(pool);<br>    pool = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="threadPoolAdd"><a href="#threadPoolAdd" class="headerlink" title="threadPoolAdd"></a>threadPoolAdd</h3><ul><li>为什么需要<code>while</code>循环<br>因为<code>pthread_cond_signal</code>会唤醒所有被条件变量阻塞的线程。<br>假设有两个生产者线程因为任务队列已经满了，而被阻塞在该位置。随后某个工作线程拿取了一个任务而使得任务队列没有满，接着<code>pthread_cond_signal</code>唤醒这两个生产者线程。这两个生产者线程首先都尝试获取<code>mutexPool</code>这把锁，然后只有一个生产者线程拿到了这把锁，执行到下一个<code>while</code>循环条件不满足就退出了，然后就可以把任务添加到任务队列中，最后释放掉了锁。此时任务队列又满了。<br>随后第二个生产者线程获得锁，仍在<code>while</code>循环中，它发现条件仍然满足，又调用<code>pthread_cond_wait</code>函数。<br>通过这样的机制，生产者线程就不会在已经满了的任务队列中继续添加任务了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">threadPoolAdd</span><span class="hljs-params">(ThreadPool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><br>    pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 阻塞生产者线程</span><br>        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;shutdown)<br>    &#123;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 添加任务</span><br>    pool-&gt;taskQ[pool-&gt;queueRear].function = func;<br>    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;<br>    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="hljs-number">1</span>) % pool-&gt;queueCapacity;<br>    pool-&gt;queueSize++;<br><br>    pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="threadPoolBusyNum、threadPoolAliveNum"><a href="#threadPoolBusyNum、threadPoolAliveNum" class="headerlink" title="threadPoolBusyNum、threadPoolAliveNum"></a>threadPoolBusyNum、threadPoolAliveNum</h3><p>这两个函数比较简单，不做说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-keyword">return</span> busyNum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-type">int</span> aliveNum = pool-&gt;liveNum;<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-keyword">return</span> aliveNum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>上一篇说过，<code>woker</code>函数是一个<code>while</code>循环，这很自然，因为线程池就是要复用线程，一个线程结束后应该转去执行其他任务，不应该结束。<br><code>while</code>循环下还有一个<code>while</code>循环，这和上面的逻辑很像。也是为了防止某个线程尝试获取空队列中的任务，这会引发难以预料的错误。<br>最后线程的执行就是一次函数调用<code>task.function(task.arg)</code><br>这里还需要注意对<code>busyNum</code>的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)arg;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-comment">// 当前任务队列是否为空</span><br>        <span class="hljs-keyword">while</span> (pool-&gt;queueSize == <span class="hljs-number">0</span> &amp;&amp; !pool-&gt;shutdown)<br>        &#123;<br>            <span class="hljs-comment">// 阻塞工作线程</span><br>            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);<br><br>            <span class="hljs-comment">// 判断是不是要销毁线程</span><br>            <span class="hljs-keyword">if</span> (pool-&gt;exitNum &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                pool-&gt;exitNum--;<br>                <span class="hljs-keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)<br>                &#123;<br>                    pool-&gt;liveNum--;<br>                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>                    threadExit(pool);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断线程池是否被关闭了</span><br>        <span class="hljs-keyword">if</span> (pool-&gt;shutdown)<br>        &#123;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>            threadExit(pool);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任务队列中取出一个任务</span><br>        Task task;<br>        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;<br>        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;<br>        <span class="hljs-comment">// 移动头结点</span><br>        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="hljs-number">1</span>) % pool-&gt;queueCapacity;<br>        pool-&gt;queueSize--;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_cond_signal(&amp;pool-&gt;notFull);<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());<br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum++;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>        task.function(task.arg);<br>        <span class="hljs-built_in">free</span>(task.arg);<br>        task.arg = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld end working...\n&quot;</span>, pthread_self());<br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum--;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h3><p><code>manager</code>是管理这些存活线程的线程。<br><code>exitNum</code>是需要杀死的线程数目。<br>在这里，增加存活线程和杀死存活线程的逻辑比较简单，详情见代码。<br>每一次最多增加或杀死<code>NUMBER</code>个存活线程。其实杀死存活线程的逻辑仍然在存活线程的<code>worker</code>函数中，<del>存活线程都是自杀的</del>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)arg;<br>    <span class="hljs-keyword">while</span> (!pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 每隔3s检测一次</span><br>        sleep(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 取出线程池中任务的数量和当前线程的数量</span><br>        pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-type">int</span> queueSize = pool-&gt;queueSize;<br>        <span class="hljs-type">int</span> liveNum = pool-&gt;liveNum;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br><br>        <span class="hljs-comment">// 取出忙的线程的数量</span><br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br><br>        <span class="hljs-comment">// 添加线程</span><br>        <span class="hljs-comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span><br>        <span class="hljs-keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)<br>        &#123;<br>            pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>            <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>                    counter++;<br>                    pool-&gt;liveNum++;<br>                &#125;<br>            &#125;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>        &#125;<br>        <span class="hljs-comment">// 销毁线程</span><br>        <span class="hljs-comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span><br>        <span class="hljs-keyword">if</span> (busyNum * <span class="hljs-number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)<br>        &#123;<br>            pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>            pool-&gt;exitNum = NUMBER;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>            <span class="hljs-comment">// 让工作的线程自杀</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMBER; ++i)<br>            &#123;<br>                pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadExit"><a href="#threadExit" class="headerlink" title="threadExit"></a>threadExit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">threadExit</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid = pthread_self();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == tid)<br>        &#123;<br>            pool-&gt;threadIDs[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池概述</title>
    <link href="/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-线程池的原理"><a href="#1-线程池的原理" class="headerlink" title="1.线程池的原理"></a>1.线程池的原理</h2><p>为什么需要线程池</p><ul><li>并发的线程数目较多，假如每一个线程都只是执行一个时间很短的任务就结束了，那么这样频繁的创建线程就会大大降低系统的效率，因为频繁创建和销毁线程都需要时间。</li></ul><p>线程池就是使得线程可以复用，一个线程执行完一个任务后并不销毁。线程池里的线程都是后台线程。如果某个线程在托管代码中空闲，那么线程池将插入另一个辅助线程来使所有处理器繁忙。如果线程池中的所有线程都繁忙，但队列中包含挂起的任务，那么线程池应该创建一个辅助线程但线程的总数不应超过最大值。超过最大值的线程需要排队。</p><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>存储需要处理的任务，由工作的线程来处理这些任务，线程池threadpool中就是存储这些待处理的任务。</p><blockquote><p>生产者消费者模型：生产者线程往任务队列里放任务，消费者线程把任务从队列中取出去。</p></blockquote><h4 id="工作的线程"><a href="#工作的线程" class="headerlink" title="工作的线程"></a>工作的线程</h4><p>任务队列的消费者。它们不停地读取任务队列，从中取出任务并处理。<br>如果任务队列为空，工作的线程将被阻塞；如果阻塞后有新的任务，由生产者将阻塞解除，工作线程开始工作。</p><h4 id="管理者线程"><a href="#管理者线程" class="headerlink" title="管理者线程"></a>管理者线程</h4><p>周期性地对任务队列中任务的数量以及处于忙碌状态的工作线程进行检测。</p><ul><li>任务过多的时候，可以创建一些新的工作线程</li><li>任务过少时，可以销毁一些工作线程</li></ul><hr><h2 id="2-项目介绍"><a href="#2-项目介绍" class="headerlink" title="2.项目介绍"></a>2.项目介绍</h2><h3 id="相关函数介绍"><a href="#相关函数介绍" class="headerlink" title="相关函数介绍"></a>相关函数介绍</h3><p>首先需要介绍几个<code>pthread.h</code>的库函数。<br><code>pthread_create(pthread_t *restrict thread, const pthread_attr_t`` *restrict attr, void *(*start_routine)(void *),void *restrict arg)</code>:创建线程, <code>start_rountine</code>作为线程起始执行函数，<code>arg</code>是传进该函数的参数。</p><p><code>pthread_join(pthread_t thread, void **retval)</code>:等待 <code>thread</code>线程结束，调用该函数的线程将被阻塞。</p><p><code>pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)</code>: 在调用这个函数前，都要获取<code>mutex</code>互斥锁。然后挂起该线程，阻塞的时候释放<code>mutex</code>这把锁（避免死锁）。等到再被唤醒的时候，他又会重新获取<code>mutex</code>这把锁。</p><p><code>pthread_signal(pthread_cond_t *cond)</code>:唤醒阻塞在<code>cond</code>条件变量上的所有线程，通常配合上面的函数一起使用。</p><h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h3><ol><li>存活线程：是等待执行任务的线程或者已经在执行任务的线程</li><li>忙碌线程：已经在执行任务的线程</li></ol><ul><li>需要创建一个管理者线程，传入一个函数指针<code>manage</code>,这个<code>manage</code>函数是一个<code>while</code>循环，它每隔一段时间就做一次检查，判断是否需要添加新的存活线程或者销毁存活线程。</li><li>创建多个存活线程，传入函数指针<code>worker</code>,同样，这个<code>worker</code>函数也是一个<code>while</code>循环，不断处理线程池中的待处理任务。在获取了线程池中的任务后，待处理任务的执行就是一个函数调用，函数完成后接着下一次的<code>while</code>循环判断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态机模型的应用</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件视角的操作系统</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：计算机硬件的状态机模型；回答以下问题："><a href="#本讲内容：计算机硬件的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：计算机硬件的状态机模型；回答以下问题："></a>本讲内容：计算机硬件的状态机模型；回答以下问题：</h2><ul><li>什么是计算机硬件？</li><li>计算机硬件和程序员之间是如何约定的？</li><li>听说操作系统也是程序。那到底是鸡生蛋还是蛋生鸡？</li></ul><h2 id="硬件与程序员的约定"><a href="#硬件与程序员的约定" class="headerlink" title="硬件与程序员的约定"></a>硬件与程序员的约定</h2><h3 id="Bare-metal-与程序员的约定"><a href="#Bare-metal-与程序员的约定" class="headerlink" title="Bare-metal 与程序员的约定"></a>Bare-metal 与程序员的约定</h3><blockquote><p>Bare-metal 是指在没有操作系统或者其他软件支持的情况下直接运行硬件的情况。</p></blockquote><ul><li><p>Bare-metal 与厂商的约定</p><ul><li>CPU Reset 后的状态 (寄存器值)</li></ul></li></ul><blockquote><p>   Reset 后处理器都从固定地址 (Reset Vector) 启动<br>     - 厂商自由处理这个地址上的值<br>     - Memory-mapped I&#x2F;O</p></blockquote><ul><li><p>厂商为操作系统开发者提供 Firmware</p><ul><li>管理硬件和系统配置</li><li>把存储设备上的代码加载到内存<ul><li>例如存储介质上的第二级 loader (加载器)</li><li>或者直接加载操作系统 (嵌入式系统)</li></ul></li></ul></li><li><p>Firmware 负责加载操作系统: BIOS vs UEFI<br>Legacy BIOS 把第一个可引导设备的第一个 512 字节加载到物理内存的 7c00 位置<br>此时处理器处于 16-bit 模式。</p></li><li><p>我们构造一个 512 字节的 “Master Boot Record” 作为磁盘镜像装在在模拟器上，并且用 gdb 观察指令在处理器上的执行。</p></li></ul><p>如何验证这一点？<br>计算机系统公理：你想到的就一定有人做到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asm">#define SECT_SIZE  512<br><br>.code16  // 16-bit assembly<br><br>// Entry of the code<br>.globl _start<br>_start:<br>  lea   (msg), %si   // R[si] = &amp;msg;<br><br>again:<br>  movb  (%si), %al   // R[al] = *R[si]; &lt;--+<br>  incw  %si          // R[si]++;           |<br>  orb   %al, %al     // if (!R[al])        |<br>  jz    done         //   goto done; --+   |<br>  movb  $0x0e, %ah   // R[ah] = 0x0e;  |   |<br>  movb  $0x00, %bh   // R[bh] = 0x00;  |   |<br>  int   $0x10        // bios_call();   |   |<br>  jmp   again        // goto again; ---+---+<br>                     //                |<br>done:                //                |<br>  jmp   .            // goto done; &lt;---+<br><br>// Data: const char msg[] = &quot;...&quot;;<br>msg:<br>  .asciz &quot;This is a baby step towards operating systems!\r\n&quot;<br><br>// Magic number for bootable device<br>.org SECT_SIZE - 2<br>.byte 0x55, 0xAA<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">mbr.img: mbr.S</span><br>gcc -ggdb -c <span class="hljs-variable">$&lt;</span><br>ld mbr.o -Ttext 0x7c00<br>objcopy -S -O binary -j .text a.out <span class="hljs-variable">$@</span><br><br><span class="hljs-section">run: mbr.img</span><br>qemu-system-x86_64 <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">debug: mbr.img</span><br>qemu-system-x86_64 -s -S <span class="hljs-variable">$&lt;</span> &amp;  <span class="hljs-comment"># Run QEMU in background</span><br>gdb -x init.gdb  <span class="hljs-comment"># RTFM: gdb (1)</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.img *.o a.out<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs init.gdb"># Kill process (QEMU) on gdb exits<br>define hook-quit<br>  kill<br>end<br><br># Connect to remote<br>target remote localhost:1234<br>file a.out<br>break *0x7c00<br>layout src<br>continue<br></code></pre></td></tr></table></figure><blockquote><p>前三行命令定义了一个名为 hook-quit 的 GDB 钩子。当用户在 GDB 中执行 quit 命令时，GDB 将自动执行 hook-quit 钩子中定义的命令。在这个例子中，hook-quit 钩子中只有一条命令 kill，它的作用是在用户退出 GDB 时杀死正在被调试的进程。这样可以确保在退出 GDB 后，被调试的进程也会被终止，避免出现进程僵死等问题。</p></blockquote><ul><li>如何用 gdb 调试 qemu<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">qemu-<span class="hljs-keyword">system</span>-x86_64 -s -S mbr.img<br></code></pre></td></tr></table></figure>-S： 把CPU暂停下来<br>-s： shorthand for -gdb tcp::1234       监听1234的端口</li></ul><p>所以我们可以启动一个 gdb </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span><br><span class="hljs-attribute">target</span> remote localhost::<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>这样就可以在gdb中调试这个qemu模拟器了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用和UNIX Shell</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ul><li>Shell</li><li>xv6 shell 代码讲解</li></ul><h3 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell"></a>什么是 shell</h3><ul><li>os &#x3D; API + 对象<blockquote><p>人不可能直接使用系统调用来使用操作系统，所以人和操作系统之间隔了一个应用程序，这个应用程序就叫 shell。shell 把内核的 API 和对象做一层封装，来帮助用户管理操作系统对象的一个<strong>应用程序</strong> 。<br>有 graphic shell 和 command line shell。</p></blockquote></li></ul><h3 id="shell-编程语言"><a href="#shell-编程语言" class="headerlink" title="shell 编程语言"></a>shell 编程语言</h3><ul><li>基于文本替换的快速工作流搭建<blockquote><p>再把 shell 命令构建成一棵树，解释为一组系统调用。</p></blockquote></li></ul><ol><li>重定向: cmd &gt; file &lt; file 2&gt; &#x2F;dev&#x2F;null</li><li>顺序结构: cmd1; cmd2, cmd1 &amp;&amp; cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量&#x2F;环境变量、控制流……</li></ol><ul><li>Job control<br>类比窗口管理器里的 “叉”、“最小化”<br>jobs, fg, bg, wait<br>(今天的 GUI 并没有比 CLI 多做太多事)<blockquote><p>例如用 jobs 查看所有的进程，用 fg 命令使该进程变成前台进程等等。</p></blockquote></li></ul><h3 id="复刻经典"><a href="#复刻经典" class="headerlink" title="复刻经典"></a>复刻经典</h3><p>一个简单地 shell 的实现<br>推荐阅读网站源代码。</p><h3 id="管道的一些细节"><a href="#管道的一些细节" class="headerlink" title="管道的一些细节"></a>管道的一些细节</h3><ul><li>在gdb中如何调试会产生子进程(多进程)的程序？</li></ul><ol><li>set follow-fork-mode child<blockquote><p>这可以在 fork 后直接切到子进程执行流。</p></blockquote></li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> follow-fork-mode <span class="hljs-comment">child</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">detach-on-fork off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">follow-exec-mode same</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">confirm off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">pagination off</span><br>source <span class="hljs-comment">visualize.py</span><br>break <span class="hljs-comment">_start</span><br>run<br>n <span class="hljs-comment">2</span><br>define <span class="hljs-comment">hook-stop</span><br>    pdump<br>end<br></code></pre></td></tr></table></figure><ol start="2"><li><p>info inferiors 命令查看 gdb中的进程</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Num  <span class="hljs-keyword">Description</span>       Executable<br><span class="hljs-number">1</span>    process <span class="hljs-number">1234</span>      <span class="hljs-regexp">/path/</span>to/parent<br><span class="hljs-number">2</span>    process <span class="hljs-number">5678</span>      <span class="hljs-regexp">/path/</span>to/child<br></code></pre></td></tr></table></figure></li><li><p>inferior 命令切换进程</p><blockquote><p>例如 inferior 1</p></blockquote></li></ol><ul><li><p>利用好工具，定制化的gdb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        <span class="hljs-built_in">print</span>()<br>    <br>        <span class="hljs-keyword">for</span> proc <span class="hljs-keyword">in</span> gdb.inferiors():<br>            pid = proc.pid<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(pid) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>    <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process <span class="hljs-subst">&#123;proc.num&#125;</span> (<span class="hljs-subst">&#123;pid&#125;</span>)&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">if</span> proc <span class="hljs-keyword">is</span> gdb.selected_inferior():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>()<br>    <br>            <span class="hljs-keyword">for</span> fd_desc <span class="hljs-keyword">in</span> subprocess.check_output(<br>                [<span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-string">&#x27;-l&#x27;</span>, <span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/fd&#x27;</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>            ).splitlines()[<span class="hljs-number">1</span>:]:<br>                perm, *_, fd, _, fname = fd_desc.split()<br>    <br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;rw&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;-&gt;&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;r&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;--&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;w&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;--&gt;&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;pipe:&#x27;</span> <span class="hljs-keyword">in</span> fname:<br>                    pipe_id = re.search(<span class="hljs-string">f&#x27;[0-9]+&#x27;</span>, fname).group()<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> [=== <span class="hljs-subst">&#123;pipe_id&#125;</span> ===]&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> <span class="hljs-subst">&#123;fname&#125;</span>&#x27;</span>)<br><br>ProcDump()<br><br><br></code></pre></td></tr></table></figure><blockquote><p>这个类继承自gdb.Command类，这个类是一个GDB命令的基类，用于创建新的GDB命令。在这个类的构造函数中，调用了父类的构造函数，并传入了三个参数，分别是”pdump”，gdb.COMMAND_DATA和gdb.COMPLETE_SYMBOL。其中，”pdump”是命令名称，gdb.COMMAND_DATA表示这是一个处理数据的命令，gdb.COMPLETE_SYMBOL表示这个命令需要在符号表中进行自动补全。<br>在你的代码中，你需要在ProcDump类中实现一个名为invoke的方法，这个方法将会被调用来执行pdump命令的实际功能。</p></blockquote></li><li><p>init.gdb脚本<br>init.gdb脚本是一个GDB初始化脚本，它会在GDB启动时自动执行。你可以在这个脚本中设置GDB的一些默认行为，例如设置别名、定义宏、加载符号表等。这个脚本可以包含任意数量的GDB命令，它们会按照在脚本中出现的顺序依次执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">gdb +x <span class="hljs-keyword">init</span>.gdb a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 &#x2F;dev&#x2F;pts ?</p><blockquote><p>&#x2F;dev&#x2F;pts是一个特殊的文件系统，它提供了一个伪终端（pseudo-terminal）接口，允许用户与计算机进行交互。当用户登录到计算机时，系统会为该用户分配一个伪终端，这个伪终端就会在&#x2F;dev&#x2F;pts目录下创建一个对应的设备文件。</p></blockquote></li></ul><p>echo hello &gt; &#x2F;dev&#x2F;pts&#x2F;8 会发生什么</p><blockquote><p>会在相应终端产生输出。使用 tty 命令可以查看当前 shell 终端对应的终端文件是哪一个。</p></blockquote><ul><li><p>说明<br>由于这里文件描述符的应用我在 MIT 6.S081 中的实验1中实现过类似的，所以在这里不再详细地描述调代码的细节。</p></li><li><p>关于 va_list</p><ol><li>va_start sets arg_ptr to the first optional argument in the list of arguments that’s passed to the function.</li><li>va_arg retrieves a value of type from the location that’s given by arg_ptr, and increments arg_ptr to point to the next argument in the list by using the size of type to determine where the next argument starts. </li><li>va_end resets the pointer to NULL</li></ol></li></ul><p>是不是似乎好像会实现 printf 函数了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统API</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FAPI/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FAPI/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入输出设备模型</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器"><a href="#IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器" class="headerlink" title="IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器"></a>IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器</h3><ul><li>就是“几组约定好功能的线”，通过握手信号从线上读出&#x2F;写入数据</li><li>每一组线都有自己的地址<blockquote><p>CPU可以直接使用指令(in&#x2F;out&#x2F;MMIO)和设备交换数据<br>CPU不管设备具体是如何实现的</p></blockquote></li></ul><h3 id="总线、中断控制器和DMA"><a href="#总线、中断控制器和DMA" class="headerlink" title="总线、中断控制器和DMA"></a>总线、中断控制器和DMA</h3><p>越来越多的IO设备，如何给未来留出一点空间？</p><ul><li>CPU只直接连接一个设备，这个IO设备实际上是一块板卡，板卡上有很多个小插槽(寄存器)。这个IO设备负责管理其他IO设备，这个设备就叫做总线。</li><li>甚至这个IO设备做得更彻底一点，我们的内存也连接在这个总线上，同一个地址空间，CPU只需要一个地址，就可以知道访问的是内存还是IO设备(统一编址)。</li></ul><h3 id="中断没能解决的"><a href="#中断没能解决的" class="headerlink" title="中断没能解决的"></a>中断没能解决的</h3><p>假设程序希望写入1GB的数据到磁盘</p><ul><li>即使磁盘已经准备好了，依然需要非常浪费时间的循环。<blockquote><p>DMA的出现：一个专门执行”memcpy”程序的CPU<br>通过增加一个CPU专门负责从内存到总线的数据搬运<br>memory-&gt;memory     device-&gt;memory    memory-&gt;device</p></blockquote></li></ul><h3 id="IO设备和计算机之间的边界逐渐模糊"><a href="#IO设备和计算机之间的边界逐渐模糊" class="headerlink" title="IO设备和计算机之间的边界逐渐模糊"></a>IO设备和计算机之间的边界逐渐模糊</h3><p>DMA不就是一个“只做一件特别事情的”CPU吗</p><ul><li>那么我们还可以有做各种事情的”CPU”啊, 例如显卡</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设备驱动程序</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课的主要内容"><a href="#本次课的主要内容" class="headerlink" title="本次课的主要内容"></a>本次课的主要内容</h2><ul><li>什么是设备驱动程序</li><li>Linux设备抽象</li></ul><h3 id="设备驱动程序原理"><a href="#设备驱动程序原理" class="headerlink" title="设备驱动程序原理"></a>设备驱动程序原理</h3><ul><li>设备其实是一组寄存器和一组协议，一个设备，一个协议</li></ul><p>设备可以分为两种</p><ol><li>字符设备：字节流，例如键盘</li><li>块设备：字节数组，例如磁盘</li></ol><h3 id="操作系统：设备-支持各类操作的对象（文件）"><a href="#操作系统：设备-支持各类操作的对象（文件）" class="headerlink" title="操作系统：设备&#x3D;支持各类操作的对象（文件）"></a>操作系统：设备&#x3D;支持各类操作的对象（文件）</h3><ul><li>read: 从设备某个指定的位置读出数据</li><li>write：向设备某个位置写入数据</li><li>ioctl: 读取&#x2F;设置设备的状态, ioctl是一个系统调用<br>上面为设备建立一个模型       <blockquote><p>也就是说，把上面这三个系统调用，也就是通用的API，经过设备驱动程序，翻译成设备能够听得懂的语言, 这段代码就是设备驱动程序。</p></blockquote></li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>把系统调用“翻译”成与设备寄存器的交互</p><ul><li>就是一段普通的内核代码</li><li>有可能这个设备驱动程序后面就是一个真实的设备，有可能没有设备，就是用设备驱动程序来模拟这个设备</li></ul><p>例如：&#x2F;dev&#x2F;中的对象</p><ol><li>&#x2F;dev&#x2F;null   null设备</li><li>&#x2F;dev&#x2F;random   随机数生成器</li></ol><h3 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h3><p>我们希望实现一个最简单的“软件定义核弹”</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核线程与进程、进程API</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="虚拟化：操作系统同时保存多个状态机"><a href="#虚拟化：操作系统同时保存多个状态机" class="headerlink" title="虚拟化：操作系统同时保存多个状态机"></a>虚拟化：操作系统同时保存多个状态机</h3><p>C程序 &#x3D; 状态机</p><ul><li>初始状态： main(argc, argv)</li><li>状态迁移： 指令的执行，包括syscall</li></ul><p>实际上，在 UNIX&#x2F;Linux 系统内核完成初始化后，只有一个 init 进程被启动，从此以后，操作系统内核就化身为了一个事件驱动的程序、状态机的管理者，仅在中断和系统调用发生时开始执行。</p><p>下面看一段小代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写出代码的运行结果。</p></blockquote><ul><li>.&#x2F;a.out</li><li>.&#x2F;a.out | cat</li></ul><ol><li>当执行.&#x2F;a.out时，会打印 6 个 Hello</li><li>当执行.&#x2F;a.out | wc -l 时，会打印 8 个 Hello ? 这是为什么呢？</li></ol><p>不妨用 strace 来看一下。<br>我们发现，</p><blockquote><p>我们的 printf 不总是打印到标准输出的。也就是说它根据标准输出连接的是终端还是管道，它会做不同的行为，这里连接到了管道，也就把输出放到一个缓冲区里面 。当第一个循环之后，缓冲区里面有一个 hello，有两个进程；第二次循环完毕后，缓冲区里面有 2 个 hello, 总共 4 个进程。所以打印 8 个。 </p></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>应用程序执行的环境。</p><ul><li>export: 告诉shell在创建子进程的时候设置环境变量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可执行程序</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="可执行文件：状态机的描述"><a href="#可执行文件：状态机的描述" class="headerlink" title="可执行文件：状态机的描述"></a>可执行文件：状态机的描述</h2><h3 id="一个描述了状态机初始状态-迁移的数据结构"><a href="#一个描述了状态机初始状态-迁移的数据结构" class="headerlink" title="一个描述了状态机初始状态 + 迁移的数据结构"></a>一个描述了状态机初始状态 + 迁移的<font color=#FF000 >数据结构</font></h3><ol><li>寄存器：大部分由ABI规定，操作系统负责设置。例如初始化pc。</li><li>地址空间：二进制文件+ABI共同决定。例如argv和envp的存储。</li><li>其他有用的信息（例如调试和core dump的信息）</li></ol><hr><h2 id="可执行文件里面应该有什么？"><a href="#可执行文件里面应该有什么？" class="headerlink" title="可执行文件里面应该有什么？"></a>可执行文件里面应该有什么？</h2><p>可执行程序描述了状态机重置后的状态，那状态有什么呢？</p><blockquote><p>无非就是寄存器和内存（地址空间）</p></blockquote><hr><h2 id="操作系统上的可执行程序"><a href="#操作系统上的可执行程序" class="headerlink" title="操作系统上的可执行程序"></a>操作系统上的可执行程序</h2><p>需要满足以下条件：</p><ol><li><p>具有执行(x)权限<br>执行.&#x2F;a.c命令 (出现permission denied错误)<br>但如果先执行 chmod +x a.c命令，会出现加载器不能正确识别题。    </p></li><li><p>加载器能够识别的可执行文件</p></li></ol><hr><h2 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h2><blockquote><p>就是操作系统里面的一个普通对象。</p></blockquote><h3 id="UNIX-Linux"><a href="#UNIX-Linux" class="headerlink" title="UNIX&#x2F;Linux"></a>UNIX&#x2F;Linux</h3><ul><li>a.out</li><li>ELF</li><li>She-bang<blockquote><p>She-bang是什么呢？其实就是一个“偷换参数”地execve。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">#!/usr/bin/python3               #这是一个可执行文件<br>print(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再执行命令 chmod +x a.c。上面这个文件就可以执行了。<br>如果加载器这样一个程序的时候，如果它发现一个#!开头的，就会在execve偷换一下，把#!后面的填入execve的第一个参数，该文件名填入第二个参数。</p><hr><h2 id="从C代码到二进制文件"><a href="#从C代码到二进制文件" class="headerlink" title="从C代码到二进制文件"></a>从C代码到二进制文件</h2><p>一段简单的C代码(main.c)：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    hello();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>gcc -O2 -c main.c得到main.o文件, 然后objdump -d main.o得到反汇编 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-number">0</span>:   f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa             endbr64 <br>   <span class="hljs-number">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>             sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">8</span>:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>   a:   e8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   f &lt;main+<span class="hljs-number">0xf</span>&gt;<br>   f:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>  <span class="hljs-number">11</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>             add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">15</span>:   c3                      ret    <br></code></pre></td></tr></table></figure><p>我们可以看到 0xa 地址处，由于不知道hello函数的地址，这里暂时填为 0</p><p>hello.c的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xa</span> + <span class="hljs-number">1</span>;   <span class="hljs-comment">//有上面汇编代码可以看出，代填 </span><br>               <span class="hljs-comment">//hello地址为 main 的地址加上偏移再加上1(操作码1个字节)</span><br>    <span class="hljs-type">int32_t</span> offset = *(<span class="hljs-type">int32_t</span>*)p;<br>    assert( (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xf</span> +offset == (<span class="hljs-type">char</span>*)hello);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下：在我们的main函数要调用hello函数时，此时pc会指向这条call指令的下一条指令的地址，也就是pc指针会是(char*)main + 0xf,由于是相对寻址(call指令的语义)，所以会跳转到pc + offset的位置，offset也就是待填地址处的值。而跳转后的地址要是hello的地址。</p></blockquote><p>我们 readelf -a main.o 来看一下有什么输出信息,其中有一部分是这样的（这里复制过来格式有点不正确）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Relocation</span> section &#x27;.rela.text.startup&#x27; at offset <span class="hljs-number">0</span>x1b8 contains <span class="hljs-number">1</span> entry:<br>  <span class="hljs-attribute">Offset</span>          Info       Type        Sym. Value    Sym. Name+Addend<br><span class="hljs-attribute">00000000000b</span>  <span class="hljs-number">000600000004</span> R_X86_64_PLT32 <span class="hljs-number">0000000000000000</span> hello - <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="重新理解编译、链接流程"><a href="#重新理解编译、链接流程" class="headerlink" title="重新理解编译、链接流程"></a>重新理解编译、链接流程</h2><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><blockquote><p>High-level semantics(高级C状态机) -&gt; Low-level semantics(汇编状态机)</p></blockquote><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><blockquote><p>Low-level semantics -&gt; Binary semantics(状态机的容器)</p></blockquote><ol><li>“一一对应”地翻译成二进制代码，sections, symbols, debug info……</li><li>不能决定的要留下“之后要怎么办”的信息(relocations重定位)</li></ol><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><blockquote><p>合并所有的容器，得到一个完整的状态机</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多处理器编程从入门到放弃</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：多处理器编程：从入门到放弃："><a href="#本讲内容：多处理器编程：从入门到放弃：" class="headerlink" title="本讲内容：多处理器编程：从入门到放弃："></a>本讲内容：多处理器编程：从入门到放弃：</h2><ul><li>入门：多线程编程库</li><li>放弃：原子性、可见性、顺序</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>每个线程都有自己的堆栈，如何确定各自的堆栈大小？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> low[<span class="hljs-number">64</span>];<br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> high[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_range</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">void</span> *ptr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ptr &lt; low[T]) low[T] = ptr;<br>    <span class="hljs-keyword">if</span> (ptr &gt; high[T]) high[T] = ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">probe</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">int</span> n)</span> &#123;<br>  update_range(T, &amp;n);<br>  <span class="hljs-type">long</span> sz = (<span class="hljs-type">uintptr_t</span>)high[T] - (<span class="hljs-type">uintptr_t</span>)low[T];<br>  <span class="hljs-keyword">if</span> (sz % <span class="hljs-number">1024</span> &lt; <span class="hljs-number">32</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack(T%d) &gt;= %ld KB\n&quot;</span>, T, sz / <span class="hljs-number">1024</span>);<br>  &#125;<br>  probe(T, n + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Infinite recursion</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tprobe</span><span class="hljs-params">(<span class="hljs-type">int</span> T)</span> &#123;<br>  low[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;<br>  high[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>  update_range(T, &amp;T);<br>  probe(T, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    create(Tprobe);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要 setbuf(stdout, NULL) 关闭缓冲区？</p><blockquote><p>有时候一个printf明明在crash前的代码运行了，但没有得到输出，原因是什么呢？<br>是因为printf先把输出放在缓冲区里。</p></blockquote><p>这段代码的核心思想就是无穷递归，利用函数参数存储在栈空间里估算栈的大小。</p><h2 id="放弃：原子性"><a href="#放弃：原子性" class="headerlink" title="放弃：原子性"></a>放弃：原子性</h2><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100000000</span><br><br><span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tsum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    sum++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  create(Tsum);<br>  create(Tsum);<br>  join();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %ld\n&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译优化 -O2得到答案 200000000</p><blockquote><p>编译器直接计算出答案，一条指令赋值给sum</p></blockquote><p>编译优化 -O1得到答案 100000000</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接和加载(2)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="动态链接与加载原理"><a href="#动态链接与加载原理" class="headerlink" title="动态链接与加载原理"></a>动态链接与加载原理</h2><h3 id="若干要素"><a href="#若干要素" class="headerlink" title="若干要素"></a>若干要素</h3><ol><li>编译成位置无关代码</li><li>对外部函数的调用是查表的</li><li>在运行（加载）的时候填表</li></ol><p>我们就发明了GOT(Global Offset Table)</p><blockquote><p>也就是table </p></blockquote><h3 id="有个有趣的问题"><a href="#有个有趣的问题" class="headerlink" title="有个有趣的问题"></a>有个有趣的问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>; <br></code></pre></td></tr></table></figure><p>编译器遇到函数调用，应该翻译成哪种指令？</p><ul><li>如果是同一个动态链接库    call foo   (因为如果是一个库的，链接的时候相对地址已经确定下来了)</li><li>如果是另外一个动态链接库  call TABLE(foo)</li></ul><p>这就需要PLT (Procedure Linkage Table)       </p><ul><li>函数太多，每个都标记区分太难看</li><li>编译器总是生成一个直接的call<blockquote><p>来自另一个动态链接库     call foo@plt            </p></blockquote></li></ul><h3 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h3><p>对于一个动态链接的二进制文件，execve后的第一条指令在哪里？</p><ul><li>what are the first a few steps executed after execve() of a ELF dynamic link binary?  (Chatgpt)</li></ul><blockquote><p>第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2   _start函数<br>也就是说，刚刚执行玩execve后，我们的pc指针指向了ld.so中的代码。</p></blockquote><ol><li>首先会加载这个ELF文件，把相关的段加载进地址空间中。</li><li>内核会根据查看程序头表(program header)中的PT_INTERP的判断是否需要动态链接。如果需要，内核就会把动态链接器(通常来说是ld-linux.so)加载进进程的地址空间中。</li><li>设置栈的初始状态。</li><li>把控制交给动态链接器：内核把pc指针设置为动态链接器的入口地址。</li><li>动态链接器的初始化，解析符号，重定位等。</li><li>把控制权交给程序(通常来说是_start函数)</li></ol><ul><li>How can I compile an ELF binary that use an alternative dynamic loader than the default ld.so?（能否替换这个加载器） <blockquote><p>gcc -o hello hello.c -Wl, –dynamic-linker&#x3D;&#x2F;path&#x2F;to&#x2F;my_ld.so<br>readelf -l hello | grep “program interpreter” 查看可执行文件的动态链接器</p></blockquote></li></ul><p>示例代码<br>ld.S  ——  将来链接成动态链接库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br>.globl _start<br>_start:<br>  movq $SYS_write, %rax   <span class="hljs-comment">// write(</span><br>  movq $<span class="hljs-number">1</span>,         %rdi   <span class="hljs-comment">//   fd=1,</span><br>  lea  <span class="hljs-title function_">st</span><span class="hljs-params">(%rip)</span>,   %rsi   <span class="hljs-comment">//   buf=st,</span><br>  movq $<span class="hljs-params">(ed - st)</span>, %rdx   <span class="hljs-comment">//   count=ed-st</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>  movq $SYS_exit,  %rax   <span class="hljs-comment">// exit(</span><br>  movq $1,         %rdi   <span class="hljs-comment">//   status=1</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>st:<br>  .ascii &quot;\033[01;<span class="hljs-number">31</span>mThis is a loader.\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m\n<span class="hljs-string">&quot;</span><br><span class="hljs-string">ed:</span><br></code></pre></td></tr></table></figure><p>hello.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld<span class="hljs-selector-class">.so</span>: ld<span class="hljs-selector-class">.S</span> hello<span class="hljs-selector-class">.c</span><br>gcc -fPIC -shared -c ld<span class="hljs-selector-class">.S</span><br>ld -shared ld<span class="hljs-selector-class">.o</span> -o ld<span class="hljs-selector-class">.so</span><br>gcc hello<span class="hljs-selector-class">.c</span> -Wl,<span class="hljs-attr">--dynamic-linker</span>=$(PWD)/ld.so<br></code></pre></td></tr></table></figure><ul><li>当我们输入make指令并执行 .&#x2F;a.out 时，我们看到，我们并没有输出Hello,而是输出了This is a loader. 这也就说明了我们的动态链接器确实换掉了，由于hello.c是动态链接的，所以内核会加载我们自己的动态链接器并执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接和加载(1)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课要回答的问题"><a href="#本次课要回答的问题" class="headerlink" title="本次课要回答的问题"></a>本次课要回答的问题</h2><ol><li>可执行文件是如何被操作系统加载的</li><li>什么是动态链接&#x2F;动态加载</li></ol><h2 id="静态ELF加载器：实现"><a href="#静态ELF加载器：实现" class="headerlink" title="静态ELF加载器：实现"></a>静态ELF加载器：实现</h2><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><ol><li>解析数据结构 + 复制到内存 + 跳转</li><li>创建进程运行时的初始状态(argv,envp,…)</li></ol><h3 id="loader-static-c"><a href="#loader-static-c" class="headerlink" title="loader-static.c"></a>loader-static.c</h3><ol><li>可以加载任何静态链接的代码, minimal.S, dfs-fork.c</li><li>并可以正确处理参数&#x2F;环境变量 env.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STK_SZ           (1 &lt;&lt; 20)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROUND(x, align)  (void *)(((uintptr_t)x) &amp; ~(align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD(x, align)    (((uintptr_t)x) &amp; (align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> push(sp, T, ...) (&#123; *((T*)sp) = (T)__VA_ARGS__; sp = (void *)((uintptr_t)(sp) + sizeof(T)); &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">execve_</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-comment">// WARNING: This execve_ does not free process resources.</span><br>  <span class="hljs-type">int</span> fd = open(file, O_RDONLY);<br>  assert(fd &gt; <span class="hljs-number">0</span>);<br>  Elf64_Ehdr *h = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  assert(h != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>  assert(h-&gt;e_type == ET_EXEC &amp;&amp; h-&gt;e_machine == EM_X86_64);<br><br>  Elf64_Phdr *pht = (Elf64_Phdr *)((<span class="hljs-type">char</span> *)h + h-&gt;e_phoff);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;e_phnum; i++) &#123;<br>    Elf64_Phdr *p = &amp;pht[i];<br>    <span class="hljs-keyword">if</span> (p-&gt;p_type == PT_LOAD) &#123;<br>      <span class="hljs-type">int</span> prot = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_R) prot |= PROT_READ;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_W) prot |= PROT_WRITE;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_X) prot |= PROT_EXEC;<br>      <span class="hljs-type">void</span> *ret = mmap(<br>        ROUND(p-&gt;p_vaddr, p-&gt;p_align),              <span class="hljs-comment">// addr, rounded to ALIGN</span><br>        p-&gt;p_memsz + MOD(p-&gt;p_vaddr, p-&gt;p_align),   <span class="hljs-comment">// length</span><br>        prot,                                       <span class="hljs-comment">// protection</span><br>        MAP_PRIVATE | MAP_FIXED,                    <span class="hljs-comment">// flags, private &amp; strict</span><br>        fd,                                         <span class="hljs-comment">// file descriptor</span><br>        (<span class="hljs-type">uintptr_t</span>)ROUND(p-&gt;p_offset, p-&gt;p_align)); <span class="hljs-comment">// offset</span><br>      assert(ret != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(p-&gt;p_vaddr + p-&gt;p_filesz), <span class="hljs-number">0</span>, p-&gt;p_memsz - p-&gt;p_filesz);<br>    &#125;<br>  &#125;<br>  close(fd);<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STK_SZ], rnd[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">void</span> *sp = ROUND(<span class="hljs-built_in">stack</span> + <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>) - <span class="hljs-number">4096</span>, <span class="hljs-number">16</span>);<br>  <span class="hljs-type">void</span> *sp_exec = sp;<br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// argc</span><br>  <span class="hljs-keyword">while</span> (argv[argc]) argc++;<br>  push(sp, <span class="hljs-type">intptr_t</span>, argc);<br>  <span class="hljs-comment">// argv[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= argc; i++)<br>    push(sp, <span class="hljs-type">intptr_t</span>, argv[i]);<br>  <span class="hljs-comment">// envp[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (; *envp; envp++) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strchr</span>(*envp, <span class="hljs-string">&#x27;_&#x27;</span>)) <span class="hljs-comment">// remove some verbose ones</span><br>      push(sp, <span class="hljs-type">intptr_t</span>, *envp);<br>  &#125;<br>  <span class="hljs-comment">// auxv[], AT_NULL-terminate</span><br>  push(sp, <span class="hljs-type">intptr_t</span>, <span class="hljs-number">0</span>);<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_RANDOM, .a_un.a_val = (<span class="hljs-type">uintptr_t</span>)rnd &#125; );<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_NULL &#125; );<br><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov $0, %%rdx;&quot;</span> <span class="hljs-comment">// required by ABI</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov %0, %%rsp;&quot;</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;jmp *%1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span>(sp_exec), <span class="hljs-string">&quot;b&quot;</span>(h-&gt;e_entry))</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s file [args...]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  execve_(argv[<span class="hljs-number">1</span>], argv + <span class="hljs-number">1</span>, envp);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下我们这里的loader(它是动态链接的): 给我们的loader传入一个参数,它执行到某一个状态的时候，把我们的ELF文件(argv[1])搬到我们的loader程序的状态上,相当于我们的程序被替换了,但这个过程并没有执行execve,只是简单地用mmap系统调用(当然操作系统加载loader这个程序的时候会用execve)。</p></blockquote></li></ol><h3 id="初始化堆栈"><a href="#初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><p>状态机是well-defined的。</p><table><thead><tr><th>表头</th><th>表头</th><th>长度(字节)</th></tr></thead><tbody><tr><td>其他信息</td><td></td><td>未知</td></tr><tr><td>Null auxiliary vector entry</td><td></td><td>1 eightbyte each</td></tr><tr><td>Auxiliary vector entries</td><td></td><td>2 eightbytes each</td></tr><tr><td>0</td><td></td><td>8</td></tr><tr><td>Environment pointers</td><td></td><td>8 bytes each</td></tr><tr><td>0</td><td>8 + 8*argc + %rsp</td><td>8</td></tr><tr><td>Argument pointers</td><td>8 + %rsp</td><td>argc 8</td></tr><tr><td>Argument count</td><td>%rsp</td><td>8</td></tr><tr><td>Undefined</td><td>Low Address</td><td></td></tr></tbody></table><h3 id="有趣之处"><a href="#有趣之处" class="headerlink" title="有趣之处"></a>有趣之处</h3><blockquote><p>这是在操作系统上实现的。用 open , mmap, close实现了一个 execve。     </p></blockquote><hr><h2 id="动态链接和加载"><a href="#动态链接和加载" class="headerlink" title="动态链接和加载"></a>动态链接和加载</h2><h3 id="为什么要动态加载"><a href="#为什么要动态加载" class="headerlink" title="为什么要动态加载"></a>为什么要动态加载</h3><ol><li>减少库函数的磁盘和内存拷贝</li></ol><ul><li>每个可执行文件里面都有所有的库函数拷贝那也太浪费了</li><li>只要遵守约定，不挑战库函数的版本(否则发布一个新版本就要重新编译全部程序)</li></ul><h3 id="这就有了”拆解应用程序”的需求"><a href="#这就有了”拆解应用程序”的需求" class="headerlink" title="这就有了”拆解应用程序”的需求"></a>这就有了”拆解应用程序”的需求</h3><blockquote><p>随着库函数越来越大，希望项目能够运行时链接。</p></blockquote><h3 id="动态链接，但不讲ELF-换一种方法。"><a href="#动态链接，但不讲ELF-换一种方法。" class="headerlink" title="动态链接，但不讲ELF,换一种方法。"></a>动态链接，但不讲ELF,换一种方法。</h3><ul><li>如果编译器、链接器、加载器都受你控制</li><li>那你怎么设计实现一个“最直观”的动态链接格式？</li><li>如何改进，就得到了ELF！</li><li>假设编译器可以为你生成位置无关代码(PIC)</li></ul><h3 id="来看一下蒋神的设计-main-part"><a href="#来看一下蒋神的设计-main-part" class="headerlink" title="来看一下蒋神的设计(main part)"></a>来看一下蒋神的设计(main part)</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul><li>dl.h(数据结构定义)</li></ul><h4 id="全家桶工具集"><a href="#全家桶工具集" class="headerlink" title="全家桶工具集"></a>全家桶工具集</h4><ul><li>dlbox.c(gcc, readdl, objdump, interp)</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>libc.S - 提供 putchar 和 exit</li><li>libhello.S - 调用 putchar, 提供 hello</li><li>main.S - 调用 hello, 提供 main</li></ul><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o dlbox dlbox<span class="hljs-selector-class">.c</span><br>./dlbox gcc libc<span class="hljs-selector-class">.S</span><br>./dlbox gcc libhello<span class="hljs-selector-class">.S</span><br>./dlbox gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.S</span><br>./dlbox readdl libc<span class="hljs-selector-class">.dl</span>         <span class="hljs-comment">//readelf</span><br></code></pre></td></tr></table></figure><blockquote></blockquote><p>会生成.dl格式的自定义可执行文件。这个可执行文件是不可以在操作系统上执行，需要自己的加载器。<br>并且我们的加载器是在当前目录中动态加载.dl文件(根据)的，如果先前没有生成所需要的.dl文件的话，我们的加载器会出现错误。</p><blockquote></blockquote><h4 id="演示一下下"><a href="#演示一下下" class="headerlink" title="演示一下下"></a><strong>演示一下下</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br>DL_HEAD<br><br><span class="hljs-title function_">LOAD</span><span class="hljs-params">(<span class="hljs-string">&quot;libc.dl&quot;</span>)</span><br><span class="hljs-title function_">IMPORT</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br><span class="hljs-title function_">EXPORT</span><span class="hljs-params">(hello)</span><br><br>DL_CODE<br><br>hello:<br>  lea <span class="hljs-title function_">str</span><span class="hljs-params">(%rip)</span>, %rdi<br>  mov <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span>, %eax<br>  push %rbx<br>  mov %rdi, %rbx<br>  inc %eax<br>  mov %eax, <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span><br>  add $0x30, %eax<br>  movb %al, 0<span class="hljs-title function_">x6</span><span class="hljs-params">(%rdi)</span><br>loop:<br>  <span class="hljs-title function_">movsbl</span> <span class="hljs-params">(%rbx)</span>,%edi<br>  test %dil,%dil<br>  je out<br>  call <span class="hljs-title function_">DSYM</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br>  inc  %rbx<br>  jmp loop<br>out:<br>  pop %rbx<br>  ret<br><br>str:<br>  .asciz &quot;Hello X\n&quot;<br><br>count:<br>  .<span class="hljs-type">int</span> 0<br><br>DL_END<br><br></code></pre></td></tr></table></figure><blockquote><p>这个文件需要使用外部的putchar函数,所以需要call DSYM(putchar), DSYM表示动态链接的，也需要手动指明putchar函数所在的库libc.dl。它定义有一个hello函数，所以需要导出。也就是EXPORT(hello).</p></blockquote><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><ol><li><p><strong>首先来看一下dl.h文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REC_SZ 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_MAGIC <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ASSEMBLER__</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_HEAD     __hdr: \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* magic */</span>    .ascii DL_MAGIC; \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* file_sz */</span>  .4byte (__end - __hdr); \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* code_off */</span> .4byte (__code - __hdr)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_CODE     .fill REC_SZ - 1, 1, 0; \</span><br><span class="hljs-meta">                      .align REC_SZ, 0; \</span><br><span class="hljs-meta">                      __code:</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_END      __end:</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> RECORD(sym, off, name) \</span><br><span class="hljs-meta">    .align REC_SZ, 0; \</span><br><span class="hljs-meta">    sym .8byte (off); .ascii name</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPORT(sym) RECORD(sym:,           0, <span class="hljs-string">&quot;?&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPORT(sym) RECORD(    , sym - __hdr, <span class="hljs-string">&quot;#&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOAD(lib)   RECORD(    ,           0, <span class="hljs-string">&quot;+&quot;</span> lib  <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DSYM(sym)   *sym(%rip)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> &#123;</span><br>    <span class="hljs-type">char</span> magic[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">uint32_t</span> file_sz, code_off;<br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> &#123;</span><br>    <span class="hljs-type">int64_t</span> offset;<br>    <span class="hljs-type">char</span> type, name[REC_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int64_t</span>) - <span class="hljs-number">1</span>];<br>  &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><blockquote><ol><li>__ASSEMBLER__是一个内置的宏，它由编译器预定义，用于判断当前代码是否为汇编代码。在编写汇编代码时，编译器会自动定义这个宏。</li><li>怎么用汇编语言定义结构体呢？ 为什么变量名前面要加.呢？这表示这是在当前偏移量下定义的。</li><li>RECORD宏定义：.align REC_SZ, 0 表示将当前位置对齐到 REC_SZ 字节边界。<br>这行代码定义了一个标签 sym，并将 off 表示的偏移量存储到该标签处。.8byte 指令告诉汇编器为该标签分配一个 8 字节的存储空间，即使用一个 64 位无符号整数来存储偏移量。<br>.ascii name 表示将 name 参数表示的记录名称作为 ASCII 字符串嵌入到汇编代码中。.ascii 指令用于将一个字符串常量嵌入到汇编代码中。</li><li>#define DSYM(sym)  这是间接跳转，先将 %rip 寄存器中存储的当前指令地址加上 hello 符号相对于当前指令的偏移量，得到函数地址，然后再根据这个地址的值进行跳转，而符号表结构体前八个字节就是函数的地址。</li></ol></blockquote></li><li><p><strong>dlbox.c文件</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">symtab</span>;</span> <span class="hljs-comment">// borrowed spaces from header</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><br><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br><span class="hljs-comment">// Implementation of binutils</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_readdl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DLIB file %s:\n\n&quot;</span>, h-&gt;path);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    LOAD  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  EXTERN  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: <span class="hljs-built_in">printf</span>(   <span class="hljs-string">&quot;%08lx  %s\n&quot;</span>, sym-&gt;offset, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_objdump</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">char</span> *hc = (<span class="hljs-type">char</span> *)h, cmd[<span class="hljs-number">64</span>];<br>  FILE *fp = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Disassembly of binary %s:\n&quot;</span>, h-&gt;path);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> *code = hc + h-&gt;hdr.code_off; code &lt; hc + h-&gt;hdr.file_sz; code++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>      <span class="hljs-keyword">if</span> (hc + sym-&gt;offset == code) &#123;<br>        <span class="hljs-type">int</span> off = code - hc - h-&gt;hdr.code_off;<br>        <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>        <span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">&quot;ndisasm - -b 64 -o 0x%08x\n&quot;</span>, off);<br>        fp = popen(cmd, <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%016x &lt;%s&gt;:\n&quot;</span>, off, sym-&gt;name);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fp) fputc(*code, fp);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>&#125;<br><br><span class="hljs-comment">// binutils: interpreter</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmd</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd;<br>  <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path);<br>&#125; commands[] = &#123;<br>  &#123; <span class="hljs-string">&quot;gcc&quot;</span>,     dl_gcc &#125;,<br>  &#123; <span class="hljs-string">&quot;readdl&quot;</span>,  dl_readdl &#125;,<br>  &#123; <span class="hljs-string">&quot;objdump&quot;</span>, dl_objdump &#125;,<br>  &#123; <span class="hljs-string">&quot;interp&quot;</span>,  dl_interp &#125;,<br>  &#123; <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-literal">NULL</span> &#125;,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;gcc|readdl|objdump|interp&#125; FILE...\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> cmd *cmd = &amp;commands[<span class="hljs-number">0</span>]; cmd-&gt;handler; cmd++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **path = &amp;argv[<span class="hljs-number">2</span>]; *path &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], cmd-&gt;cmd) == <span class="hljs-number">0</span>; path++) &#123;<br>      <span class="hljs-keyword">if</span> (path != argv + <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>      cmd-&gt;handler(*path);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Implementation of dlopen()</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">libs</span>[16], <span class="hljs-title">syms</span>[128];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(syms[i].name, name) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)syms[i].offset;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(libs); i++) &#123;<br>    <span class="hljs-keyword">if</span> (libs[i] &amp;&amp; <span class="hljs-built_in">strcmp</span>(libs[i]-&gt;name, sym-&gt;name) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// already loaded</span><br>    <span class="hljs-keyword">if</span> (!libs[i]) &#123;<br>      libs[i] = sym;<br>      dlopen(sym-&gt;name); <span class="hljs-comment">// load recursively</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="来解释一下-按顺序-："><a href="#来解释一下-按顺序-：" class="headerlink" title="来解释一下(按顺序)："></a>来解释一下(按顺序)：</h3><ol><li><p>首先需要dl_gcc各.S文件得到.dl。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原来命令行还可以这么写！ 前一句生成64位的位置无关代码，然后再把代码段拷贝成.dl文件。这里主要是一些宏替换，并且由于我们的汇编代码格式是很严格地按照dl_hdr的形式写的，所以我们得到的其实是一个dl_lib的结构体。更直观地来感受一下，我们使用命令gcc -E main.S,得到宏替换展开的文件(如下):</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 0 &quot;main.S&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot; 2</span><br><span class="hljs-comment"># 1 &quot;main.S&quot;</span><br><span class="hljs-comment"># 1 &quot;dl.h&quot; 1</span><br><span class="hljs-comment"># 2 &quot;main.S&quot; 2</span><br><br>__hdr: <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__end - __hdr)</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__code - __hdr)</span><br><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libc.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libhello.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; hello: <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(main - __hdr)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;#&quot;</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><br><span class="hljs-string">.fill</span> 32 - 1, 1, 0; <span class="hljs-string">.align</span> 32, 0; __code:<br><br>main:<br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  movq $0, %rax<br>  ret<br><br>__end:<br></code></pre></td></tr></table></figure><blockquote><p>xxd main.dl命令得到二进制文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dotnetcli">00000000: 0114 0514 e000 0000 c000 0000 0000 0000  ................<br>00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 2b6c 6962 632e 646c  ........+libc.dl<br>00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000040: 0000 0000 0000 0000 2b6c 6962 6865 6c6c  ........+libhell<br>00000050: 6f2e 646c 0000 0000 0000 0000 0000 0000  o.dl............<br>00000060: 0000 0000 0000 0000 3f68 656c 6c6f 0000  ........?hello..<br>00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000080: c000 0000 0000 0000 236d 6169 6e00 0000  ........#main...<br>00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000c0: ff15 9aff ffff ff15 94ff ffff ff15 8eff  ................<br>000000d0: ffff ff15 88ff ffff 48c7 c000 0000 00c3  ........H.......<br></code></pre></td></tr></table></figure><blockquote><p>libc.dl、libhello.dl、hello这三个符号都是填零的。只有main函数已经填上了正确的偏移。<br>可以反推，我们得到的.dl文件的格式是这样的：首先是__hdr头，这里有模数，文件的大小，以及代码段的偏移。 然后是符号表；符号表结束后，再32个字节填0作为分界线，然后是代码段。 妙哇妙哇！原来宏定义还可以这么用！</p></blockquote></li><li><p><strong>然后是dl_interp函数来解释执行</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>找到main函数，exit(entry()) 的作用就是在程序结束时执行 main 函数，并将其返回值作为程序的退出码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>这里要打开.dl文件，并且把这个文件用mmap函数映射到dlbox进程的地址空间，此时其他.dl文件的代码段就会映射到dlbox进程的地址空间中，也就可以确定函数的地址了，这也就和动态链接的链接时绑定思想不谋而合。打开这个可执行程序时，h-&gt;symtab &#x3D; (struct symbol *)((char *)h + REC_SZ);这里是初始化符号表。</li><li>如果遇到.dl作为符号表项(‘+’)，则用dlload递归加载，dlload则是调用dlopen实现的。</li><li>如果遇到符号表项的某一项标记位’?’,表示引用外部符号，我们通过查表dlsym函数来填表。</li><li>可以想象，这是一个递归的过程，递归地填表。如果变量是这个main程序的函数(‘#’),我们直接可以确定该函数的地址。也就是表头的地址加上偏移。</li><li>如果这个符号是个.dl文件，则需要调用dlopen把这个文件整体映射进进程的地址空间(递归)，映射完后，所有符号的地址都会被确定，然后我们就可以遍历来填sym表了。这个sym表记录了所有符号，也是一个结构体，一开始所有的项的name字段初始化为NULL。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>如果这个符号是外部的函数，由于我们先包含.dl的库文件，所以外部符号这时候都会解析完毕，我们就可以直接填入正确的地址。</li><li>上面的思想主要是：我们在装载动态库的时候，我们不像静态链接那样可以知道这个模块是装载在哪个位置的。我们的解决方法是通过间接跳转在本模块的某个位置(这是可以确定的)，这个位置就有这个函数的地址的信息。由于我们都是按模块装载的，所以这一点并不难实现，通过添加一个sym的全局变量结构数组，在每装载一个模块(.dl)时，就把该模块的所有这个模块的export类型的变量全部填入这个sym数组中。<br>然后，有了这个sym数组，就可以开始回填到每个模块的符号表中带有(‘?’)的符号offset字段了。</li></ol></blockquote></li></ol><hr><h3 id="反思与改进-最精彩的部分"><a href="#反思与改进-最精彩的部分" class="headerlink" title="反思与改进(最精彩的部分)"></a><strong>反思与改进(最精彩的部分)</strong></h3><h5 id="一些小缺陷"><a href="#一些小缺陷" class="headerlink" title="一些小缺陷"></a>一些小缺陷</h5><ul><li>存储保护和加载位置。允许将.dl中的一部分以某个指定的权限映射到内存的某个位置—&gt;程序头表</li><li>允许自由指定加载器—&gt;加入INTERP</li><li>空间浪费 —&gt;字符串存储在常量池，统一通过“指针”访问(这也是ELF难读的原因)</li></ul><h5 id="另一个大缺陷"><a href="#另一个大缺陷" class="headerlink" title="另一个大缺陷"></a>另一个大缺陷</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>一种写法，两种情况</p></blockquote><ul><li>来自于其他编译单元(静态链接)</li><li>动态链接库</li></ul><p>例如，有a.o和b.o静态链接再和lib.so动态链接,如果a.o中引用了一个外部符号foo,那么该如何判断这个符号究竟是属于哪个单元呢？如果只是简单地宏替换, call *foo(%rip),但其实这样是效率很低的。</p><h5 id="“发明”PLT-GOT"><a href="#“发明”PLT-GOT" class="headerlink" title="“发明”PLT &amp; GOT"></a>“发明”PLT &amp; GOT</h5><blockquote><p>先编译为相对于%rip的简单的call调用，在链接的时候，如果发现这是一个本单元的符号，直接相对于rip寻址；如果发现这是一个外部(动态链接)库的话，就需要plt这条entry,再把地址填上去。</p></blockquote><blockquote><p>我们的“符号表”就是Global Offset Table(GOT).</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000000011e0</span> &lt;printf@plt&gt;:<br>    <span class="hljs-attribute">11e0</span>:       f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa             endbr64<br>    <span class="hljs-attribute">11e4</span>:       f2 ff <span class="hljs-number">25</span> <span class="hljs-number">7</span>d <span class="hljs-number">2</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span>    bnd jmp *<span class="hljs-number">0</span>x2d7d(%rip)        # <span class="hljs-number">3</span>f68 &lt;printf@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span>&gt;<br>    <span class="hljs-attribute">11eb</span>:       <span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>咦，这条jmp指令不是有点熟悉吗？和我们的DSYM很相似。这不印证了我们的猜想吗？</p></blockquote><h5 id="最后一个问题：数据"><a href="#最后一个问题：数据" class="headerlink" title="最后一个问题：数据"></a>最后一个问题：数据</h5><blockquote><p>不管多少个静态库动态库，但我们的程序只有一个errno,environ,stdout。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux世界中的应用程序(构建最小的Linux)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/</url>
    
    <content type="html"><![CDATA[<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><ul><li><p>加载第一个进程 （init 应用程序）</p><blockquote><p>相当于在操作系统中放置一个位于初始状态的状态机</p></blockquote></li><li><p>包含一些进程可以操纵的操作系统对象</p></li><li><p>然后 Linux 变成一个中断(系统调用)处理程序</p></li></ul><p>systemd为什么是进程树的根 (init 进程并不是 systemd)</p><h2 id="Linux-Kernel-系统调用上的发行版和应用生态"><a href="#Linux-Kernel-系统调用上的发行版和应用生态" class="headerlink" title="Linux Kernel 系统调用上的发行版和应用生态"></a>Linux Kernel 系统调用上的发行版和应用生态</h2><ul><li>系统工具 coreutils, binutils, systemd, ….</li><li>桌面系统 </li><li>应用程序</li></ul><h2 id="构建最小的Linux"><a href="#构建最小的Linux" class="headerlink" title="构建最小的Linux"></a>构建最小的Linux</h2><p>目标：把Linux内核启动起来，把minimal.S的二进制文件加载，打印HelloWorld，然后就退出。</p><p>我们真正的壁垒</p><ol><li>怎么样提出问题</li><li>怎样回答问出的问题</li></ol><p>问题：  我希望用 QEMU 在给定的 Linux 内核完成初始化后，直接执行我自己编写的、静态链接的 init 二进制文件。我应该怎么做？</p><ol><li>需要编译一个静态链接的 init 二进制文件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ gcc -<span class="hljs-keyword">static</span> -o <span class="hljs-keyword">init</span> <span class="hljs-keyword">init</span>.c<br></code></pre></td></tr></table></figure></li><li>创建一个 initramfs 文件系统，其中包含您的 init 二进制文件和任何其他必需的文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">initramfs:<br><span class="hljs-comment"># Copy kernel and busybox from the host system</span><br>@<span class="hljs-built_in">mkdir</span> -p build/initramfs/bin<br>sudo bash -c <span class="hljs-string">&quot;cp /boot/vmlinuz build/ &amp;&amp; chmod 666 build/vmlinuz&quot;</span><br><span class="hljs-built_in">cp</span> init build/initramfs/<br><span class="hljs-built_in">cp</span> $(shell <span class="hljs-built_in">which</span> busybox) build/initramfs/bin/<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>什么是 cpio </p><blockquote><p>cpio 是一个类似于 tar 的工具，用于创建和提取归档文件。最终，归档文件将输出到名为 initramfs.cpio 的文件中。这个命令通常用于创建一个自定义的 initramfs 文件系统，以便在启动时加载自定义的软件和配置文件。</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> build/initramfs &amp;&amp; \<br>find . -print0 \<br>| cpio <span class="hljs-params">--null</span> -ov <span class="hljs-params">--format=newc</span> \<br>| gzip -9 &gt; <span class="hljs-string">../initramfs.cpio.gz</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 initramfs</p><blockquote><p>initramfs 是一个临时文件系统，它被加载到内存中，以便在 Linux 内核初始化后提供一个初始根文件系统。这个临时的根文件系统在根文件系统挂载之前执行必要的初始化任务。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-initrd build/initramfs.cpio.gz<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>然后，您需要在 QEMU 中将 initramfs 文件系统加载到内存中，并将 init 二进制文件设置为 init 进程。您可以使用以下命令启动 QEMU：<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">run:<br><span class="hljs-comment"># Run QEMU with the installed kernel and generated initramfs</span><br>qemu-system-x86_64 <span class="hljs-string">\</span><br>  -serial mon:stdio <span class="hljs-string">\</span><br>  -kernel build/vmlinuz <span class="hljs-string">\</span><br>  -initrd build/initramfs.cpio.gz <span class="hljs-string">\</span><br>  -machine accel=kvm:tcg <span class="hljs-string">\</span><br>  -append <span class="hljs-string">&quot;console=ttyS0 quiet rdinit=$(INIT)&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>rdinit&#x3D;init 是一个内核命令行参数，用于指定内核启动后应该运行哪个程序作为根文件系统的初始化进程。在 Linux 系统中，init 进程是所有进程的祖先进程，负责启动系统中的各种服务和进程。rdinit&#x3D;init 参数告诉内核在启动时运行名为 init 的程序作为 init 进程，这通常是指在 initramfs 文件系统中的程序。<br>如果这个init进程中途结束退出了的话，例如把这个init进程换成我们的一个minimal.S(简单的打印后退出)，那么由于init进程结束，系统会panic。init进程有着特殊的作用。</p></blockquote></li></ol><ul><li>什么是busybox<blockquote><p>Busybox是一个开源工具集，集成了许多常用的Unix工具，如ls、cat、grep、find等，可以在嵌入式系统中提供命令行界面的支持。Busybox的目标是提供一个小巧、高效的Unix工具集。</p></blockquote></li></ul><ol><li>busybox sh 就变成一个 shell</li><li>busybox ls 就执行 ls 命令</li></ol><ul><li>busybox 可以看成Linux所有程序的一个打包</li></ul><ul><li><p>init 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (2) Run a shell on the init console</span><br><span class="hljs-variable">$BB</span> sh<br></code></pre></td></tr></table></figure><p>把 init 程序换成这个脚本后，系统启动没有 kernel panic了。<br>make run启动后，得到了一个Linux的终端，但输入 ls 命令是没有反应的。</p><blockquote><p>回想一下：系统在启动以后，只有 init 和 busybox，系统并不认识 ls 命令。可以 &#x2F;bin&#x2F;busybox ls。</p></blockquote></li><li><p>那应该怎么办？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (3) Rock&#x27;n Roll!</span><br><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-variable">$BB</span> sh<br><br><span class="hljs-built_in">mkdir</span> -p /tmp<br><span class="hljs-built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc  none /proc<br><span class="hljs-built_in">mkdir</span> -p /sys  &amp;&amp; mount -t sysfs none /sys<br><span class="hljs-built_in">mknod</span> /dev/tty c 4 1<br>setsid /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1<br></code></pre></td></tr></table></figure></li><li><p>在 &#x2F;bin 目录下创建多个命令的快捷方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>最后回答什么是 systemd, 它为什么是进程树的根。</p><blockquote><p>在之后，会执行 &#x2F;usr&#x2F;sbin&#x2F;init<br>可以看到，这是个快捷方式，指向 &#x2F;lib&#x2F;systemd&#x2F;systemd</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码风格和定制化gdb调试</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ol><li>编程中的一些细节</li><li>调试工具的正确使用方法</li></ol><h3 id="软件的热更新DSU"><a href="#软件的热更新DSU" class="headerlink" title="软件的热更新DSU"></a>软件的热更新DSU</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOSTRING(s)  STRINGIFY(s)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">padding</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;.fill &quot;</span> TOSTRING(PADDING) <span class="hljs-string">&quot;, 1, 0x90&quot;</span></span><br><span class="hljs-params">  )</span>;<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In old function %s\n&quot;</span>, __func__);<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo_new</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In new function %s\n&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-comment">// 48 b8 (64-bit imm)   movabs $imm,%rax</span><br><span class="hljs-comment">// ff e0                jmpq   *%rax</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> PATCH[] = <span class="hljs-string">&quot;\x48\xb8--------\xff\xe0&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DSU</span><span class="hljs-params">(<span class="hljs-type">void</span> *func, <span class="hljs-type">void</span> *func_new)</span> &#123;<br>  <span class="hljs-type">int</span> flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;<br><br>  <span class="hljs-comment">// Grant write permission to the memory</span><br>  <span class="hljs-comment">// We must handle boundary cases</span><br>  <span class="hljs-type">uintptr_t</span> fn = (<span class="hljs-type">uintptr_t</span>)func;<br>  <span class="hljs-type">uintptr_t</span> base = fn &amp; ~<span class="hljs-number">0xfff</span>;<br>  <span class="hljs-keyword">if</span> (fn + <span class="hljs-keyword">sizeof</span>(PATCH) &gt; base + <span class="hljs-number">4096</span>) &#123;<br>    np = <span class="hljs-number">2</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    np = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;np = %d\n&quot;</span>, np);<br><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, flag);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>  <br>  <span class="hljs-comment">// Patch the first instruction (this is UB in C spec)</span><br>  <span class="hljs-built_in">memcpy</span>(func, PATCH, <span class="hljs-keyword">sizeof</span>(PATCH));<br>  <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span> *)func + <span class="hljs-number">2</span>, &amp;func_new, <span class="hljs-keyword">sizeof</span>(func_new));<br><br>  <span class="hljs-comment">// Revoke the write permission</span><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, PROT_READ | PROT_EXEC);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  foo();<br>  DSU(foo, foo_new);  <span class="hljs-comment">// Dynamic software update</span><br>  foo();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些编程小技巧"><a href="#一些编程小技巧" class="headerlink" title="一些编程小技巧"></a>一些编程小技巧</h4><ul><li><p>什么是 __func__？</p><blockquote><p><strong>func</strong> 是C语言中的一个内置宏，它返回当前函数的名称作为一个字符串常量。它可以用于调试和错误报告，以便在程序出错时能够更容易地确定错误发生在哪个函数中。<br>相当于：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">my_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __func__ <span class="hljs-string">&quot;my_func&quot;</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current function: %s\n&quot;</span>, __func__);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __func__ </span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 <strong>func</strong> 宏不需要包含任何头文件，因为它是C语言的内置宏，可以直接在代码中使用。</p></blockquote></li><li><p>使用 assert 断言</p><blockquote><p>有利于 bug 的定位</p></blockquote></li></ul><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><ul><li><p>为什么要把函数设置成 inline?<br>内联函数（inline function）是一种编译器提供的优化手段，它的本质是将函数在调用处展开，从而避免了函数调用的开销。也就是说，内联函数不是真正的函数调用，而是将函数的代码嵌入到调用处，类似于宏替换。</p></li><li><p>打一个小补丁</p><blockquote><p>我们知道，在调用一个函数的时候，首先 call foo, 把返回地址压栈，并跳转到foo函数处，然后再在foo函数那里给上一个补丁。</p></blockquote><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">movabs <span class="hljs-built_in">$imm</span> , <span class="hljs-built_in">%rax</span><br>jump *(rax)<br></code></pre></td></tr></table></figure><p>%rax是 foo_new函数的地址，因为foo_new函数最后也会调用 ret 指令，所以结束后返回到原来的地方。</p></li></ul><h3 id="用好工具"><a href="#用好工具" class="headerlink" title="用好工具"></a>用好工具</h3><ul><li>如何让gdb以更友好的方式帮我们打印相关的信息？<br>计算机公理3：让你感到不适的 tedious 工作，一定有办法提高效率。</li></ul><blockquote><p>用python写一个脚本，增加一个自定义的gdb命令</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>REGS = [<br>    <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;rbx&#x27;</span>, <span class="hljs-string">&#x27;rcx&#x27;</span>, <span class="hljs-string">&#x27;rdx&#x27;</span>,<br>    <span class="hljs-string">&#x27;rbp&#x27;</span>, <span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-string">&#x27;rsi&#x27;</span>, <span class="hljs-string">&#x27;rdi&#x27;</span>,<br>    <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-string">&#x27;r9&#x27;</span>, <span class="hljs-string">&#x27;r10&#x27;</span>, <span class="hljs-string">&#x27;r11&#x27;</span>,<br>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RegDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(RegDump, self).__init__(<br>            <span class="hljs-string">&quot;rdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, arg, _</span>):<br>        <span class="hljs-comment"># 得到变量 ctx 的值</span><br>        <span class="hljs-comment"># 每次输入 rdump 命令会执行 invoke 函数</span><br>        ctx = gdb.parse_and_eval(<span class="hljs-string">f&#x27;ctx&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(REGS):<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;r.upper():<span class="hljs-number">3</span>&#125;</span> = <span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(ctx[r]):016x&#125;</span>&#x27;</span>,<br>                end=[<span class="hljs-string">&#x27;  &#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>][i % <span class="hljs-number">2</span>]<br>            )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>RegDump()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_source_line</span>(<span class="hljs-params">address</span>):<br>    <span class="hljs-comment"># by GPT-4</span><br><br>    <span class="hljs-comment"># Find the source code line corresponding to the given address</span><br>    symtab_and_line = gdb.find_pc_line(address)<br><br>    <span class="hljs-comment"># Check if the source code line was found</span><br>    <span class="hljs-keyword">if</span> symtab_and_line.symtab <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Get the source file name and line number</span><br>        filename = symtab_and_line.symtab.filename<br>        line_number = symtab_and_line.line<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Path(filename).name&#125;</span>:<span class="hljs-subst">&#123;line_number&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Source code line not found&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        n = gdb.parse_and_eval(<span class="hljs-string">f&#x27;NTASK&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            tsk = gdb.parse_and_eval(<span class="hljs-string">f&#x27;tasks[<span class="hljs-subst">&#123;i&#125;</span>]&#x27;</span>)<br>            pc = <span class="hljs-built_in">int</span>(tsk[<span class="hljs-string">&#x27;context&#x27;</span>][<span class="hljs-string">&#x27;rip&#x27;</span>])<br>            is_current = <span class="hljs-built_in">int</span>(<br>                gdb.parse_and_eval(<span class="hljs-string">f&#x27;&amp;tasks[<span class="hljs-subst">&#123;i&#125;</span>] == current&#x27;</span>)<br>            )<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;Proc-<span class="hljs-subst">&#123;i&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&quot; *&quot;</span>[is_current]&#125;</span> &#x27;</span>,<br>                get_source_line(pc)<br>            )<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>ProcDump()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程地址空间</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux进程的地址空间"><a href="#Linux进程的地址空间" class="headerlink" title="Linux进程的地址空间"></a>Linux进程的地址空间</h2><p>有什么工具可以来查看进程的地址空间</p><ol><li>pmap</li><li>cat &#x2F;proc&#x2F; [pid] &#x2F; maps</li><li>gdb</li><li>readelf</li><li>objdump</li></ol><p>有的程序刚开始执行就结束了(比如打印一个东西就退出)，如果要查看这个进程的地址空间。那怎么办？</p><blockquote><p>使用gdb。<br>使用gdb命令 info inferiors得到进程的pid</p></blockquote><ul><li>该命令打印gdb当前管理的inferiors列表，每个inferior都有自己的不同地址空间，inferior与进程对应。</li></ul><ol><li><p>得到进程的pid后,使用命令 !pmap [pid], 在gdb中使用shell命令需要在前面加上 ！。</p></li><li><p>同样，在gdb中，还可以使用 !cat &#x2F;proc&#x2F; [pid] &#x2F;maps来查看进程的地址空间。</p></li></ol><ul><li>其实pmap就是使用系统中的 &#x2F;proc&#x2F;[pid]&#x2F;这个文件实现的。<br>怎么证明呢？<blockquote><p>使用 strace   strace pmap [pid]</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>gdb调试starti之后，查看进程的地址空间：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">8</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>     <span class="hljs-number">16</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>              <span class="hljs-number">416</span>K<br></code></pre></td></tr></table></figure><p>我们还发现，在按下starti后，有一条信息：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fe32b0 in _start () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>说明动态链接的第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2中，甚至在地址空间中此时也没有libc这个库。<br>在状态机在刚刚被初始化的一瞬间，在进程里面还没有printf。</p><blockquote><p>动态链接的ELF文件中，有一个INTERP, 就是这里的ld-linux-x86-64.so.2, 需要另外一个程序，才能执行现在这个程序，对于动态链接来说，这就是加载器。</p></blockquote><p>再在main函数上打个断点，continue后再打印一次进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555558000</span>      <span class="hljs-number">4</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7d7f000</span>     <span class="hljs-number">12</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7d82000</span>    <span class="hljs-number">160</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7daa000</span>   <span class="hljs-number">1620</span>K r-x-- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f3f000</span>    <span class="hljs-number">352</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f97000</span>     <span class="hljs-number">16</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9b000</span>      <span class="hljs-number">8</span>K rw--- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9d000</span>     <span class="hljs-number">52</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbb000</span>      <span class="hljs-number">8</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffd000</span>      <span class="hljs-number">8</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>             <span class="hljs-number">2644</span>K<br></code></pre></td></tr></table></figure><p>如上，我们发现libc已经有了。加载器也还在，未来可能还需要这个加载器加载其他动态链接库。</p><h4 id="其他小细节"><a href="#其他小细节" class="headerlink" title="其他小细节"></a>其他小细节</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> main&#123;<br><span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在库都加载完成后，用 !cat &#x2F;proc&#x2F;14776&#x2F;&#x2F;maps 查看该进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7ffff7fbd000</span>-<span class="hljs-number">7</span>ffff7fc1000 r--p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vvar]</span><br><br><span class="hljs-attribute">7ffff7fc1000</span>-<span class="hljs-number">7</span>ffff7fc3000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vdso]</span><br><br></code></pre></td></tr></table></figure><p>我们发现这两行， vvar 和 vdso 是什么？</p><blockquote><p>不进入内核的系统调用。<br>vvar is a memory region that contains kernel variables that are frequently accessed by user-space programs. These variables are read-only and can be accessed directly by the user-space programs without making a system call.<br>例如<br>当前的时间， 系统页面大小<br>vdso is a memory region that contains a small shared library provided by the kernel. This library contains a set of functions that are commonly used by user-space programs and can be excuted directly in user mode, without the need for a system call.</p></blockquote><h3 id="进程地址空间的管理"><a href="#进程地址空间的管理" class="headerlink" title="进程地址空间的管理"></a>进程地址空间的管理</h3><p>操作系统应该提供一个修改进程地址空间的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 映射</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br><br><span class="hljs-comment">// 修改映射权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>本质：在状态机状态上增加&#x2F;删除&#x2F;修改一段可访问的内存</p><ul><li>mmap: 可以用来申请内存 (MAP_ANONYMOUS)，也可以把文件 “搬到” 进程地址空间中</li></ul><p>一小段示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GiB * (1024LL * 1024 * 1024)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *p = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span> GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap: %lx\n&quot;</span>, (<span class="hljs-type">uintptr_t</span>)p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)p == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;cannot map&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  *(p + <span class="hljs-number">2</span> GiB) = <span class="hljs-number">1</span>;<br>  *(p + <span class="hljs-number">4</span> GiB) = <span class="hljs-number">2</span>;<br>  *(p + <span class="hljs-number">7</span> GiB) = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">4</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">6</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">7</span> GiB));<br>&#125;<br></code></pre></td></tr></table></figure><p>疑问：这个程序运行会不会需要很长的时间，因为它分配了那么多的内存？</p><blockquote><p>其实一瞬间就完成了。也就是说，在使用mmap的时候，只是在操作系统中标记了这个进程这么多的内存，这个进程中这些内存还并没有开始分配，只是在后面用到了才会产生缺页中断。</p></blockquote><h3 id="入侵地址空间"><a href="#入侵地址空间" class="headerlink" title="入侵地址空间"></a>入侵地址空间</h3><p>进程 (M,  R 状态机) 在 “无情执行指令机器” 上执行</p><ul><li>状态机是一个封闭世界</li><li>但如果允许一个进程对其他进程的地址空间有访问权？</li></ul><p>一些入侵地址空间的例子</p><ol><li>调试器(gdb)</li></ol><ul><li>gdb 可以任意观测和修改程序的状态</li></ul><ol start="2"><li>Profiler (perf)</li></ol><h4 id="入侵进程地址空间-1-金山游侠"><a href="#入侵进程地址空间-1-金山游侠" class="headerlink" title="入侵进程地址空间 (1): 金山游侠"></a>入侵进程地址空间 (1): 金山游侠</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_WATCH 65536</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <span class="hljs-comment">// Name of the binary</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-type">int</span> memfd;         <span class="hljs-comment">// Address space of the process</span><br>  <span class="hljs-type">int</span> bits;          <span class="hljs-comment">// Search bit-width (16, 32, or 64)</span><br>  <span class="hljs-type">bool</span> has_watch;    <span class="hljs-comment">// Watched values</span><br>  <span class="hljs-type">uintptr_t</span> watch[MAX_WATCH];<br>&#125;;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span>;<br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint32_t</span> val)</span> &#123;<br>  <span class="hljs-type">uintptr_t</span> start, kb;<br>  <span class="hljs-type">char</span> perm[<span class="hljs-number">16</span>];<br>  FILE *fp = popens(<span class="hljs-string">&quot;pmap -x $(pidof %s) | tail -n +3&quot;</span>, g-&gt;name);<br>  <span class="hljs-type">int</span> nmatch = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;start) == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%ld%*ld%*ld%s%*[^\n]s&quot;</span>, &amp;kb, perm);<br>    <span class="hljs-keyword">if</span> (perm[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Non-writable areas</span><br><br>    <span class="hljs-type">uintptr_t</span> size = kb * <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for brevity</span><br>    lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>    size = read(g-&gt;memfd, mem, size);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Scanning %lx--%lx\n&quot;</span>, start, start + size);<br><br>    <span class="hljs-keyword">if</span> (!g-&gt;has_watch) &#123;<br>      <span class="hljs-comment">// First-time search; scan all memory</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> off = <span class="hljs-number">0</span>; off &lt; size; off += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>        <span class="hljs-keyword">if</span> (v == val &amp;&amp; nmatch &lt; MAX_WATCH) &#123;<br>          g-&gt;watch[nmatch++] = start + off;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Search in the watched values</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>        <span class="hljs-type">intptr_t</span> off = g-&gt;watch[i] - start;<br>        <span class="hljs-keyword">if</span> (g-&gt;watch[i] &amp;&amp; <span class="hljs-number">0</span> &lt;= off &amp;&amp; off &lt; size) &#123;<br>          <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>          <span class="hljs-keyword">if</span> (v == val) nmatch++;<br>          <span class="hljs-keyword">else</span> g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(mem);<br>  &#125;<br>  pclose(fp);<br><br>  <span class="hljs-keyword">if</span> (nmatch &gt; <span class="hljs-number">0</span>) &#123;<br>    g-&gt;has_watch = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d match(es).\n&quot;</span>, nmatch);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">overwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint64_t</span> val)</span> &#123;<br>  <span class="hljs-type">int</span> nwrite = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++)<br>    <span class="hljs-keyword">if</span> (g-&gt;watch[i]) &#123;<br>      lseek(g-&gt;memfd, g-&gt;watch[i], SEEK_SET);<br>      write(g-&gt;memfd, &amp;val, g-&gt;bits / <span class="hljs-number">8</span>);<br>      nwrite++;<br>    &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d value(s) written.\n&quot;</span>, nwrite);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>    g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  g-&gt;has_watch = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Search for %d-bit values in %s.\n&quot;</span>, g-&gt;bits, g-&gt;name);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">load_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  FILE *pid_fp;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  g-&gt;name = name;<br>  g-&gt;bits = <span class="hljs-number">32</span>;<br>  reset(g);<br><br>  pid_fp = popens(<span class="hljs-string">&quot;pidof %s&quot;</span>, g-&gt;name);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(pid_fp, <span class="hljs-string">&quot;%d&quot;</span>, &amp;g-&gt;pid) != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Panic: fail to get pid of \&quot;%s\&quot;.\n&quot;</span>, g-&gt;name);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>release:<br>  <span class="hljs-keyword">if</span> (pid_fp) pclose(pid_fp);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &gt;= <span class="hljs-number">0</span>) &#123;<br>    close(g-&gt;memfd);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">long</span> val;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> <span class="hljs-title">game</span>;</span><br><br>  <span class="hljs-keyword">if</span> (load_game(&amp;game, argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (!feof(<span class="hljs-built_in">stdin</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s %d) &quot;</span>, game.name, game.pid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> release;<br><br>    <span class="hljs-keyword">switch</span> (buf[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-keyword">goto</span> release; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); game.bits = val; reset(&amp;game); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); scan(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); overwrite(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>: reset(&amp;game); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>release:<br>  close_game(&amp;game);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span> &#123;<br>  <span class="hljs-type">char</span> cmd[<span class="hljs-number">128</span>];<br>  va_list args;<br>  va_start(args, fmt);<br>  vsnprintf(cmd, <span class="hljs-keyword">sizeof</span>(cmd), fmt, args);<br>  va_end(args);<br>  FILE *ret = popen(cmd, <span class="hljs-string">&quot;r&quot;</span>);<br>  assert(ret);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span> &#123;<br>  <span class="hljs-type">uint64_t</span> val = *(<span class="hljs-type">uint64_t</span> *)(&amp;mem[off]);<br>  <span class="hljs-keyword">switch</span> (bits) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: val &amp;= <span class="hljs-number">0xffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: val &amp;= <span class="hljs-number">0xffffffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>: <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码导读</p><ul><li>va_list，va_start()、va_arg() 和 va_end() 是什么<blockquote><p>这可以使C语言实现变长参数。</p><blockquote><p>va_list 是一个类型，用于表示可变参数列表。<br>va_start() 宏用于初始化可变参数列表<br>va_arg() 宏用于访问可变参数列表中的下一个参数<br>va_end() 宏用于结束可变参数列表的访问</p></blockquote></blockquote></li><li>一段小例子<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> &#123;<br>    va_list ap;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;<br><br>    va_start(ap, count); <span class="hljs-comment">// 初始化可变参数列表</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        total += va_arg(ap, <span class="hljs-type">double</span>); <span class="hljs-comment">// 获取下一个参数</span><br>    &#125;<br><br>    va_end(ap); <span class="hljs-comment">// 结束可变参数列表</span><br><br>    <span class="hljs-keyword">return</span> total / count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> avg = average(<span class="hljs-number">5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;平均值为：%f\n&quot;</span>, avg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>popen函数</p><blockquote><p>popen()会调用fork()产生子进程，然后从子进程中调用&#x2F;bin&#x2F;sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。</p></blockquote></blockquote></li><li>也就是说，首先获取游戏进程的名字后，先创建一个子进程执行 pidof [name]的命令，可以获取游戏进程pid。然后fscanf(pid_fp, “%d”, &amp;g-&gt;pid) !&#x3D; 1读取该进程pid。<br>接着打开&#x2F;proc&#x2F;[pid]&#x2F;mem这个文件。g-&gt;memfd指向这个文件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br></code></pre></td></tr></table></figure></li><li>scan函数<br>在用pmap得到虚拟地址区域后，就可以把这个区域映射到入侵程序的地址空间中，并得到起始地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for </span><br></code></pre></td></tr></table></figure></li><li>之后把 &#x2F;proc&#x2F;pid&#x2F;mem的文件偏移设为虚拟地址区域起始处。</li></ul><ul><li>如果想要在&#x2F;proc&#x2F;pid&#x2F;mem 文件访问进程的虚拟地址 0x12345678，您需要将文件偏移量设置为 0x12345678。<br>并把这个区域的内存全部写入入侵进程的地址空间中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>size = read(g-&gt;memfd, mem, size);<br></code></pre></td></tr></table></figure></li></ul><ul><li>然后就可以根据偏移，可以把相应的地址对应起来了。大致意思就是在入侵地址里暴力寻找符合条件的地址，然后根据找的的符合条件的地址，由于偏移是一样的，也就可以把这个地址对应到被入侵进程的相应虚拟地址区域中了。</li></ul><h4 id="入侵进程地址空间-2-变速齿轮"><a href="#入侵进程地址空间-2-变速齿轮" class="headerlink" title="入侵进程地址空间 (2): 变速齿轮"></a>入侵进程地址空间 (2): 变速齿轮</h4><p>用修改程序系统调用的手段来欺骗程序对时间的认识，就可以实现游戏的加速和减速。</p><ul><li><p>简单的一段C程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> hp = <span class="hljs-number">10000</span>;<br><br>__attribute__((noinline)) <span class="hljs-type">int</span> <span class="hljs-title function_">hit</span><span class="hljs-params">(<span class="hljs-type">int</span> damage)</span> &#123;<br>  <span class="hljs-keyword">return</span> hp - damage;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    hp = hit(rand() % <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hp = %d\n&quot;</span>, hp);<br>    usleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">if</span> (hp &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>python 脚本</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(argv) &lt; <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Usage <span class="hljs-subst">&#123;argv[<span class="hljs-number">0</span>]&#125;</span> [--hp] [--fast] [--slow]&#x27;</span>)<br>    exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">addr, patch</span>):<br>    pid = <span class="hljs-built_in">int</span>(subprocess.check_output([<span class="hljs-string">&#x27;pidof&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/mem&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.seek(addr)<br>        fp.write(patch)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">symbol</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> subprocess.check_output([<span class="hljs-string">&#x27;nm&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]).splitlines():<br>        tokens = line.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).split()<br>        <span class="hljs-keyword">if</span> tokens[-<span class="hljs-number">2</span>:] == [<span class="hljs-string">&#x27;T&#x27;</span>, symbol]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tokens[<span class="hljs-number">0</span>], base=<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--hp&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># hit -&gt; mov $9999999, %eax; ret</span><br>    patch(name(<span class="hljs-string">&#x27;hit&#x27;</span>), <span class="hljs-string">b&#x27;\xb8\x7f\x96\x98\x00\xc3&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--slow&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shl $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xe7\x04&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--fast&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shr $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xef\x04&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork的应用</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul><li>fork状态机复制，包括持有的所有操作系统对象(如文件描述符)</li><li>execve重置状态机，但继承持有的所有操作系统的对象</li><li>例如在fork之前打开一个管道, 然后就可以把一部分计算的输出管道给另外一个进程的输入</li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><ul><li>RTFM: O_CLOEXEC : execve时文件描述符不应该被继承； O_APPEND：以追加的方式写该文件</li><li>对于数据文件，文件描述符会记住上次访问的位置</li><li>dup：复制一个文件描述符，进程有两个fd指向同一个文件，并且具有同一个offset</li></ul><h2 id="回到fork-复制，但又没有完全复制"><a href="#回到fork-复制，但又没有完全复制" class="headerlink" title="回到fork, 复制，但又没有完全复制"></a>回到fork, 复制，但又没有完全复制</h2><p>概念上状态机被复制，但实际上复制后内存都共享</p><ul><li>“Copy on Write”只有被写入的页面才会复制一份<ol><li>被复制后，整个地址空间都被标记位”只读”</li><li>操作系统捕获Page Fault后酌情复制页面</li><li>操作系统会维护每个页面的引用计数</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C标准库和实现</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="我们该如何学习-C-标准库"><a href="#我们该如何学习-C-标准库" class="headerlink" title="我们该如何学习 C 标准库?"></a>我们该如何学习 C 标准库?</h2><ul><li><del>直接调试 glibc (像我们上课那样)</del></li><li>寻找更好的替代品，一定有为嵌入式设备实现的简化 libc。<blockquote><p>选择 musl<br>musl是一个轻量级的C标准库，它专注于提供高效、可靠和安全的C语言运行时环境。musl库的设计目标是遵循POSIX标准，同时保持代码的简洁和易于维护。它主要用于嵌入式系统、轻量级容器和其他类似的应用程序中，因为它比其他标准库更小、更快、更安全，并且不包含任何专有代码或许可证限制。在某些情况下，它也可以用作替代glibc的标准库。</p></blockquote></li></ul><ul><li>那怎么编译一个 C 程序用 musl 作为 libc 而不是用 glibc呢 ？<ol><li>sudo apt-get install musl-tools</li><li>编写C程序，包含 stdio.h 头文件</li><li>musl-gcc -o hello hello.c</li></ol></li></ul><h2 id="libc-的基本功能"><a href="#libc-的基本功能" class="headerlink" title="libc 的基本功能"></a>libc 的基本功能</h2><ul><li>基础数据的体系结构无关抽象</li></ul><ul><li>inttypes.h</li></ul><ul><li>字符串和数组操作</li></ul><h2 id="操作系统对象与环境"><a href="#操作系统对象与环境" class="headerlink" title="操作系统对象与环境"></a>操作系统对象与环境</h2><ul><li><p>环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **env = environ; *env; env++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *env);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>environ是一个字符指针的指针。</p></li><li><p>environ是谁赋值的？</p></li></ul><p>gdb调试<br>第一条指令的时候 environ 还没有被赋值。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fc7bfe in _dlstart () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib/</span>ld-musl-x86_64.so.<span class="hljs-number">1</span><br>(gdb) p(<span class="hljs-keyword">char</span>*) environ<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>而在main函数的时候，environ是有正确的值的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>__libc_start_main函数<br>char **envp = argv + argc + <span class="hljs-number">1</span>;<br>.....<br>.....<br><span class="hljs-regexp">//</span>__init_libc函数<br>environ = envp<br></code></pre></td></tr></table></figure><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："><a href="#本讲内容：指令序列和高级语言的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："></a>本讲内容：指令序列和高级语言的状态机模型；回答以下问题：</h2><ul><li>什么是软件 (程序)？</li><li>如何在操作系统上构造最小&#x2F;一般&#x2F;图形界面应用程序？</li><li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li></ul><h2 id="构建一个最小的程序"><a href="#构建一个最小的程序" class="headerlink" title="构建一个最小的程序"></a>构建一个最小的程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcc-编译出来的文件一点也不小"><a href="#gcc-编译出来的文件一点也不小" class="headerlink" title="gcc 编译出来的文件一点也不小"></a>gcc 编译出来的文件一点也不小</h3><ol><li>objdump 工具可以查看对应的汇编代码</li><li>–verbose 可以查看所有编译选项 (真不少)</li><li>printf 变成了 puts@plt</li><li>-Wl,–verbose 可以查看所有链接选项 (真不少)<br>原来链接了那么多东西<br>还解释了 end 符号的由来</li><li>-static 会链接 libc (大量的代码)<blockquote><p>gcc a.c 和 gcc a.c -static 有什么区别？</p></blockquote></li></ol><h3 id="强行构造最小的-Hello-World？"><a href="#强行构造最小的-Hello-World？" class="headerlink" title="强行构造最小的 Hello, World？"></a>强行构造最小的 Hello, World？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c hello<span class="hljs-selector-class">.c</span>    -&gt; hello<span class="hljs-selector-class">.o</span> <br>ld hello<span class="hljs-selector-class">.o</span> -e <span class="hljs-selector-tag">main</span>   -&gt; <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>执行a.out,会发生Segmentation Fault.</p><p>如果改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再继续执行上面的编译命令，发现程序可以正常执行了（死循环）。</p><blockquote><p>查看汇编语言，猜测程序返回时的 ret 出现了错误。</p></blockquote><h3 id="解决异常退出"><a href="#解决异常退出" class="headerlink" title="解决异常退出"></a>解决异常退出</h3><blockquote><p>解决办法：用一条特殊的指令请操作系统帮忙</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">movq $SYS_exit,  %rax   <span class="hljs-comment"># exit(</span><br>movq $1,         %rdi   <span class="hljs-comment">#   status=1</span><br><span class="hljs-keyword">syscall</span>                 <span class="hljs-comment"># );</span><br></code></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<ul><li>程序把控制权完全交给操作系统</li><li>操作系统可以改变程序状态甚至终止程序</li></ul></li></ul><h2 id="理解高级编程语言程序"><a href="#理解高级编程语言程序" class="headerlink" title="理解高级编程语言程序"></a>理解高级编程语言程序</h2><blockquote><p>编程语言也是一个状态机</p></blockquote><ul><li>非递归的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> pc, n;<br>  <span class="hljs-type">char</span> from, to, via;<br>&#125; Frame;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ret()     (&#123; top--; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  Frame stk[<span class="hljs-number">64</span>], *top = stk - <span class="hljs-number">1</span>;<br>  call(n, from, to, via);<br>  <span class="hljs-keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;<br>    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;<br>    <span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <br>      <span class="hljs-comment">// 为什么goto(4)只是设置pc为3，是因为循环会++</span><br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>什么叫函数调用<blockquote><p>函数是由很多个栈帧组成的，每一个栈帧都有一个PC</p></blockquote></li></ul><p>什么是函数调用？</p><blockquote><p> 函数调用就是在栈帧的顶部再加上一个栈帧，这个栈帧的PC是0，然后把参数放到栈上</p></blockquote><p>什么是函数返回</p><blockquote><p>  把顶部的栈给抹掉</p></blockquote><p>什么是执行一条语句</p><blockquote><p>  取最顶上栈帧PC上的语句执行</p></blockquote><ul><li>代码讲解<br>这是递归版的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    hanoi(n - <span class="hljs-number">1</span>, from, via, to);<br>    hanoi(<span class="hljs-number">1</span>,     from, to,  via);<br>    hanoi(n - <span class="hljs-number">1</span>, via,  to,  from);<br>  &#125;<br>  <span class="hljs-comment">// return 省略了</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据上面的思想，把整个hanoi函数理解成一个栈帧，每一个栈帧有一个PC，还需要参数信息</p></blockquote></li></ul><p><strong>可以理解成函数体每一条语句都是一条PC指针</strong><br>每一次循环，都会取最顶上的栈帧来操作<br>这也就是下部分的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作系统上的软件-应用程序"><a href="#操作系统上的软件-应用程序" class="headerlink" title="操作系统上的软件 (应用程序)"></a>操作系统上的软件 (应用程序)</h2><blockquote><p>任何程序 &#x3D; minimal.S &#x3D; 调用 syscall 的状态机</p></blockquote><p>可执行文件是操作系统中的对象</p><ul><li><p>与大家日常使用的文件 (a.c, README.txt) 没有本质区别</p></li><li><p>操作系统提供 API 打开、读取、改写 (都需要相应的权限)</p></li></ul><p>查看可执行文件</p><ul><li>vim, cat, xxd 都可以直接 “查看” 可执行文件</li><li>vim 中二进制的部分无法 “阅读”，但可以看到字符串常量</li><li>使用 xxd 可以看到文件以 “\x7f” “ELF” 开头</li><li>Vscode 有 binary editor 插件</li></ul><p>在 Vim 中输入 %!xxd 命令会将当前编辑的文件转换成十六进制表示，并在 Vim 中显示。这个命令的作用是将当前编辑的文件作为输入传递给 xxd 命令(%表示对整个文件执行操作)，xxd 命令会将其转换成十六进制格式，并将结果输出到标准输出流，此时 Vim 会将其读取并显示在编辑器中。</p><h2 id="动手实验：观察程序的执行"><a href="#动手实验：观察程序的执行" class="headerlink" title="动手实验：观察程序的执行"></a>动手实验：观察程序的执行</h2><p>工具程序代表：编译器 (gcc)</p><ul><li>主要的系统调用：execve, read, write</li><li>strace -f gcc a.c (gcc 会启动其他进程， -f选项会追踪所有子进程)<ul><li>可以管道给编辑器 vim -</li><li>编辑器里还可以 %!grep (细节&#x2F;技巧)</li></ul></li></ul><p>grep 命令的 -e 选项用于指定一个或多个匹配模式，这些模式可以是正则表达式或普通字符串。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">strace <span class="hljs-keyword">ls</span> |&amp; <span class="hljs-keyword">grep</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">read</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">write</span><br></code></pre></td></tr></table></figure><p>图形界面程序代表：编辑器 (xedit)</p><ul><li>主要的系统调用：poll, recvmsg, writev</li><li>strace xedit<ul><li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li><li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
