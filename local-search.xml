<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>P3实验笔记</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P3%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P3%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Query-Execution"><a href="#Query-Execution" class="headerlink" title="Query Execution"></a><strong>Query Execution</strong></h2><p>从这一个实验开始，我们就正式进入了Bustub数据库的底层实现部分。这个实验完成后，我们利用我们实现的算子，可以在本机进行SQL语句的查询。</p><h3 id="SQL语句的执行"><a href="#SQL语句的执行" class="headerlink" title="SQL语句的执行"></a><strong>SQL语句的执行</strong></h3><p><strong>Parser</strong></p><p>一条 sql 语句，首先经过 Parser 生成一棵抽象语法树 AST。Bustub 中采用了 libpg_query 库将 sql 语句 parse 为 AST。这个地方主要运用的是编译原理的内容。</p><p><strong>Binder</strong></p><p>在得到 AST 后，还需要将这些词语绑定到数据库实体上，这就是 Binder 的工作。例如有这样一条 sql：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> colA <span class="hljs-keyword">FROM</span> table1;<br></code></pre></td></tr></table></figure><p>其中 <code>SELECT</code> 和 <code>FROM</code> 是关键字，<code>colA</code> 和 <code>table1</code> 是标识符。Binder 遍历 AST，将这些词语绑定到相应的实体上。实体是 Bustub 可以理解的各种 c++ 类。绑定完成后，得到的结果是一棵 Bustub 可以直接理解的树。把它叫做 Bustub AST。</p><p><strong>Planner</strong></p><p>得到 Bustub AST 后，Planner 遍历这棵树，生成初步的查询计划。</p><p><strong>Optimizer</strong></p><p>由 Planner 得到初步的查询计划后，再将查询计划交给 Optimizer 进行修改优化，生成优化过后的最终查询计划。</p><p><strong>Executor</strong></p><p>拿到查询计划后，就可以生成真正的执行查询计划的一系列算子了。这也是我们在这次实验需要完成的。算子有3种执行模型：</p><ol><li>Iterator Model，Pipeline Model，也就是火山模型。每个算子都有 <code>Init()</code> 和 <code>Next()</code> 两个方法。<code>Init()</code> 对算子进行初始化工作。<code>Next()</code> 则是向下层算子请求下一条数据。当 <code>Next()</code> 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。可以看到，火山模型一次调用请求一条数据，占用内存较小，但函数调用开销大，特别是虚函数调用造成 cache miss 等问题。在bustub中选用了这种火山模型。我们将在下面的实验中对火山模型有进一步的了解和体会</li><li>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高。但减少了函数调用的开销。</li><li>Vectorization Model. 对上面两种模型的中和，一次调用返回一批数据。</li></ol><p>此外，算子的执行方向也有两种：</p><ol><li>Top-to-Bottom. 从根节点算子开始，不断地 pull 下层算子的数据。</li><li>Bottom-to-Top. 从叶子节点算子开始，向上层算子 push 自己的数据。</li></ol><p>我们来看一个具体的例子，理解一下火山模型：</p><img src="/img/bustub/iteratormodel.png" style="zoom: 33%;"><p>右下是我们的执行算子，最顶层的是1个projection的算子，它不断调用<code>Next</code> 方法获取它的每一条记录，它有1个<code>child_executor_</code> 的子算子为它不断提供它需要进行projection的数据，这个算子在这里是一个Join类型的算子，它的每一条数据是怎么来的呢，当然也是通过不断调用<code>Next</code> 方法从它的左儿子和右儿子执行算子中获取的，左儿子和右儿子也是通过<code>Next</code> 方法获得数据条目的。可以看到，叶子节点的算子肯定要从数据库中的表中获取数据，也就是叶子算子一定是SeqScan算子。中间的算子对获取到的<code>Tuple</code> 进行加工，获得中间结果，再把中间结果传递给上层算子。整个火山模型就是这样的一个工作流程。</p><p>我们可以看到，这种火山模型获取一条数据都需要一条很长的<code>Next</code> 调用函数链，函数的花销是很大的。</p><h2 id="SeqScan"><a href="#SeqScan" class="headerlink" title="SeqScan"></a><strong>SeqScan</strong></h2><p>为什么每一个执行算子都需要<code>ExecutorContext</code> 和 <code>PlanNode</code> ？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">SeqScanExecutor::SeqScanExecutor(ExecutorContext *exec_ctx, <span class="hljs-type">const</span> SeqScanPlanNode *plan)<br></code></pre></td></tr></table></figure><p>生成的具体的查询计划后，就可以生成真正执行查询计划的一系列算子。每种查询计划都有与之对应的算子，将查询计划替换成相应的Executor。<code>PlanNode</code> 中有该查询计划所需要的表的名称，而<code>ExecutorContext</code> 中有支持查询的相关资源，比如<code>catalog</code> 、<code>buffer_pool_manager_</code> 以及事务相关的。</p><p>我们来看SeqScan这个算子，正如我们上面说的，SeqScan算子是最底层的算子，它是在TablePage中把一条条<code>Tuple</code> 给读取出来。</p><p>这里我们需要阅读一下<code>TablePage</code> 迭代器的实现部分，通过迭代器就可以实现了。</p><h2 id="Insert-Delete"><a href="#Insert-Delete" class="headerlink" title="Insert &amp;&amp; Delete"></a><strong>Insert &amp;&amp; Delete</strong></h2><p>这两个算子的实现也不难，但记得要更新与 table 相关的所有 index。index 与 table 类似，同样由 Catalog 管理。需要注意的是，由于可以对不同的字段建立 index，一个 table 可能对应多个 index，所有的 index 都需要更新。</p><p>主要调用<code>table_info_-&gt;table_-&gt;InsertTuple</code> 和 <code> indexinfo-&gt;index_-&gt;InsertEntry</code> 函数。这里还需要注意，这里的插入和删除都有一个<code>GetOutputSchema()</code> 的表格式。</p><h2 id="NestedLoopJoin"><a href="#NestedLoopJoin" class="headerlink" title="NestedLoopJoin"></a><strong>NestedLoopJoin</strong></h2><p>这个Join算子有两个子执行器，<code>left_executor_</code>和<code>right_executor_</code>，在<code>NestedLoopJoinPlanNode *plan</code>有一个 <code>JoinType</code>表示是Left Join还是Right Join。</p><p>在这里有一个细节，就是我们很容易写成这样的伪代码:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">while</span> (left_child-&gt;<span class="hljs-keyword">Next</span>(&amp;left_tuple))&#123;<br>    <span class="hljs-keyword">while</span> (right_child-&gt;<span class="hljs-keyword">Next</span>(&amp;right_tuple))&#123;<br>        <span class="hljs-keyword">if</span> (left_tuple matches right_tuple)&#123;<br>            *tuple = ...;   <span class="hljs-comment">// assemble left &amp; right together</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br></code></pre></td></tr></table></figure><p>仔细一看，这种实现是错误的，在火山模型中，right child 在 left child 的第一次循环中就被消耗完了，之后只会返回 false。所以我们需要用一个数组把right child的tuple事先获取到并存起来(实验指导上也说了，直接放在内存里面就够了)。</p><p>现在还有一个问题，如何判断两个tuple是否是匹配的呢，这里就需要遇到另一个很重要的类<code>AbstractExpression</code>了。</p><p><code>AbstractExpression</code> 抽象了 sql 中的各种表达式，包括 <code>ArithmeticExpression</code>、<code>ColumnValueExpression</code>、<code>ComparisonExpression</code>、<code>ConstantValueExpression</code> 和 <code>LogicExpression</code>。这都是什么？看下面这条 sql：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SELECT * FROM <span class="hljs-built_in">t1</span> WHERE <span class="hljs-built_in">t1</span>.x = <span class="hljs-built_in">t1</span>.y + <span class="hljs-number">1</span> <span class="hljs-keyword">AND </span><span class="hljs-built_in">t1</span>.y &gt; <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>重点关注 <code>WHERE</code> 后的表达式 <code>t1.x = t1.y + 1 AND t1.y &gt; 0</code>。看这下面这张图，这其实就是一棵表达式树，sql中所有的表达式都会被parse成表达式树，再进行绑定。</p><img src="/img/bustub/p3-2.jpg" style="zoom: 67%;"><p>在NestedLoopJoin里，调用的是<code>EvaluateJoin</code>,返回是true表示匹配成功。</p><p> 我们来看里匹配的判断逻辑：</p><p>在<code>Next</code>函数中，得到的这个<code>value</code>是bool类型的，也就是说顶层的表达式是一个逻辑表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Next()函数</span><br><span class="hljs-keyword">auto</span> value = plan_-&gt;Predicate().EvaluateJoin(&amp;left_tuple_, left_executor_-&gt;GetOutputSchema(), &amp;right_tuple,<br>                                                   right_executor_-&gt;GetOutputSchema());<br></code></pre></td></tr></table></figure><p>我们看这个<code>EvaluateJoin</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// LogicExpression 类</span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">EvaluateJoin</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple *left_tuple, <span class="hljs-type">const</span> Schema &amp;left_schema, <span class="hljs-type">const</span> Tuple *right_tuple,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> Schema &amp;right_schema)</span> <span class="hljs-type">const</span> -&gt; Value override &#123;<br>    Value lhs = GetChildAt(<span class="hljs-number">0</span>)-&gt;EvaluateJoin(left_tuple, left_schema, right_tuple, right_schema);<br>    Value rhs = GetChildAt(<span class="hljs-number">1</span>)-&gt;EvaluateJoin(left_tuple, left_schema, right_tuple, right_schema);<br>    <span class="hljs-keyword">return</span> ValueFactory::GetBooleanValue(PerformComputation(lhs, rhs));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我举一个例子，下面这个sql语句可以抽象成一棵表达式树.</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Select * From <span class="hljs-built_in">t1</span> INNER <span class="hljs-keyword">JOIN </span><span class="hljs-built_in">t2</span> where <span class="hljs-built_in">t1</span>.x + <span class="hljs-built_in">t2</span>.y = <span class="hljs-built_in">t1</span>.y + <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>表达式树的root节点是一个<code>LogicExpression</code>，它有两个子节点，这两个子节点都是一个<code>ArithmaticExpression</code>，<code>ArithmaticExpression</code>中值的获取仍需要调用函数<code>EvaluateJoin(left_tuple, left_schema, right_tuple, right_schema)</code>，因为表达式都需要用到tuple1和tuple2，再在最底层的是<code>ColumnValueExpression</code>(如上面的<code>t1.x</code>)或者是<code>ConstantValueExpression</code>（如上面的100），这两个的<code>EvaluateJoin</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ConstantValueExpression</span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">EvaluateJoin</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple *left_tuple, <span class="hljs-type">const</span> Schema &amp;left_schema, <span class="hljs-type">const</span> Tuple *right_tuple,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> Schema &amp;right_schema)</span> <span class="hljs-type">const</span> -&gt; Value override &#123;<br>    <span class="hljs-keyword">return</span> val_;<br>&#125;<br><br><span class="hljs-comment">// ColumnValueExpression</span><br><span class="hljs-keyword">auto</span> <span class="hljs-title function_">EvaluateJoin</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple *left_tuple, <span class="hljs-type">const</span> Schema &amp;left_schema, <span class="hljs-type">const</span> Tuple *right_tuple,</span><br><span class="hljs-params">                    <span class="hljs-type">const</span> Schema &amp;right_schema)</span> <span class="hljs-type">const</span> -&gt; Value override &#123;<br>    <span class="hljs-keyword">return</span> tuple_idx_ == <span class="hljs-number">0</span> ? left_tuple-&gt;GetValue(&amp;left_schema, col_idx_)<br>                           : right_tuple-&gt;GetValue(&amp;right_schema, col_idx_);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a><strong>Aggregation</strong></h2><p>在实现这个算子的时候，由于我对Aggregation的理解不深入，导致很困难。我们先来简单介绍一下这个算子到底是如何使用的。首先，这个算子并不是严格的火山模型，它需要在<code>Init</code>函数中把所有的数据条目都计算出来，再在<code>Next</code>函数中不断获取<code>Tuple</code>。</p><p>例如有下面这个SQL语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CQL">select min(colA-colB),max(colA+colB) from table_1 group by (colC-colD) (colE+colF);<br></code></pre></td></tr></table></figure><p>在Aggregation中，有一个<code>AggregateKey</code>，它只有一个成员<code>std::vector&lt;Value&gt; group_bys_;</code>，还有一个<code>AggregateValue</code>，它也只有一个成员<code>std::vector&lt;Value&gt; aggregates_;</code>。</p><p><code>AggregationExecutor</code>中有两个函数，它们都根据<code>expr</code>表达式计算出相应的结果。</p><p>我们再来看上面的SQL语句，也就不难理解这里面的设计了。在这里<code>colC-colD</code>和<code>colE+colF</code>是一个<code>AggregateKey</code>，<code>colC-colD</code>和<code>colE+colF</code>分别是<code>group_bys_[0]</code>和<code>group_bys_[1]</code>。</p><p>同样<code>colA-colB</code>和<code>colA+colB</code>是一个<code>AggregateValue</code>，<code>colA-colB</code>和<code>colA+colB</code>分别是<code>aggregates_[0]</code>和<code>aggregates_[1]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">MakeAggregateKey</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple *tuple)</span> -&gt; AggregateKey &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Value&gt; keys;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;expr : plan_-&gt;GetGroupBys()) &#123;<br>      keys.emplace_back(expr-&gt;Evaluate(tuple, child_-&gt;GetOutputSchema()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;keys&#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/** @return The tuple as an AggregateValue */</span><br>  <span class="hljs-keyword">auto</span> <span class="hljs-title function_">MakeAggregateValue</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple *tuple)</span> -&gt; AggregateValue &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Value&gt; vals;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;expr : plan_-&gt;GetAggregates()) &#123;<br>      vals.emplace_back(expr-&gt;Evaluate(tuple, child_-&gt;GetOutputSchema()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;vals&#125;;<br>  &#125;<br></code></pre></td></tr></table></figure><p>Aggregation就是我们所说的聚合，我们要把同一个<code>AggregateKey</code>的所有数据作为一组，聚合函数可以计算某一组里面的最小值，最大值或者某一个字段的总和。所需要的数据结构不就是一个<code>unordered_map</code>吗？</p><p><code>AggregationExecutor</code>中有一个<code>SimpleAggregationHashTable aht_</code>，我们来看一下这个<code>SimpleAggregationHashTable</code>。它最主要的数据结构如下：</p><p><code>ht_</code>每一个不同的<code>AggregateKey</code>都<code>AggregateValue</code>，<code>agg_types_</code>就是聚合函数的类型，例如在上面的SQL语句中，<code>agg_types_[0]</code>是<code>MIN</code>，<code>agg_types_[1]</code>是<code>MAX</code>，它们分别存在<code>AggregateValue</code>中的<code>vals[0]</code>和<code>vals[1]</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** The hash table is just a map from aggregate keys to aggregate values */</span>  <br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;AggregateKey, AggregateValue&gt; ht_&#123;&#125;;<br><span class="hljs-comment">/** The aggregate expressions that we have */</span><br><span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;AbstractExpressionRef&gt; &amp;agg_exprs_;<br><span class="hljs-comment">/** The types of aggregations that we have */</span><br><span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;AggregationType&gt; &amp;agg_types_;<br></code></pre></td></tr></table></figure><p>在<code>Init</code>函数中，首先需要把数据都准备好，把相应的<code>&#123;MakeAggregateKey(&amp;tuple), MakeAggregateValue(&amp;tuple)&#125;</code>添加到<code>map</code>中，如果不存在这个<code>AggregateKey</code>，<code>map</code>首先要<code>Insert</code>一个初始值，然后调用<code>CombineAggregateValues(&amp;ht_[agg_key], agg_val);</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AggregationExecutor::Init</span><span class="hljs-params">()</span> &#123;<br>  ........<br>  <span class="hljs-keyword">while</span> (child_-&gt;Next(&amp;tuple, &amp;rid)) &#123;<br>    aht_.InsertCombine(MakeAggregateKey(&amp;tuple), MakeAggregateValue(&amp;tuple));<br>  &#125;<br>  ........<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertCombine</span><span class="hljs-params">(<span class="hljs-type">const</span> AggregateKey &amp;agg_key, <span class="hljs-type">const</span> AggregateValue &amp;agg_val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ht_.count(agg_key) == <span class="hljs-number">0</span>) &#123;<br>      ht_.insert(&#123;agg_key, GenerateInitialAggregateValue()&#125;);<br>    &#125;<br>    CombineAggregateValues(&amp;ht_[agg_key], agg_val);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>CombineAggregateValues</code>就是更新这个group聚合的信息，例如<code>agg_types_[i]</code>如果是<code>CountStarAggregate</code>类型(计算某个Group内<code>Tuple</code>的条目数)，就需要对相应的<code>result[i]</code>进行加1即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// CombineAggregateValues(AggregateValue *result, const AggregateValue &amp;input)</span><br><span class="hljs-keyword">switch</span> (agg_types_[i]) &#123;<br>    <span class="hljs-keyword">case</span> AggregationType::CountStarAggregate:<br>      result-&gt;aggregates_[i] = result-&gt;aggregates_[i].Add(ValueFactory::GetIntegerValue(<span class="hljs-number">1</span>));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AggregationType::CountAggregate:<br>      <span class="hljs-keyword">if</span> (result-&gt;aggregates_[i].IsNull()) &#123;<br>        result-&gt;aggregates_[i] = ValueFactory::GetIntegerValue(<span class="hljs-number">0</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (!input.aggregates_[i].IsNull()) &#123;<br>        result-&gt;aggregates_[i] = result-&gt;aggregates_[i].Add(ValueFactory::GetIntegerValue(<span class="hljs-number">1</span>));<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AggregationType::SumAggregate:<br>      <span class="hljs-keyword">if</span> (result-&gt;aggregates_[i].IsNull()) &#123;<br>        result-&gt;aggregates_[i] = input.aggregates_[i];<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!input.aggregates_[i].IsNull()) &#123;<br>        result-&gt;aggregates_[i] = result-&gt;aggregates_[i].Add(input.aggregates_[i]);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    ......<br></code></pre></td></tr></table></figure><h2 id="TopN"><a href="#TopN" class="headerlink" title="TopN"></a><strong>TopN</strong></h2><p>这个算子就是找到最大或者最小的N个<code>Tuple</code>，很显然这个TopN也不满足火山模型，它也是在<code>Init</code>函数中把所有的N条数据条目准备好，然后再在<code>Next</code>函数中不断从内存中获取出来。那么该如何实现呢，我们可以使用<code>std::priority_queue</code>来实现，当然，还要给这个优先队列写一个比较器函数。</p><h2 id="Sort-Limit-As-TopN"><a href="#Sort-Limit-As-TopN" class="headerlink" title="Sort + Limit As TopN"></a><strong>Sort + Limit As TopN</strong></h2><p>接下来是实现一个优化了。</p><p>如果一个执行算子的类型是Limit，而它的子执行算子的类型则是Sort,(Limit算子只有唯一的一个子执行器)，这样就可以进行优化了。我们可以把这两个算子合并成一个TopN算子。那么Bustub是如何进行优化的呢?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">Optimizer::Optimize</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef &#123;<br>  <span class="hljs-keyword">if</span> (force_starter_rule_) &#123;<br>    <span class="hljs-comment">// Use starter rules when `force_starter_rule_` is set to true.</span><br>    <span class="hljs-keyword">auto</span> p = plan;<br>    p = OptimizeMergeProjection(p);<br>    p = OptimizeMergeFilterNLJ(p);<br>    p = OptimizeNLJAsIndexJoin(p);<br>    p = OptimizeOrderByAsIndexScan(p);<br>    p = OptimizeSortLimitAsTopN(p);<br>    <span class="hljs-keyword">return</span> p;<br>  &#125;<br>  <span class="hljs-comment">// By default, use user-defined rules.</span><br>  <span class="hljs-keyword">return</span> OptimizeCustom(plan);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先来看一下另一个优化OrderByAsIndexScan是怎么实现的。这个优化的条件是父执行器是一个Sort执行器，子节点是一个Seqscan执行器，并且父节点参与排序的字段只有一个，这样就可以优化这两个为一个IndexScan算子。下面是这个优化的具体实现。</p><p>我们发现<code>children.emplace_back(OptimizeOrderByAsIndexScan(child));</code>这里就是一个递归，也就是说，对这棵Plan Tree进行后序遍历，自顶而上替换可以优化的节点为IndexScan。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">Optimizer::OptimizeOrderByAsIndexScan</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef &#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;AbstractPlanNodeRef&gt; children;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child : plan-&gt;GetChildren()) &#123;<br>    children.emplace_back(OptimizeOrderByAsIndexScan(child));<br>  &#125;<br>  <span class="hljs-keyword">auto</span> optimized_plan = plan-&gt;CloneWithChildren(<span class="hljs-built_in">std</span>::move(children));<br><br>  <span class="hljs-keyword">if</span> (optimized_plan-&gt;GetType() == PlanType::Sort) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;sort_plan = dynamic_cast&lt;<span class="hljs-type">const</span> SortPlanNode &amp;&gt;(*optimized_plan);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;order_bys = sort_plan.GetOrderBy();<br><br>    <span class="hljs-comment">// Has exactly one order by column</span><br>    <span class="hljs-keyword">if</span> (order_bys.size() != <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> optimized_plan;<br>    &#125;<br><br>    <span class="hljs-comment">// Order type is asc or default</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[order_type, expr] = order_bys[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span> (!(order_type == OrderByType::ASC || order_type == OrderByType::DEFAULT)) &#123;<br>      <span class="hljs-keyword">return</span> optimized_plan;<br>    &#125;<br><br>    <span class="hljs-comment">// Order expression is a column value expression</span><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> *column_value_expr = dynamic_cast&lt;ColumnValueExpression *&gt;(expr.get());<br>    <span class="hljs-keyword">if</span> (column_value_expr == nullptr) &#123;<br>      <span class="hljs-keyword">return</span> optimized_plan;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> order_by_column_id = column_value_expr-&gt;GetColIdx();<br><br>    <span class="hljs-comment">// Has exactly one child</span><br>    BUSTUB_ENSURE(optimized_plan-&gt;children_.size() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Sort with multiple children?? Impossible!&quot;</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child_plan = optimized_plan-&gt;children_[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">if</span> (child_plan-&gt;GetType() == PlanType::SeqScan) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;seq_scan = dynamic_cast&lt;<span class="hljs-type">const</span> SeqScanPlanNode &amp;&gt;(*child_plan);<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> *table_info = catalog_.GetTable(seq_scan.GetTableOid());<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> indices = catalog_.GetTableIndexes(table_info-&gt;name_);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> *index : indices) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;columns = index-&gt;key_schema_.GetColumns();<br>        <span class="hljs-keyword">if</span> (columns.size() == <span class="hljs-number">1</span> &amp;&amp;<br>            columns[<span class="hljs-number">0</span>].GetName() == table_info-&gt;schema_.GetColumn(order_by_column_id).GetName()) &#123;<br>          <span class="hljs-comment">// Index matched, return index scan instead</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;IndexScanPlanNode&gt;(optimized_plan-&gt;output_schema_, index-&gt;index_oid_);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> optimized_plan;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了上面的提示，我们不难写出SortLimitAsTopN的优化了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">Optimizer::OptimizeSortLimitAsTopN</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractPlanNodeRef &amp;plan)</span> -&gt; AbstractPlanNodeRef &#123;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;AbstractPlanNodeRef&gt; children;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;child : plan-&gt;GetChildren()) &#123;<br>    children.emplace_back(OptimizeSortLimitAsTopN(child));<br>  &#125;<br>  <span class="hljs-keyword">auto</span> optimized_plan = plan-&gt;CloneWithChildren(<span class="hljs-built_in">std</span>::move(children));<br><br>  <span class="hljs-keyword">if</span> (optimized_plan-&gt;GetType() == PlanType::Limit) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;limit_plan = dynamic_cast&lt;<span class="hljs-type">const</span> LimitPlanNode &amp;&gt;(*optimized_plan);<br><br>    <span class="hljs-comment">// limit 就只有一个 子执行器</span><br>    BUSTUB_ASSERT(limit_plan.children_.size() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Limit plan must have one and only one child&quot;</span>);<br>    <span class="hljs-keyword">if</span> (limit_plan.children_[<span class="hljs-number">0</span>]-&gt;GetType() == PlanType::Sort) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;sort_plan = dynamic_cast&lt;<span class="hljs-type">const</span> SortPlanNode &amp;&gt;(*optimized_plan-&gt;GetChildAt(<span class="hljs-number">0</span>));<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;order_bys = sort_plan.GetOrderBy();<br><br>      BUSTUB_ENSURE(sort_plan.children_.size() == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Sort Plan should have exactly 1 child.&quot;</span>);<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_shared&lt;TopNPlanNode&gt;(limit_plan.output_schema_, sort_plan.GetChildAt(<span class="hljs-number">0</span>), order_bys,<br>                                            limit_plan.limit_);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> optimized_plan;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P4实验笔记</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P4%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P4%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>P4需要完成以下任务：</p><ul><li>Lock Manager：锁管理器，利用 2PL 实现并发控制。支持 <code>REPEATABLE_READ</code>、<code>READ_COMMITTED</code> 和 <code>READ_UNCOMMITTED</code> 三种隔离级别，支持 <code>SHARED</code>、<code>EXCLUSIVE</code>、<code>INTENTION_SHARED</code>、<code>INTENTION_EXCLUSIVE</code> 和 <code>SHARED_INTENTION_EXCLUSIVE</code> 五种锁，支持 table 和 row 两种锁粒度，支持锁升级。Project 4 重点部分。</li><li>Deadlock Detection：死锁检测，运行在一个 background 线程，每间隔一定时间检测当前是否出现死锁，并挑选合适的事务将其 abort 以解开死锁。</li><li>Concurrent Query Execution：修改之前实现的 <code>SeqScan</code>、<code>Insert</code> 和 <code>Delete</code> 算子，加上适当的锁以实现并发的查询。</li></ul><p>建议在阅读此文前，先看一下我的上篇文章[Bustub中的并发控制]。</p><h2 id="Task-1-Lock-Manager"><a href="#Task-1-Lock-Manager" class="headerlink" title="Task-1 Lock Manager"></a><strong>Task-1 Lock Manager</strong></h2><p>大部分需要注意的内容都在 <code>lock_manager.h</code> 的 LOCK NOTE 和 UNLOCK NOTE 里了，并且我在[Bustub中的并发控制]中也简单介绍了这样做实现不同隔离机制的原理。</p><p>首先理一理 Lock Manager 的结构：</p><ul><li><code>table_lock_map_</code>：记录 table 和与其相关锁请求的映射关系。</li><li><code>row_lock_map_</code>：记录 row 和与其相关锁请求的映射关系。</li></ul><p>这两个 map 的值均为锁请求队列 <code>LockRequestQueue</code>：</p><ul><li><code>request_queue_</code>：实际存放锁请求的队列。</li><li><code>cv_</code> &amp; <code>latch_</code>：条件变量和锁，配合使用可以实现经典的等待资源的模型。</li><li><code>upgrading_</code>：正在此资源上尝试锁升级的事务 id。</li></ul><p>锁请求以 <code>LockRequest</code> 类表示：</p><ul><li><code>txn_id_</code>：发起此请求的事务 id。</li><li><code>lock_mode_</code>：请求锁的类型。</li><li><code>oid_</code>：在 table 粒度锁请求中，代表 table id。在 row 粒度锁请求中，表示 row 属于的 table 的 id。</li><li><code>rid_</code>：仅在 row 粒度锁请求中有效。指 row 对应的 rid。</li><li><code>granted_</code>：是否已经对此请求授予锁？</li></ul><p>Lock Manager处理事务发送的锁请求，并且记录锁请求的状态。授予的锁和未授予的锁请求都存在锁请求队列<code>LockRequestQueue</code>中。</p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a><strong>锁升级</strong></h3><p>Bustub中的锁升级是什么，为什么需要锁升级?</p><p>应用场景：假设事务T1读取 table_1 的所有 Tuple，事务T2先读取 table_1 的所有 Tuple，然后执行一些别的操作(因为二阶段锁的限制这里可能并不能立马释放读锁)，再写 table_1 的一些Tuple。</p><p>如果事务T2直接获取到了table_1的IX锁，那么事务T1获取table_1的S锁就会发生阻塞。我们可以有更好的解决方案，比如事务T2先给table_1上S类型锁，要写的时候再上X类型锁。这里就需要锁升级了。T2会尝试把原来的S类型锁升级为X类型的锁，它对某个资源始终最多只持有一把锁。判断是否可以进行升级需要已授予的锁是否和锁升级的类型兼容，如果不兼容就得等待。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a><strong>Lock</strong></h3><p>接下来，我们以<code>LockTable(Transaction *txn, LockMode lock_mode, const table_oid_t &amp;oid)</code>为例，介绍一下Lock上锁的过程。</p><p><strong>第一步：逻辑状态的检查</strong></p><p>若 txn 处于 Abort&#x2F;Commit 状态，抛逻辑异常，不应该有这种情况出现。</p><p>若 txn 处于 Shrinking 状态，则需要检查 txn 的隔离级别和当前锁请求类型，不符合要求的锁请求需要把事务状态设置成ABORT，并抛出<code>TransactionAbortException</code>的异常。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">REPEATABLE_READ:<br>   The transaction is required <span class="hljs-keyword">to</span> take <span class="hljs-literal">all</span> locks.<br>   All locks are allowed <span class="hljs-keyword">in</span> the GROWING <span class="hljs-keyword">state</span><br>   No locks are allowed <span class="hljs-keyword">in</span> the SHRINKING <span class="hljs-keyword">state</span><br><br>READ_COMMITTED:<br>   The transaction is required <span class="hljs-keyword">to</span> take <span class="hljs-literal">all</span> locks.<br>   All locks are allowed <span class="hljs-keyword">in</span> the GROWING <span class="hljs-keyword">state</span><br>   Only IS, S locks are allowed <span class="hljs-keyword">in</span> the SHRINKING <span class="hljs-keyword">state</span><br><br>READ_UNCOMMITTED:<br>   The transaction is required <span class="hljs-keyword">to</span> take only IX, X locks.<br>   X, IX locks are allowed <span class="hljs-keyword">in</span> the GROWING <span class="hljs-keyword">state</span>.<br>   S, IS, SIX locks are never allowed<br></code></pre></td></tr></table></figure><p><strong>第二步：获取相应资源的锁请求队列</strong></p><p>如果是相应资源的第一个锁请求还需要创建新的锁请求队列。这里要注意加锁保护数据结构。</p><p><strong>第三步：检查此锁请求是否为一次锁升级。</strong></p><p>首先，记得对 queue 加锁。</p><p>granted 和 waiting 的锁请求均放在同一个队列里，我们需要遍历队列查看有没有与当前事务 id（我习惯叫做 tid）相同的请求。如果存在这样的请求，则代表当前事务在此前已经得到了在此资源上的一把锁，接下来可能需要锁升级。</p><blockquote><p>需要注意的是，这个请求的 <code>granted_</code> 一定为 true。因为假如事务此前的请求还没有被通过，事务会被阻塞在 LockManager 中，不可能再去尝试获取另一把锁。</p></blockquote><p>现在我们找到了此前已经获取的锁，开始尝试锁升级。首先，判断此前授予锁类型是否与当前请求锁类型相同。若相同，则代表是一次重复的请求，直接返回。否则进行下一步检查。</p><p>接下来，判断当前资源上是否有另一个事务正在尝试升级（<code>queue-&gt;upgrading_ == INVALID_TXN_ID</code>）。若有，则终止当前事务，抛出 <code>UPGRADE_CONFLICT</code> 异常。因为不允许多个事务在同一资源上同时尝试锁升级。</p><ul><li>为什么一个资源不允许多个事务同时进行锁升级呢?</li></ul><blockquote><p>如果不同事务可以同时对一个资源进行锁升级，那么对于某个资源R，假如事务T1和T2都尝试(阻塞)把IS类型的锁升级为S类型(因为假设事务T3获取了SIX类型的锁所以导致阻塞这两个锁升级请求)，R的LockQueue中删除了T1和T2原来的锁请求，都插入了新升级的锁请求(等待授予，grant_为false)，因为锁升级具有最高的优先级，所以需要把请求插入到第一个grant不是true的请求的前面，但这也却导致了一个问题，如果T1先插入，T2后插入，T2的锁升级请求在T1锁升级请求的前面了，也就是说反而T2比T1具有更大的优先级了，这不符合逻辑，所以这里为了降低实现的复杂度，采用了这种粗暴的方法。但其实可以新建一个专门的锁升级队列就可以解决这个问题从而实现统一资源的不同事务的同步锁升级了。</p></blockquote><p><strong>第四步：将锁请求插入到队列中</strong></p><p>不管是锁升级请求还是平凡的锁请求，都需要把请求添加到队列中。这里不同的是锁升级请求和平凡锁请求插入的位置不同。</p><p><strong>第五步，尝试获取锁。</strong></p><p>这是最后一步，也是最核心的一步，体现了 Lock Manager 的执行模型。首先，需要清楚条件变量的使用场景。</p><p>这里需要使用条件变量，先给出条件变量经典的使用形式：</p><p><code>wait()</code> 函数接受一个 <code>std::unique_lock&lt;std::mutex&gt;</code> 对象作为参数，该参数通常是通过调用 <code>std::unique_lock</code> 对 <code>std::mutex</code> 对象进行上锁而获得的。在调用 <code>wait()</code> 函数之前，必须先获得互斥锁，以确保在等待期间其他线程无法修改条件变量所关联的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::unique_lock&lt;<span class="hljs-built_in">std</span>::mutex&gt; <span class="hljs-title function_">lock</span><span class="hljs-params">(latch)</span>;<br><span class="hljs-keyword">while</span> (!resource) &#123;<br>    cv.wait(lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>条件变量与互斥锁配合使用。首先需要持有锁，并查看是否能够获取资源。这个锁与资源绑定，是用来保护资源的锁。若暂时无法获取资源，则调用条件变量的 wait 函数。调用 wait 函数后，latch 将自动<strong>释放</strong>，并且当前线程被挂起，以节省资源。这就是阻塞的过程。此外，允许有多个线程在 wait 同一个 latch。</p><p>在 <code>GrantLock()</code> 中，Lock Manager 会判断是否可以满足当前锁请求。若可以满足，则返回 true，事务成功获取锁，并退出循环。若不能满足，则返回 false，事务暂时无法获取锁，在 wait 处阻塞，等待资源状态变化时被唤醒并再次判断是否能够获取锁。资源状态变化指的是什么？其他事务释放了锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!GrantLock(upgraded_lock_request, lock_request_queue)) &#123;<br>    lock_request_queue-&gt;cv_.wait(lock);<br>    <br>    <span class="hljs-keyword">if</span> (txn-&gt;GetState() == TransactionState::ABORTED) &#123;<br>      lock_request_queue-&gt;upgrading_ = INVALID_TXN_ID;<br>      lock_request_queue-&gt;request_queue_.remove(upgraded_lock_request);<br>      lock_request_queue-&gt;cv_.notify_all();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>接下来是 <code>GrantLock()</code> 函数。在此函数中，我们需要判断当前锁请求是否能被满足。</p><ol><li>判断兼容性。遍历请求队列，查看当前锁请求是否与所有的已经 granted 的请求兼容。需要注意的是，在我的实现中 granted 请求不一定都在队列头部，因此需要完全遍历整条队列。锁兼容矩阵可以在 Lecture slides 中查看。若全部兼容，则通过检查。否则直接返回 false。当前请求无法被满足。</li><li>判断优先级。锁请求会以严格的 FIFO 顺序依次满足。只有当前请求为请求队列中优先级最高的请求时，才允许授予锁。优先级可以这样判断：</li><li>如果队列中存在锁升级请求，若锁升级请求正为当前请求，则优先级最高。否则代表其他事务正在尝试锁升级，优先级高于当前请求。</li><li>若队列中不存在锁升级请求，则遍历队列。如果，当前请求是第一个 waiting 状态的请求，则代表优先级最高。如果当前请求前面还存在其他 waiting 请求，则要判断当前请求是否前面的 waiting 请求兼容。若兼容，则仍可以视为优先级最高。若存在不兼容的请求，则优先级不为最高。</li></ol><p><code>GrantLock</code>函数首先遍历队列中所有的<code>lock_request</code>(进入的时候已经获取了锁，<code>wait</code>被唤醒需要重新获取锁才可以继续执行)，如果这个锁请求已被授予，则需要判断当前的锁请求与这个已授予的锁请求是否是兼容的，如果不兼容直接返回false。如果遍历到第一个没有被授予的锁请求，跟进先进先出的原则，如果这个锁请求和参数<code>lock_request</code>是同一个的话，那么这个锁请求的优先级就是最高的，直接返回true，如果第一个没有被授予的锁请求不是<code>lock_request</code>的话，那么证明当前的锁请求不是优先级最高的，那么需要返回false。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">LockManager::GrantLock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;LockRequest&gt; &amp;lock_request,</span><br><span class="hljs-params">                            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;LockRequestQueue&gt; &amp;lock_request_queue)</span> -&gt; <span class="hljs-type">bool</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;lrq : lock_request_queue-&gt;request_queue_) &#123;<br>    <span class="hljs-comment">// 首先判断兼容性</span><br>    <span class="hljs-keyword">if</span> (lrq-&gt;granted_ &amp;&amp; !IsLockModeCompatible(lrq-&gt;lock_mode_, lock_request-&gt;lock_mode_)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 先进先出的原则，前面存在没有授予锁的请求，直接return false</span><br>    <span class="hljs-keyword">if</span> (!lrq-&gt;granted_) &#123;<br>      <span class="hljs-keyword">if</span> (lock_request.get() != lrq.get()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="UnLock"><a href="#UnLock" class="headerlink" title="UnLock"></a><strong>UnLock</strong></h3><p>仍以 table lock 为例。Unlock 的流程比 Lock 要简单不少。</p><p>首先，由于是 table lock，在释放时需要先检查其下的所有 row lock 是否已经释放。</p><p>接下来是 table lock 和 row lock 的公共步骤：</p><p><strong>第一步，获取对应的 lock request queue。</strong></p><p><strong>第二步，遍历请求队列，找到 unlock 对应的 granted 请求。</strong></p><p>若不存在对应的请求，抛 <code>ATTEMPTED_UNLOCK_BUT_NO_LOCK_HELD</code> 异常。</p><p>找到对应的请求后，根据事务的隔离级别和锁类型修改其状态。</p><p>当隔离级别为 <code>REPEATABLE_READ</code> 时，S&#x2F;X 锁释放会使事务进入 Shrinking 状态。当为 <code>READ_COMMITTED</code> 时，只有 X 锁释放使事务进入 Shrinking 状态。当为 <code>READ_UNCOMMITTED</code> 时，X 锁释放使事务 Shrinking，S 锁不会出现。</p><p>之后，在请求队列中 remove unlock 对应的请求，并将请求 delete。</p><p>在锁成功释放后，调用 <code>cv_.notify_all()</code> 唤醒所有阻塞在此 table 上的事务，检查能够获取锁。</p><h2 id="Task-2-Deadlock-Detection"><a href="#Task-2-Deadlock-Detection" class="headerlink" title="Task-2 Deadlock Detection"></a><strong>Task-2 Deadlock Detection</strong></h2><p>在前面讲过，二阶段锁协议并不保证不会出现死锁，那么我们需要进行死锁检测，如果发生了死锁，则需要终止某一个事务。</p><p>在阻塞过程中有可能会出现多个事务的循环等待，而循环等待会造成死锁。在 Bustub 中我们采用一个 Background Deadlock Detection 线程来定时检查当前是否出现死锁。</p><p>我们用 wait for 图来表示事务之间的等待关系。wait for 是一个有向图，<code>t1-&gt;t2</code> 即代表 t1 事务正在等待 t2 事务释放资源。当 wait for 图中存在环时，即代表出现死锁，需要挑选事务终止以打破死锁。</p><p>我们并不需要时刻维护 wait for 图，而是在死锁检测线程被唤醒时，根据当前请求队列构建 wait for 图，再通过 wait for 图判断是否存在死锁。当判断完成后，将丢弃当前 wait for 图。下次线程被唤醒时再重新构建。</p><p>最常见的有向图环检测算法包括 DFS 和拓扑排序。在这里我们选用 DFS 来进行环检测。构建 wait for 图时要保证搜索的确定性。始终从 tid 较小的节点开始搜索，在选择邻居时，也要优先搜索 tid 较小的邻居。</p><p>构建 wait for 图的过程是，遍历 <code>table_lock_map</code> 和 <code>row_lock_map</code> 中所有的请求队列，对于每一个请求队列，用一个二重循环将所有满足等待关系的一对 tid 加入 wait for 图的边集。满足等待关系是指，对于两个事务 a 和 b，a 是 waiting 请求，b 是 granted 请求，则生成 <code>a-&gt;b</code> 一条边。</p><p>构建好 wait for 图后，就可以判断有向图中是否出现了环，如果出现了环，就需要把其中最年轻的事务(<code>txn_id</code>最小)状态设置成ABORT。 </p><h2 id="Task-3-Concurrent-Query-Execution"><a href="#Task-3-Concurrent-Query-Execution" class="headerlink" title="Task-3 Concurrent Query Execution"></a><strong>Task-3 Concurrent Query Execution</strong></h2><p>最后就是为Seqscan、Insert和Delete加锁实现不同的隔离级别了。</p><h3 id="Seqscan"><a href="#Seqscan" class="headerlink" title="Seqscan"></a><strong>Seqscan</strong></h3><p>如果隔离级别是 <code>READ_UNCOMMITTED</code> 则无需加锁。加锁失败则抛出 <code>ExecutionException</code> 异常。</p><p>在 <code>READ_COMMITTED</code> 下，在 <code>Next()</code> 函数中，若表中已经没有数据，则提前释放之前持有的锁。在 <code>REPEATABLE_READ</code> 下，在 Commit&#x2F;Abort 时统一释放，无需手动释放。</p><p>那应该加什么锁呢，直观来说应该对Table加S类型的锁就行了。但如果深入了解Bustub的代码，发现直接对Table加S类型的锁是错误的，而应该对表先加IS锁，然后再在下面的tuple加S锁。</p><ul><li>Q1:为什么对于Seqscan，需要对表加IS锁再对tuple加S锁，为什么不能够直接对表加S锁呢？</li></ul><blockquote><p>主要是后续可以进行一个merge filter scan的优化，把filter放进SeqScan里，这种情况下就是表IS+符合条件的行S。</p><p>另外，如果直接表S的话，执行一个DELETE … WHERE …，同一个query里先在下层SeqScan加了S锁，又尝试在Delete里加IX锁，但是S不能升级为IX，会导致这条query执行不了，升级不兼容。所以还是SeqScan也用表IS+行S比较容易实现。</p></blockquote><ul><li>Q2:在 <code>READ_COMMITTED</code> 下，在 <code>Next()</code> 函数中，若表中已经没有数据，则提前释放之前持有的锁。在 <code>REPEATABLE_READ</code> 下，在 Commit&#x2F;Abort 时统一释放，无需手动释放，为什么？</li></ul><blockquote><p>在我的上篇文章[Bustub中的并发控制]中讲过，读未提交的Seqscan读取是不需要进行加锁的。</p><p>在读已提交中，为什么要在<code>Next</code>函数中如果没有数据，释放所有的锁呢。在前面的加锁规则中我们也说到过，读已提交事务解S类型的锁并不改变二阶段封锁协议中的状态，所以这里提前释放S锁，后面就有可能再次获取这个tuple的S锁(读已提交在<code>SHRINKING</code>阶段仍可以加S锁)，这也就是为什么读已提交会出现不可重复读的问题。</p><p>而可重复读的事务把所有锁的释放推到了事务提交或终止后，在读取某条tuple时，只能<code>lock-S(tuple-1) ... read(tuple1) ... read(tuple1)...unlock(tuple-1)</code>，所以就不会出现前后读取不一致的问题。</p></blockquote><h3 id="Insert-Delete"><a href="#Insert-Delete" class="headerlink" title="Insert &amp; Delete"></a><strong>Insert &amp; Delete</strong></h3><p>在 <code>Init()</code> 函数中，为表加上 IX 锁，再为行加 X 锁。</p><h2 id="LeaderBoard-Task"><a href="#LeaderBoard-Task" class="headerlink" title="LeaderBoard Task"></a><strong>LeaderBoard Task</strong></h2><p>这里需要实现几个小优化：</p><h3 id="Predicate-pushdown-to-SeqScan"><a href="#Predicate-pushdown-to-SeqScan" class="headerlink" title="Predicate pushdown to SeqScan"></a><strong>Predicate pushdown to SeqScan</strong></h3><p>这就是谓词下推到Seqscan的算子中，我们在上面已经提到了，这需要先对整张表上IS锁，再对行上S锁实现读取。</p><h3 id="Update算子"><a href="#Update算子" class="headerlink" title="Update算子"></a><strong>Update算子</strong></h3><p>在了解完<code>TablePage</code>的结构和<code>MarkDelete</code>以及<code>ApplyDelete</code>函数后，我误认为Bustub貌似不能够实现Update操作，原因是Delete采用了比较取巧的行为将<code>size</code>的第32位置1，但Update后tuple原来的大小可是彻底消失了，事务Abort之后又该怎么恢复呢。可是还是证明我想错了，Bustub能够实现Update操作，主要原因就是<code>Transaction</code>维护了一个写的集合。这样做Update,Insert、Delete操作的时候都需要把这些写过的tuple记录到write set里面，方便事务Abort后进行恢复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> <span class="hljs-title function_">GetWriteSet</span><span class="hljs-params">()</span> -&gt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;TableWriteRecord&gt;&gt; &#123; <span class="hljs-keyword">return</span> table_write_set_; &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableWriteRecord</span> &#123;</span><br> public:<br>  TableWriteRecord(RID rid, WType wtype, <span class="hljs-type">const</span> Tuple &amp;tuple, TableHeap *table)<br>      : rid_(rid), wtype_(wtype), tuple_(tuple), table_(table) &#123;&#125;<br><br>  RID rid_;<br>  WType wtype_;<br>  <span class="hljs-comment">/** The tuple is only used for the update operation. */</span><br>  Tuple tuple_;<br>  <span class="hljs-comment">/** The table heap specifies which table this write record is for. */</span><br>  TableHeap *table_;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TransactionManager::Abort</span><span class="hljs-params">(Transaction *txn)</span> &#123;<br>  txn-&gt;SetState(TransactionState::ABORTED);<br>  <span class="hljs-comment">// Rollback before releasing the lock.</span><br>  <span class="hljs-keyword">auto</span> table_write_set = txn-&gt;GetWriteSet();<br>  <span class="hljs-keyword">while</span> (!table_write_set-&gt;empty()) &#123;<br>    <span class="hljs-keyword">auto</span> &amp;item = table_write_set-&gt;back();<br>    <span class="hljs-keyword">auto</span> *table = item.table_;<br>    <span class="hljs-keyword">if</span> (item.wtype_ == WType::DELETE) &#123;<br>      table-&gt;RollbackDelete(item.rid_, txn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.wtype_ == WType::INSERT) &#123;<br>      <span class="hljs-comment">// Note that this also releases the lock when holding the page latch.</span><br>      table-&gt;ApplyDelete(item.rid_, txn);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (item.wtype_ == WType::UPDATE) &#123;<br>      <span class="hljs-comment">// 再调用UpdateTuple函数更新回去，妙妙妙!</span><br>      table-&gt;UpdateTuple(item.tuple_, item.rid_, txn);<br>    &#125;<br>    table_write_set-&gt;pop_back();<br>  &#125;<br>  table_write_set-&gt;clear();<br>    <br>  ........<br>  <span class="hljs-comment">// 接下来可能还需要恢复索引呢</span><br></code></pre></td></tr></table></figure><p>Update算子的实现就很清楚了，首先为整张表上一把IX类型的锁，然后再对要更新的tuple加上X锁，但不立马释放，等到事务结束的时候统一释放(所以每一个事务都有表锁集合和行锁集合)。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P2实验笔记(2)</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P2%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P2%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>第一部分是设计好遍历B+树的迭代器，第二部分是实现B+树的并发。</p><h2 id="B-树中的并发控制"><a href="#B-树中的并发控制" class="headerlink" title="B+树中的并发控制"></a><strong>B+树中的并发控制</strong></h2><p>我们会使用一种特殊的加锁方式，叫做 latch crabbing。顾名思义，就像螃蟹一样，移动一只脚，放下，移动另一只脚，再放下。基本思想是： 1. 先锁住 parent page， 2. 再锁住 child page， 3. 假设 child page 是<em>安全</em>的，则释放 parent page 的锁。<em>安全</em>指当前 page 在当前操作下一定不会发生 split&#x2F;steal&#x2F;merge。同时，<em>安全</em>对不同操作的定义是不同的，Search 时，任何节点都安全；Insert 时，判断 max size；Delete 时，判断 min size。</p><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a><strong>Search</strong></h3><p>Search 时，从 root page 开始，先给 parent 上读锁，然后获取到child page，再给 child page 上读锁，随后就可以释放 parent page 的锁。如此向下递归。</p><img src="/img/bustub/search-1.jpg" style="zoom:50%;"><img src="/img/bustub/search-2.jpg" style="zoom:50%;"><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a><strong>Insert</strong></h3><p>Insert 时，从 root page 开始，先给 parent 上写锁，再给 child page 上写锁。假如 child page 安全，则释放所有祖先的锁；否则不释放锁，继续向下递归。</p><blockquote><p>这里的child page安全判断就是上面说的，这次操作最多只会影响child page的的自身结构，并不会波及其 parent page，这样一来我们就可以对 parent page进行解锁。</p><p>比如说，假设这是一个Insert，该page即使加上一条数据后仍然不会发生溢出，我们就可以认为这个page的parent page是安全的(包括所有的以上的祖先也都是安全的)，但这个page的写锁我们现在还不能释放。</p></blockquote><img src="/img/bustub/insert-1.jpg" style="zoom:50%;"><img src="/img/bustub/insert-2.jpg" style="zoom:50%;"><p>在 child page 不安全时，需要持续持有祖先的写锁。并在出现安全的 child page 后，释放所有祖先写锁。如何记录哪些 page 当前持有锁？这里就要用到在 Checkpoint1 里一直没有提到的一个参数，<code>transaction</code>。</p><p>transaction 就是 Bustub 里的事务。调用 transaction 的 <code>AddIntoPageSet()</code> 方法，来跟踪当前线程获取的 page 锁。在发现一个安全的 child page 后，将 transaction 中记录的 page 锁全部释放掉。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a><strong>Delete</strong></h3><p>和 Insert 基本一样。仅是判断是否安全的方法不同（检测 min size）。需要另外注意的是，当需要 steal&#x2F;merge sibling 时，也需要对 sibling 加锁。并在完成 steal&#x2F;merge 后马上释放。这里是为了避免其他线程正在对 sibling 进行 Search&#x2F;Insert 操作，从而发生 data race。这里的加锁就不需要在 transaction 里记录了，只是临时使用。</p><p>还有一些需要注意的细节，下面是某位大佬的总结，<a href="https://zhuanlan.zhihu.com/p/593214033">链接我放在这里</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P2实验笔记(1)</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P2%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P2%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a><strong>Overview</strong></h2><p>写这篇文章的目的主要用于B+树实现过程中的一些总结，不会太多涉及代码的实现，主要介绍思路和结构。个人感觉这是整个课程实验中最难的一个实验了。早就听说数据库中常用B+树来做索引，现在终于有机会直观地了解这一部分了。</p><p>这篇文章主要介绍CheckPoint1的内容。下一篇文章介绍B+树中的并发。</p><h2 id="B-树的结构"><a href="#B-树的结构" class="headerlink" title="B+树的结构"></a><strong>B+树的结构</strong></h2><p>B+树中有两种节点，一种是<code>InternalPage</code>，另一种是<code>LeafPage</code>。这两种page可以抽象成<code>BPlusTreePage</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPlusTreePage</span> &#123;</span><br> public:<br> private:<br>  <span class="hljs-comment">// member variable, attributes that both internal and leaf page share</span><br>  IndexPageType page_type_;   <span class="hljs-comment">// leaf or internal. 4 Byte</span><br>  <span class="hljs-type">lsn_t</span> lsn_    <span class="hljs-comment">// temporarily unused. 4 Byte</span><br>  <span class="hljs-type">int</span> size_;    <span class="hljs-comment">// tree page data size(not in byte, in count). 4 Byte</span><br>  <span class="hljs-type">int</span> max_size_;    <span class="hljs-comment">// tree page data max size(not in byte, in count). 4 Byte</span><br>  <span class="hljs-type">page_id_t</span> parent_page_id_;  <span class="hljs-comment">// 4 Byte</span><br>  <span class="hljs-type">page_id_t</span> page_id_;   <span class="hljs-comment">// 4 Byte</span><br>  <span class="hljs-comment">// Header data 24 Byte in total </span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPlusTreeInternalPage</span> :</span> public BPlusTreePage &#123;<br> public:<br> private:<br>  <span class="hljs-comment">// Flexible array member for page data.</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> MappingType std::pair<span class="hljs-string">&lt;KeyType, ValueType&gt;</span></span><br>  MappingType array_[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BPlusTreeLeafPage</span> :</span> public BPlusTreePage &#123;<br> public:<br> private:<br>  <span class="hljs-type">page_id_t</span> next_page_id_;<br>  <span class="hljs-comment">// Flexible array member for page data.</span><br>  MappingType array_[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>可以看到<code>LeafePage</code>相较于<code>InternalPage</code>，它的元数据还多了一个<code>next_page_id</code>，这个字段在设计B+树的迭代器的时候作用十分大。</p><p>那么该如何获取这些B+树的节点呢? 答案就在下面。<strong>reinterpret_cast 运算符并不会改变括号中运算对象的值，而是对该对象从位模式上进行重新解释</strong>，有了前面的铺垫很容易理解这个函数，即原先该内存解读为 <code>Page</code>，现在解读为 <code>BPlusTreePage</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Page *page = buffer_pool_manager-&gt;FetchPage(page_id);<br><span class="hljs-comment">// 强制类型转化 page-&gt;GetData()</span><br>BPlusTreePage *page_node = reinterpret_cast&lt;BPlusTreePage *&gt;(page-&gt;GetData());<br></code></pre></td></tr></table></figure><p>我们现在再来看一下Bustub中的B+树的视图:</p><img src="/img/bustub/bplustree.png" style="zoom:50%;"><p>对于B+树里面的<code>InternalPage</code>，它的key字段是索引，而它的value则是子节点的<code>PageId</code>。对于B+树里面的<code>LeafPage</code>，它的key字段也是建立的索引字段，而value部分则是数据条目对应的位置<code>RID</code>。</p><p>所以对于<code>InternalPage</code>，它的key是需要比value少1个的，Project 中要求，第一个 Key 为空。主要是因为在 internal page 中，n 个 key 可以将数轴划分为 n+1 个区域，也就对应着 n+1 个 value。</p><p>熟悉了B+树的基本结构后，我们简单介绍一下三种操作(<code>Insert</code> <code>Delete</code> <code>LookUp</code>)的实现思路。</p><h2 id="LookUp"><a href="#LookUp" class="headerlink" title="LookUp"></a><strong>LookUp</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyType &amp;key, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;ValueType&gt; *result, Transaction *transaction)</span><br></code></pre></td></tr></table></figure><p>当拿到一个 key 需要查找对应的 value 时，首先需要经由 internal page 递归地向下查找，最终找到 key 所在的 leaf page。这个过程可以简化为一个函数 <code>Findleaf()</code>。</p><p><code>FindLeaf</code>只需要找到可能存在<code>key</code>的leaf page，如果是internal page，根据 key 在当前 internal page 中找到对应的 child page id(我们在拿到 page id 后，调用 buffer pool 的 <code>FetchPage()</code> 函数来获取对应的 page 指针。要注意的是，在使用完 page 之后，需要将 page unpin 掉，否则最终会导致 buffer pool 中的所有 page 都被 pin 住，无法从 disk 读取其他的 page。然后再在下层 page 寻找)，最后在返回的 leaf page 里进行<code>LookUp</code>查找。</p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a><strong>Insert</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> KeyType &amp;key, <span class="hljs-type">const</span> ValueType &amp;value, Transaction *transaction = nullptr)</span><br></code></pre></td></tr></table></figure><p>与 Search 相同，第一步是根据 key 找到需要插入的 leaf page。同样是调用 <code>Findleaf()</code>。得到 leaf page 后，将 key 插入 leaf page。要注意的是，插入时仍需保证 key 的有序性。同样可以二分搜索找到合适的位置插入。</p><p>在把KV插入叶子节点后，需要判断 leaf page 是否是等于<code>max_size_</code>的，如果是，则需要进行一次分裂操作，叶子节点的分裂过程如下：</p><ol><li>新建一个空的 page</li><li>将原 page 的一半转移到新 page 中，（假如选择将新 page 放在原 page 右侧，则转移原 page 的右半部分）</li><li>更新原 page 和新 page 的 next page id</li><li>获取 parent page</li><li>将用于区分原 page 和新 page 的 key 插入 parent page 中</li><li>更新 parent page 所有 child page 的父节点指针</li></ol><p>往parent page里插入新的KV后，还需要判断parent page是否是满的状态，则还需要对parent page进行分裂，parent page的分裂过程如下：</p><ol><li>新建一个空的 page， </li><li>将原 page 的一半转移到新 page 中，需要注意原 page 和新 page 的第一个 key 都是无效的， </li><li>更新新 page 所有 child page 的父节点指针，指向新 page </li><li>获取 parent page</li><li>将用于区分原 page 和新 page 的 key 插入 parent page 中， 6. 更新 parent page 所有 child page 的父节点指针。</li></ol><img src="/img/bustub/split.png" style="zoom: 50%;"><p>对于root page内KV已满的情况，初始化就比一般情况下复杂一点，如上图所示，它需要设置两个KV，<code>array_[0].Value</code>设置为 left page的PageId，<code>array_[0].Key</code>不需要进行设置，<code>array_[1].Value</code>设置成 right page的PageId，<code>array_[1].Key</code>需要设置成 right page的一条元素的Key。</p><h2 id="Deletion"><a href="#Deletion" class="headerlink" title="Deletion"></a><strong>Deletion</strong></h2><p>将一个 KV 在 B+树删除，最终需要在叶子节点的 Leaf Page 删除 KV ，并同时进行适当的调整使得 B+树始终满足它的性质，具体的：</p><ol><li>首先找到叶子结点(<code>FindLeaf</code>)</li><li>如果叶子结点内存在KV，并且删除后叶子结点内的元素个数仍满足 ≥ min_size，直接删除</li><li>否则，需要进行 <code>CoalesceOrRedistribute</code></li><li>向父亲递归操作</li></ol><p>函数<code>CoalesceOrRedistribute</code>是对删除某个元素后的 page 进行的调整，看这个 page 是需要与它的左邻居(或是右邻居)进行合并(Coalesce)还是简单地从左邻居(右邻居)中借走一个KV(Redistribute)。</p><h3 id="Redistribute"><a href="#Redistribute" class="headerlink" title="Redistribute"></a><strong>Redistribute</strong></h3><p>尝试从两侧的兄弟节点中借一个 KV 对（父节点相同的节点中选取）假如存在一侧节点有富余的 KV 对，则成功，结束操作。</p><img src="/img/bustub/redistribute.png" style="zoom:50%;"><p>除了需要进行左右节点之间KV的移动，还需要调整parent page中的某一个KV，只需要在原来基础上更改，并不需要添加或删除。对于重分配，并不需要继续对parent page进行其他操作。</p><h3 id="Coalesce"><a href="#Coalesce" class="headerlink" title="Coalesce"></a><strong>Coalesce</strong></h3><p>如果左右邻居的节点都没有富足的节点外借，那么就可以进行将当前page与左(右)邻居进行合并，合并之后，parent page 也需要删除对应的KV，这一步继续对应函数<code>CoalesceOrRedistribute</code>，也就是递归向上。</p><img src="/img/bustub/coalece.png" style="zoom:50%;"><p>另外不要忘记了设置字段<code>NextPageId</code>。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1实验笔记</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P1%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P1%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Extendible-Hash-Table"><a href="#Extendible-Hash-Table" class="headerlink" title="Extendible Hash Table"></a><strong>Extendible Hash Table</strong></h2><p>我们先来了解一下什么是Extendible Hash Table。Extendible Hashing 有两个主要的部分</p><ol><li>目录(Directories): 即我们的哈希数组,目录的一个slot(即一个元素,下标)存储一个指向叶的地址的指针。还有一个id被分配给每个目录项,当目录扩张的时候,id就会发生改变。</li><li>叶(bucket): 桶用来存储散列后的数据(hash(key)和对应的value)</li></ol><p>我们来看一下相关的类实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bucket</span> &#123;</span><br>   public:<br>    explicit <span class="hljs-title function_">Bucket</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>)</span>;<br>    ....<br>        <br>   private:<br>    <span class="hljs-comment">// TODO(student): You may add additional private members and helper functions</span><br>    <span class="hljs-type">size_t</span> size_;<br>    <span class="hljs-type">int</span> depth_;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;K, V&gt;&gt; list_;<br>  &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendibleHashTable</span> :</span> public HashTable&lt;K, V&gt; &#123;<br>private:<br>  <span class="hljs-type">int</span> global_depth_ = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// The global depth of the directory</span><br>  <span class="hljs-type">size_t</span> bucket_size_ = <span class="hljs-number">0</span>;  <span class="hljs-comment">// The size of a bucket</span><br>  <span class="hljs-type">int</span> num_buckets_ = <span class="hljs-number">0</span>;     <span class="hljs-comment">// The number of buckets in the hash table</span><br>  mutable <span class="hljs-built_in">std</span>::mutex latch_;<br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Bucket&gt;&gt; dir_;  <span class="hljs-comment">// The directory of the hash table</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看一下ExtendibleHashTable的主要思路</p><p>这是当前的ExtendibleHashTable的状态。左边的数据结构是<code>std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_</code> ，也就是directory。它的有一个<code>global_depth_</code>深度为2，表示<code>dir_</code>有4项。</p><img src="/img/bustub/ExtendibleHashTable-3.png" style="zoom: 67%;"><p>接下来我们想要插入C，<code>hash(C)</code>进行位运算，二进制前两位(因为这里的<code>global_depth_</code>为2，所以只看前2位)为<code>10</code>，表示要插入进<code>dir_</code>下标为2的<code>Bucket</code>里。但现在由于这个<code>Bucket</code>的<code>local_depth_</code>为2，表示这个<code>Bucket</code>最大的存储大小为2(<code>Bucket</code>的最大容量和它的<code>local_depth_</code>有关，<code>Bucket</code>已经满了，那么就需要进行扩容。下面分几种情况：</p><ol><li>如果<code>Bucket</code>的<code>local_depth_</code>等于<code>global_depth_</code>：这就需要把<code>dir_</code>扩容一倍(<code>global_depth_</code>需要加1)，然后再把当前<code>Bucket</code>的<code>local_depth_</code>加1，最后把元素直接插进这个<code>Bucket</code>中。</li><li>如果<code>Bucket</code>的<code>local_depth_</code>小于<code>global_depth_</code>，那么这个<code>Bucket</code>需要进行扩容(<code>local_depth_</code>加1)，还有需要对<code>Bucket</code>里面的元素进行再分配，这需要申请新的<code>Bucket</code>结构体。主要的思路看这两幅图大概就能看明白了。</li></ol><img src="/img/bustub/ExtendibleHashTable-4.png" style="zoom: 60%;"><h2 id="LRU-K-Replacement-Policy"><a href="#LRU-K-Replacement-Policy" class="headerlink" title="LRU-K Replacement Policy"></a><strong>LRU-K Replacement Policy</strong></h2><p>在 LRU-K 中，我们需要记录 page 最近 K 次被引用的时间。假如 list 中所有 page 都被引用了大于等于 K 次，则比较最近第 K 次被引用的时间，驱逐最早的。假如 list 中存在引用次数少于 K 次的 page，则将这些 page 挑选出来，用普通的 LRU 来比较这些 page 第一次被引用的时间，驱逐最早的。</p><p>先介绍一下 frame 的概念。page 放置在 buffer pool 的 frame 中，frame 的数量是固定的，即 buffer pool 的大小。如果 buffer pool 中的一个 frame 没有用来放置任何 page，则说该 frame 是空闲的。如果所有 frame 都不是空闲的，则表明 buffer pool 已满。</p><p>Replacer 里有一张哈希表，用于存储不同 frame 的信息。将 frame 的信息封装成 <code>FrameInfo</code> 类。哈希表的 key 为 frame id，value 为 FrameInfo。</p><p>FrameInfo 里用链表保存 page 最近 K 次被引用的时间戳。这里的时间戳不适合也不需要用真正的 Unix 时间戳，直接用一个从 0 递增的 <code>size_t</code> 变量 <code>curr_timestamp</code> 来表示即可，每次引用 Replacer 中的任一 page 时，记录该次引用的时间戳为 <code>curr_timestamp</code>，并将其加 1。<code>size_t</code> 的大小也保证了这个变量不会溢出。</p><h2 id="Buffer-Pool-Manager"><a href="#Buffer-Pool-Manager" class="headerlink" title="Buffer Pool Manager"></a><strong>Buffer Pool Manager</strong></h2><p>这是<code>buffer_pool_manager_</code>类成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/** Number of pages in the buffer pool. */</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pool_size_;<br><span class="hljs-comment">/** The next page id to be allocated  */</span><br><span class="hljs-built_in">std</span>::atomic&lt;<span class="hljs-type">page_id_t</span>&gt; next_page_id_ = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/** Bucket size for the extendible hash table */</span><br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bucket_size_ = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">/** Array of buffer pool pages. */</span><br>Page *pages_;<br><span class="hljs-comment">/** Pointer to the disk manager. */</span><br>DiskManager *disk_manager_<br>    __attribute__((__unused__));  <span class="hljs-comment">// 这通常用于避免编译器警告，同时保留该变量以备将来使用的可能性。</span><br><span class="hljs-comment">/** Pointer to the log manager. Please ignore this for P1. */</span><br>LogManager *log_manager_ __attribute__((__unused__));<br><span class="hljs-comment">/** Page table for keeping track of buffer pool pages. */</span><br>ExtendibleHashTable&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">frame_id_t</span>&gt; *page_table_;<br><span class="hljs-comment">/** Replacer to find unpinned pages for replacement. */</span><br>LRUKReplacer *replacer_;<br><span class="hljs-comment">/** List of free frames that don&#x27;t have any pages on them. */</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-type">frame_id_t</span>&gt; free_list_;<br><span class="hljs-comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span><br><span class="hljs-built_in">std</span>::mutex latch_;<br><br></code></pre></td></tr></table></figure><ul><li>pages：buffer pool 中缓存 pages 的指针数组</li><li>disk_manager：框架提供，可以用来读取 disk 上指定 page id 的 page 数据，或者向 disk 上给定 page id 对应的 page 里写入数据</li><li>page_table：刚才实现的 Extendible Hash Table，用来将 page id 映射到 frame id，即 page 在 buffer pool 中的位置</li><li>replacer：刚才实现的 LRU-K Replacer，在需要驱逐 page 腾出空间时，告诉我们应该驱逐哪个 page</li><li>free_list：空闲的 frame 列表</li></ul><p><code>buffer_pool_manager_</code>有几个重要的函数。</p><ul><li><p><strong><code>FetchPgImp(page_id_t page_id)</code></strong>:寻找Buffer Pool里面是否存在某一个page，如果存在并返回这个Page在指针(根据Extendible Hash Table判断)；如果不存在，就需要寻找在free list中存在没有被使用的frame，再使用LRU驱逐策略看能不能驱逐某个frame，但前提必须是这个buffer page的引用计数等于0。这里还需要判断是否要把内容写回磁盘。</p><p>获取后，需要将evictable设置为false,在哈希表中建立映射，page的引用计数要加1.</p></li><li><p><strong><code>UnpinPgImp(page_id_t page_id, bool is_dirty)</code></strong>:访问完一个页面结束后就要进行Unpin，如果对页面进行了修改还需要把把<code>is_dirty</code>置为<code>true</code>以后写回磁盘。这个函数需要对page的引用计数减1，如果引用计数为0，还需要把这个frame设置成可以驱逐的(<code>is_evictable</code>)，这一步并不需要加入free list。</p><p><code>pin_count_</code>为0的时候这一步也不需要把内容写会磁盘，等到之后Fetch或者New的时候再根据<code>is_dirty_</code>位写回磁盘。</p></li><li><p>**<code>NewPgImp(page_id_t *page_id)</code>**：上层调用者希望新建一个 page。如果当前 buffer pool 已满并且所有 page 都是 unevictable 的，直接返回。如果当前 buffer pool 里没有空闲的 frame，但有 evitable 的 page，利用 LRU-K Replacer 获取可以驱逐的 frame id，将 frame 中原 page 驱逐，并创建新的 page 放在此 frame 中。</p><p>使用 <code>AllocatePage</code> 分配一个新的 page id(从0递增)，这相当于数据库文件的偏移，建立映射，增加引用计数。</p><p>如果被驱逐的页面还是<code>dirty</code>的，那么还需要把内容写回磁盘。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P0实验笔记</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/P0%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>书到用时方恨少，这个Project虽说前缀树我在之前就学过，但C++的基础知识还是很不牢固，所以先把一些需要用的知识点要在这里再记一下。</p><h3 id="左值引用和右值引用"><a href="#左值引用和右值引用" class="headerlink" title="左值引用和右值引用"></a>左值引用和右值引用</h3><ul><li>左值是可以放在赋值号左边的，左值必须要在内存中有实体。</li><li>右值出现在赋值号右边；右值可以在寄存器也可以在内存中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = num;<br><span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure><p>上面。<code>num</code>有地址是左值，<code>b</code>是对<code>num</code>的引用，所以这是左值引用。而10是右值，所以<code>c</code>是右值引用，这里是错误的。<br>但这样又是可以的：<br><code>const int&amp; c =10</code>,允许使用常量左值引用操作右值。<br>实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p><h4 id="右值引用介绍"><a href="#右值引用介绍" class="headerlink" title="右值引用介绍"></a>右值引用介绍</h4><p>右值引用也必须立即进行初始化操作，且<strong>使用右值进行初始化</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>&amp;&amp; a = <span class="hljs-number">10</span>;<br>a = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><p>上面的操作都是正确的。<br>右值引用 引用 右值，会使右值被存储到特定的位置。</p><ul><li>左值引用的短板<br>传值传参和传值返回都会产生拷贝，有的甚至是深拷贝，代价很大。而左值引用的实际意义在于做参数和做返回值都可以减少拷贝，从而提高效率。但是，左值引用的短板是不能够<strong>引用局部变量</strong>。</li></ul><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-comment">// 接收一个 std::vector&lt;int&gt; 的右值引用参数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">processVector</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp;&amp; vec)</span> &#123;<br>    <span class="hljs-comment">// 对右值引用进行操作，而不进行拷贝</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">// 将 nums 作为右值传递给函数</span><br>    processVector(<span class="hljs-built_in">std</span>::move(nums));<br><br>    <span class="hljs-comment">// 此时 nums 已被移动，不再可用</span><br>    <span class="hljs-comment">// 这里访问 nums 将导致未定义的行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>右值引用的特性是可以绑定到临时对象（右值）上的引用，而临时对象在表达式求值后就会被销毁。因此，当我们将<code>nums</code>通过<code>std::move()</code>转换为右值引用后，它的值类别变为右值，而不再是左值。<br>在函数参数中接收到右值引用 vec 后，我们可以直接操作它，而不需要进行对象拷贝。这是因为右值引用的特性允许我们“窃取”临时对象的资源，而不是进行拷贝。在这种情况下，我们可以直接使用 <code>vec</code> 的资源（例如 <code>std::vector</code> 中的数据），而不需要进行额外的拷贝操作。</p><h4 id="move移动语义"><a href="#move移动语义" class="headerlink" title="move移动语义"></a>move移动语义</h4><p>作用是将一个左值强制转化为右值，以实现移动语义。左值被 move 后变为右值，于是右值引用可以引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> t = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int&amp;&amp; rrt = t; // 编译报错，不能直接引用左值</span><br><br><span class="hljs-comment">// 2.但是右值引用可以引用被move的左值</span><br><span class="hljs-type">int</span>&amp;&amp; rrt = <span class="hljs-built_in">std</span>::move(t);  <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>右值引用意义和移动构造函数:<br>右值做参数，那么就会调用移动构造，而调用移动构造就会减少拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次移动构造就会少做一次深拷贝。</p><h4 id="forward完美转发"><a href="#forward完美转发" class="headerlink" title="forward完美转发"></a>forward完美转发</h4><p>有了<code>move</code>函数之后，我们又遇到了一个新的问题：</p><p>按照上面的写法，处理临时变量用右值引用<code>T&amp;&amp;</code>，处理普通变量用<code>const</code>引用<code>const T&amp;</code>，我们需要分别建立两个函数，然后入参使用不同的类型，每个函数都要写两遍。<br>那么能不能避免重复，将<code>T &amp;&amp;</code>类型和<code>const T &amp;</code>类型合二为一呢？</p><blockquote><p>答案就是：<code>forward</code>函数，<code>std::forward</code>也被称为完美转发，即：保持原来的值属性不变：</p></blockquote><ul><li>如果原来的值是左值，经<code>std::forward</code>处理后该值还是左值。</li><li>如果原来的值是右值，经<code>std::forward</code>处理后它还是右值。<br>这样一来，我们就可以使用<code>forward</code>函数对入参进行封装，从而保证了入参的统一性，从而可以实现一个方法处理两种类型！<br>正因为如此，<code>forward</code>函数被大量用在了入参值类型情况不确定的C++模板中！</li></ul><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><code>std::unique_ptr</code>是一个智能指针类模板，用于管理动态分配的对象。它提供了独占所有权的语义，意味着一个<code>unique_ptr</code>指针可以拥有对一个对象的唯一所有权，并负责在其生命周期结束时自动释放该对象。</p><ul><li><code>move</code>: 转移所有权，将原指针置空。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">ptr1</span><span class="hljs-params">(new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>))</span>;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt; ptr2 = <span class="hljs-built_in">std</span>::move(ptr1); <span class="hljs-comment">// 移动所有权</span><br><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-type">int</span>&gt;&gt; vec;<br>vec.push_back(<span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">20</span>)); <span class="hljs-comment">// 移动 unique_ptr 到容器中</span><br></code></pre></td></tr></table></figure><ul><li><code>reset</code>:更改所有权。</li></ul><ol><li><code>ptr.reset()</code>:销毁对象，指针置空。</li><li><code>ptr.reset(new_ptr)</code>:智能指针指向新的对象，原对象销毁。</li></ol><ul><li><code>get</code>：<code>get()</code>是<code> unique_ptr</code>类的成员函数，它返回指向<code>unique_ptr</code>所拥有的对象的指针，即原始指针。</li></ul><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>说了这么多，如果感觉还不是很懂，就直接来看代码吧。<br>我这里只介绍一些比较重要的函数。</p><h3 id="TrieNode"><a href="#TrieNode" class="headerlink" title="TrieNode"></a>TrieNode</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">TrieNode(TrieNode &amp;&amp;other_trie_node) noexcept &#123;<br>    key_char_ = other_trie_node.key_char_;<br>    is_end_ = other_trie_node.is_end_;<br>    children_.swap(other_trie_node.children_);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这就是移动构造函数。<br>调用<code> children_.swap(other_trie_node.children_)</code>，使用<code> std::swap</code>函数将 <code>other_trie_node</code> 的 <code>children_</code> 成员变量与当前对象的 <code>children_</code>成员变量进行交换。这样做可以实现高效的移动操作，避免不必要的复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *<span class="hljs-title function_">InsertChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; &amp;&amp;child)</span> &#123;<br>    <span class="hljs-keyword">if</span> (HasChild(key_char) || key_char != child-&gt;key_char_) &#123;<br>      <span class="hljs-keyword">return</span> nullptr;<br>    &#125;<br>    children_[key_char] = <span class="hljs-built_in">std</span>::move(child);<br>    <span class="hljs-keyword">return</span> &amp;children_[key_char];<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *<span class="hljs-title function_">GetChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> &#123;<br>    <span class="hljs-keyword">auto</span> node = children_.find(key_char);<br>    <span class="hljs-keyword">if</span> (node != children_.end()) &#123;<br>      <span class="hljs-keyword">return</span> &amp;(node-&gt;second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br></code></pre></td></tr></table></figure><ul><li><p>为什么返回的都是智能指针的指针？</p><blockquote><p>因为智能指针对一个对象有唯一的所有权,如果我们在字典树的操作中需要不断迭代的话，需要移动指针，那就需要用到智能指针的指针了。</p></blockquote></li><li><p>为什么要<code>children_[key_char] = std::move(child)</code>?</p><blockquote><p>child 是一个右值引用的 std::unique_ptr<TrieNode>，应该直接将其移动给 children_[key_char]。child 的所有权转移给 children_[key_char]，而不是重新构造一个新的 std::unique_ptr。这样做可以避免不必要的内存分配和析构，并正确地转移所有权。</TrieNode></p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">RemoveChildNode</span><span class="hljs-params">(<span class="hljs-type">char</span> key_char)</span> &#123;<br>    <span class="hljs-keyword">auto</span> node = children_.find(key_char);<br>    <span class="hljs-keyword">if</span> (node != children_.end()) &#123;<br>      node-&gt;second.reset();<br>      children_.erase(key_char);<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="TrieNodeWithValue"><a href="#TrieNodeWithValue" class="headerlink" title="TrieNodeWithValue"></a>TrieNodeWithValue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value) : TrieNode(<span class="hljs-built_in">std</span>::forward&lt;TrieNode&gt;(trieNode)) &#123;<br>    value_ = value;<br>    SetEndNode(<span class="hljs-literal">true</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>移动构造函数，把<code>trieNode</code>作为右值传递给<code>TrieNodeWithValue</code>，实现资源的转移。</p><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br>  <span class="hljs-type">bool</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key, T value)</span> &#123;<br>     <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    latch_.WLock();<br>    <span class="hljs-keyword">auto</span> cur = &amp;root_;<br>    <span class="hljs-comment">// latch_.WLock();</span><br>    <span class="hljs-keyword">auto</span> c = key.begin();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">auto</span> x = c++;<br>      <span class="hljs-keyword">if</span> (c == key.end()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cur-&gt;get()-&gt;HasChild(*x)) &#123;<br>        cur = cur-&gt;get()-&gt;GetChildNode(*x);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        cur = cur-&gt;get()-&gt;InsertChildNode(*x, <span class="hljs-built_in">std</span>::make_unique&lt;TrieNode&gt;(*x));<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">char</span> ch = key.back();<br>    <span class="hljs-keyword">auto</span> end_node = cur-&gt;get()-&gt;GetChildNode(ch);<br><br>    <span class="hljs-keyword">if</span> (end_node != nullptr &amp;&amp; end_node-&gt;get()-&gt;IsEndNode()) &#123;<br>      latch_.WUnlock();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (end_node != nullptr) &#123;<br>      <span class="hljs-keyword">auto</span> new_node = new TrieNodeWithValue&lt;T&gt;(<span class="hljs-built_in">std</span>::move(*(end_node-&gt;get())), value);<br>      end_node-&gt;reset(new_node);<br><br>      latch_.WUnlock();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果为空</span><br>    cur = cur-&gt;get()-&gt;InsertChildNode(ch, <span class="hljs-built_in">std</span>::make_unique&lt;TrieNode&gt;(ch));<br>    <span class="hljs-comment">// 现在还是一个中间节点，还不是TrieNodeWithValue</span><br>    <span class="hljs-keyword">auto</span> new_node = new TrieNodeWithValue&lt;T&gt;(<span class="hljs-built_in">std</span>::move(**cur), value);<br>    cur-&gt;reset(new_node);<br>    latch_.WUnlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">Remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    latch_.WLock();<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *&gt; storage;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *node = &amp;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key) &#123;<br>      storage.emplace_back(node);<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *next = node-&gt;get()-&gt;GetChildNode(ch);<br><br>      <span class="hljs-keyword">if</span> (next == nullptr) &#123;<br>        latch_.WUnlock();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br>      node = next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (node-&gt;get()-&gt;HasChildren()) &#123;<br>      <span class="hljs-comment">// node = node-&gt;get()-&gt;GetChildNode(key[key.size()-1]);</span><br>      node-&gt;get()-&gt;SetEndNode(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = storage.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 想一下， root 节点是不记录字符的</span><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;TrieNode&gt; *pre = storage[i];<br>        <span class="hljs-keyword">if</span> ((i &lt; static_cast&lt;<span class="hljs-type">int</span>&gt;(key.size() - <span class="hljs-number">1</span>)) &amp;&amp; (node-&gt;get()-&gt;IsEndNode() || node-&gt;get()-&gt;HasChildren())) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pre-&gt;get()-&gt;RemoveChildNode(key[i]);<br>        node = pre;<br>      &#125;<br>    &#125;<br><br>    latch_.WUnlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename T&gt;<br>  T <span class="hljs-title function_">GetValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;key, <span class="hljs-type">bool</span> *success)</span> &#123;<br>    *success = <span class="hljs-literal">true</span>;<br>    latch_.RLock();<br>    <span class="hljs-keyword">if</span> (key.empty()) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> cur = &amp;root_;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : key) &#123;<br>      <span class="hljs-keyword">if</span> (cur-&gt;get()-&gt;HasChild(ch)) &#123;<br>        cur = cur-&gt;get()-&gt;GetChildNode(ch);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        *success = <span class="hljs-literal">false</span>;<br>        latch_.RUnlock();<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!cur-&gt;get()-&gt;IsEndNode()) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      latch_.RUnlock();<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> flag_node = dynamic_cast&lt;TrieNodeWithValue&lt;T&gt; *&gt;(cur-&gt;get());<br>    <span class="hljs-keyword">if</span> (flag_node == nullptr) &#123;<br>      *success = <span class="hljs-literal">false</span>;<br>      latch_.RUnlock();<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br><br>    latch_.RUnlock();<br>    <span class="hljs-keyword">return</span> flag_node-&gt;GetValue();<br>  &#125;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bustub中索引的实现</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Bustub%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Bustub%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Bustub中的索引机制"><a href="#Bustub中的索引机制" class="headerlink" title="Bustub中的索引机制"></a><strong>Bustub中的索引机制</strong></h2><p>在<code>catalog</code>类中，有这样一个成员<code>index_names_</code>，它记录了某个表所有的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-type">index_oid_t</span>&gt;&gt; index_names_;<br></code></pre></td></tr></table></figure><p>我们先从函数<code>CreateIndex</code>出发，了解一下Bustub中索引的实现。</p><p><code>schema</code>：表中Tuple的格式。</p><p><code>key_schema</code>：索引的格式，也就是哪几个字段合在一起建立索引，组成一条Tuple。</p><p><code>key_attrs</code>：索引字段在table中的下标。</p><p><code>keysize</code>：key的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">CreateIndex</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;index_name, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;table_name, <span class="hljs-type">const</span> Schema &amp;schema,<span class="hljs-type">const</span> Schema &amp;key_schema, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint32_t</span>&gt; &amp;key_attrs, <span class="hljs-built_in">std</span>::<span class="hljs-type">size_t</span> keysize, HashFunction&lt;KeyType&gt; hash_function)</span> -&gt; IndexInfo *;<br></code></pre></td></tr></table></figure><p>首先是一些相关的检查，不必多言。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (table_names_.find(table_name) == table_names_.end()) &#123;<br>  <span class="hljs-keyword">return</span> NULL_INDEX_INFO;<br>&#125;<br><br>BUSTUB_ASSERT((index_names_.find(table_name) != index_names_.end()), <span class="hljs-string">&quot;Broken Invariant&quot;</span>);<br><br><span class="hljs-keyword">auto</span> &amp;table_indexes = index_names_.find(table_name)-&gt;second;<br><span class="hljs-keyword">if</span> (table_indexes.find(index_name) != table_indexes.end()) &#123;<br>  <span class="hljs-keyword">return</span> NULL_INDEX_INFO;<br>&#125;<br><br><span class="hljs-keyword">auto</span> meta = <span class="hljs-built_in">std</span>::make_unique&lt;IndexMetadata&gt;(index_name, table_name, &amp;schema, key_attr<br></code></pre></td></tr></table></figure><p>然后就是建立一个B+树(我们在P2实现的)，这个B+树存取索引，其中的Key也是Tuple(由<code>key_schema</code>和<code>key_attars</code>定义)，<strong>Value就是每一条数据的<code>RID</code>，<code>RID</code>记录的是每一条Tuple的物理页面的和页面内的编号</strong>，所以索引就建好了。但这里有一个要求，在Bustub中如果要对某个表在字段x1,x2….xn中建立索引，那么这个表中，任意两条的tuple的x1,x2…xn不能同时相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> index = <span class="hljs-built_in">std</span>::make_unique&lt;BPlusTreeIndex&lt;KeyType, ValueType, KeyComparator&gt;&gt;(<span class="hljs-built_in">std</span>::move(meta), bpm_);<br><br><span class="hljs-comment">// Populate the index with all tuples in table heap</span><br><span class="hljs-keyword">auto</span> *table_meta = GetTable(table_name);<br><span class="hljs-keyword">auto</span> *heap = table_meta-&gt;table_.get();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> tuple = heap-&gt;Begin(txn); tuple != heap-&gt;End(); ++tuple) &#123;<br>  index-&gt;InsertEntry(tuple-&gt;KeyFromTuple(schema, key_schema, key_attrs), tuple-&gt;GetRid(), txn);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是把索引添加到<code>catalog_</code>中了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Get the next OID for the new index</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> index_oid = next_index_oid_.fetch_add(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// Construct index information; IndexInfo takes ownership of the Index itself</span><br><span class="hljs-keyword">auto</span> index_info =<br>    <span class="hljs-built_in">std</span>::make_unique&lt;IndexInfo&gt;(key_schema, index_name, <span class="hljs-built_in">std</span>::move(index), index_oid, table_name, keysize);<br><span class="hljs-keyword">auto</span> *tmp = index_info.get();<br><br><span class="hljs-comment">// Update internal tracking</span><br>indexes_.emplace(index_oid, <span class="hljs-built_in">std</span>::move(index_info));<br>table_indexes.emplace(index_name, index_oid);<br><br><span class="hljs-keyword">return</span> tmp;<br></code></pre></td></tr></table></figure><p>索引中保存了整个表的所有数据，所以当某个表有Insert或者删除某个Tuple时，必须也对索引进行Insert或者Delete。</p><p>索引建好了，就可以利用索引进行查询了。索引查询也很简单，我们对索引建有迭代器(B+树的迭代器)，我们就可以获取每一条Tuple的<code>RID</code>信息，有了这个信息，就可以调用<code>GetTuple</code>函数得到相应的tuple了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">auto TableHeap::<span class="hljs-constructor">GetTuple(<span class="hljs-params">const</span> RID &amp;<span class="hljs-params">rid</span>, Tuple <span class="hljs-operator">*</span><span class="hljs-params">tuple</span>, Transaction <span class="hljs-operator">*</span><span class="hljs-params">txn</span>, <span class="hljs-params">bool</span> <span class="hljs-params">acquire_read_lock</span>)</span> -&gt; <span class="hljs-built_in">bool</span><br></code></pre></td></tr></table></figure><p>但是我发现，Bustub里面似乎不能够把字符串类型的字段做索引。我们之前在实现B+树的时候，有一个柔型数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">MappingType array_[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>可见每一个的Key的长度都是固定的。所以貌似来看，Bustub必须保证索引是建立在定长字段上的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bustub中表的设计</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Bustub%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB-Table%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Bustub%E4%BB%A3%E7%A0%81%E5%AF%BC%E8%AF%BB-Table%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Bustub中的Table"><a href="#Bustub中的Table" class="headerlink" title="Bustub中的Table"></a><strong>Bustub中的Table</strong></h2><p>首先，我们先来看一下Bustub数据库中表的设计的结构图：</p><p>首先，Bustub 有一个 Catalog。Catalog 提供了一系列 API，例如 <code>CreateTable()</code>、<code>GetTable()</code> 等等。Catalog 维护了几张 hashmap，保存了 table id 和 table name 到 table info 的映射关系。table id 由 Catalog 在新建 table 时自动分配，table name 则由用户指定。</p><p>这里的 table info 包含了一张 table 的 metadata，有 schema、name、id 和指向 table heap 的指针。系统的其他部分想要访问一张 table 时，先使用 name 或 id 从 Catalog 得到 table info，再访问 table info 中的 table heap。</p><p>table heap 是管理 table 数据的结构，包含 <code>InsertTuple()</code>、<code>MarkDelete()</code> 一系列 table 相关操作。table heap 本身并不直接存储 tuple 数据，tuple 数据都存放在 table page 中。table heap 可能由多个 table page 组成，仅保存其第一个 table page 的 page id。需要访问某个 table page 时，通过 page id 经由 buffer pool 访问。</p><p>table page 是实际存储 table 数据的结构，父类是 page。相较于 page，table page 多了一些新的方法。table page 在 data 的开头存放了 next page id、prev page id 等信息，将多个 table page 连成一个双向链表，便于整张 table 的遍历操作。当需要新增 tuple 时，table heap 会找到当前属于自己的最后一张 table page，尝试插入，若最后一张 table page 已满，则新建一张 table page 插入 tuple。table page 低地址存放 header，tuple 从高地址也就是 table page 尾部开始插入。</p><p>tuple 对应数据表中的一行数据。每个 tuple 都由 RID 唯一标识。RID 由 page id + slot num 构成。tuple 由 value 组成，value 的个数和类型由 table info 中的 schema 指定。</p><p>value 则是某个字段具体的值，value 本身还保存了类型信息。</p><img src="/img/bustub/table-1.png" style="zoom:50%;"><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a><strong>Tuple</strong></h2><p>上面给出了一条<code>Tuple</code> 的结构，如果我们想解析一条<code>Tuple</code> ，例如知道<code>Tuple</code> 的每一个<code>Value</code> ，包括类型，我们就需要另外一个叫做<code>Schema</code> 的类了。所以说<code>Tuple</code> 需要和<code>Schema</code> 配合使用。</p><p><code>Schema</code> 定义好了一个表的表模式，即一个table由哪些列组成的，列的名称，占用的大小等。<code>Tuple</code> 中有一些列是由Varchar组成的字符串，由于这些字符串长度的不确定，我们又该如何在<code>Tuple</code>中进行存储呢？</p><p>我们可以先计算<code>Schema</code>中固定的长度，也就是比如一些int、bool等类型的column，这些存储的位置都可以固定下来，并且可以用这些加起来得到<code>schema</code>的长度，而对于变长的字符串，我们留一个<code>offset</code> ，再在整个<code>shema</code> 固定部分的长度后面加进去。这也就是<code>Column</code> 中函数<code>IsInlined()</code>的作用，就是判断<code>data_</code>的 <code>column-&gt;GetOffset()</code>处 存储的是真实的Value，还是二级的offset。这样就解决了Varchar的可边长问题：</p><p>我们再来看一下<code>Tuple</code> 的结构，<code>data_</code> 字符数组就是这样组织的，主要还是看代码</p><img src="/img/bustub/tuple-1.png" style="zoom: 33%;"><p><code>Tuple</code>除了<code>data_</code>来存储各个column外，还有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> allocated_&#123;<span class="hljs-literal">false</span>&#125;;  <span class="hljs-comment">// is allocated?</span><br>RID rid_&#123;&#125;;              <span class="hljs-comment">// if pointing to the table heap, the rid is valid</span><br><span class="hljs-type">uint32_t</span> size_&#123;<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>这三个成员。</p><h2 id="TablePage"><a href="#TablePage" class="headerlink" title="TablePage"></a><strong>TablePage</strong></h2><p>bustub中存储table表的页叫做<code>TablePage</code> ，它的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Slotted page format:</span><br><span class="hljs-comment"> *  ---------------------------------------------------------</span><br><span class="hljs-comment"> *  | HEADER | ... FREE SPACE ... | ... INSERTED TUPLES ... |</span><br><span class="hljs-comment"> *  ---------------------------------------------------------</span><br><span class="hljs-comment"> *                                ^</span><br><span class="hljs-comment"> *                                free space pointer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  Header format (size in bytes):</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------------------</span><br><span class="hljs-comment"> *  | PageId (4)| LSN (4)| PrevPageId (4)| NextPageId (4)| FreeSpacePointer(4) |</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------------------</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------</span><br><span class="hljs-comment"> *  | TupleCount (4) | Tuple_1 offset (4) | Tuple_1 size (4) | ... |</span><br><span class="hljs-comment"> *  ----------------------------------------------------------------</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>下面就是<code>TablePage</code>的结构，前面有24个字节的头部，分别存储了Page的基本信息以及<code>FreeSpacePointer</code>和<code>TupleCount</code>，通过这两个就可以实现对<code>TablePage</code>的解析。每一个<code>offset</code>就是Page中<code>Tuple</code>的<code>data_</code>在页的起始位置的偏移，至于<code>RID</code>就是<code>offset size</code>数组的下标。</p><img src="/img/bustub/tablepage.png" style="zoom: 33%;"><p>在Bustub中是如何删除某一条<code>Tuple</code>的呢，首先先对<code>Tuple</code>进行删除的标记，也就是调用<code>MarkDelete</code>函数。</p><blockquote><p>事务首先调用MarkDelete，然后如果提交成功，使用ApplyDelete函数从物理上删除。如果事务异常终止了则调用RollbackDelete函数再把每个tuple的size的第32位1给抹去。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">TableHeap::MarkDelete</span><span class="hljs-params">(<span class="hljs-type">const</span> RID &amp;rid, Transaction *txn)</span><br></code></pre></td></tr></table></figure><p>这个函数做一些判断后调用<code>SetTupleSize</code>。这个标志就相当于把<code>tuple_size</code>的第32位置1，根据这一位判断是否是需要被<code>Delete</code>的。同样<code>UnsetDeletedFlag</code>函数就是获取设为<code>Delete</code>标志位前<code>tuple</code>的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">SetTupleSize(slot_num, SetDeletedFlag(tuple_size));<br><br><span class="hljs-comment">// DELETE_MASK  (0b)  100000.....000(31个0)</span><br><span class="hljs-type">static</span> constexpr <span class="hljs-type">uint64_t</span> DELETE_MASK = (<span class="hljs-number">1U</span> &lt;&lt; (<span class="hljs-number">8</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint32_t</span>) - <span class="hljs-number">1</span>));<br><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title function_">SetDeletedFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tuple_size)</span> -&gt; <span class="hljs-type">uint32_t</span> &#123;<br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(tuple_size | DELETE_MASK);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title function_">UnsetDeletedFlag</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tuple_size)</span> -&gt; <span class="hljs-type">uint32_t</span> &#123;<br>    <span class="hljs-keyword">return</span> static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(tuple_size &amp; (~DELETE_MASK));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ApplyDelete"><a href="#ApplyDelete" class="headerlink" title="ApplyDelete"></a><strong>ApplyDelete</strong></h3><p>接下来我们可以直接看<code>ApplyDelete</code>函数，这个函数是把<code>tuple</code>的内容从<code>TablePage</code>中进行物理删除。</p><p>这个函数的行为是把<code>rid</code>这个<code>tuple</code>给删除了，首先利用<code>UnsetDeletedFlag</code>函数得到原来的<code>tuple_size</code>，然后把使用<code>memmove</code>函数直接把需要删除的<code>tuple</code>给覆盖掉。然后再把移动了的<code>tuple</code>(<code>offset</code>小于被删除<code>tuple</code>的<code>offset</code>)的偏移加上删除<code>tuple</code>的<code>tuple_size</code>。还需要把相应位置的<code>offset</code>和<code>size</code>都置为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TablePage::ApplyDelete</span><span class="hljs-params">(<span class="hljs-type">const</span> RID &amp;rid, Transaction *txn, LogManager *log_manager)</span> &#123;<br>  <span class="hljs-type">uint32_t</span> slot_num = rid.GetSlotNum();<br>  BUSTUB_ASSERT(slot_num &lt; GetTupleCount(), <span class="hljs-string">&quot;Cannot have more slots than tuples.&quot;</span>);<br><br>  <span class="hljs-type">uint32_t</span> tuple_offset = GetTupleOffsetAtSlot(slot_num);<br>  <span class="hljs-type">uint32_t</span> tuple_size = GetTupleSize(slot_num);<br>  <span class="hljs-comment">// Check if this is a delete operation, i.e. commit a delete.</span><br>  <span class="hljs-keyword">if</span> (IsDeleted(tuple_size)) &#123;<br>    tuple_size = UnsetDeletedFlag(tuple_size);<br>  &#125;<br>    <br>  <span class="hljs-comment">// Otherwise we are rolling back an insert.</span><br>  <span class="hljs-type">uint32_t</span> free_space_pointer = GetFreeSpacePointer();<br>  BUSTUB_ASSERT(tuple_offset &gt;= free_space_pointer, <span class="hljs-string">&quot;Free space appears before tuples.&quot;</span>);<br><br>  memmove(GetData() + free_space_pointer + tuple_size, GetData() + free_space_pointer,<br>          tuple_offset - free_space_pointer);<br>  SetFreeSpacePointer(free_space_pointer + tuple_size);<br>  SetTupleSize(slot_num, <span class="hljs-number">0</span>);<br>  SetTupleOffsetAtSlot(slot_num, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Update all tuple offsets.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; GetTupleCount(); ++i) &#123;<br>    <span class="hljs-type">uint32_t</span> tuple_offset_i = GetTupleOffsetAtSlot(i);<br>    <span class="hljs-keyword">if</span> (GetTupleSize(i) != <span class="hljs-number">0</span> &amp;&amp; tuple_offset_i &lt; tuple_offset) &#123;<br>      SetTupleOffsetAtSlot(i, tuple_offset_i + tuple_size);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="InsertTuple"><a href="#InsertTuple" class="headerlink" title="InsertTuple"></a><strong>InsertTuple</strong></h3><p><code>InsertTuple</code>函数负责把<code>tuple</code>中的<code>data_</code>部分插入到<code>TablePage</code>中，再把插入的位置记录在指针<code>rid</code>中。</p><p>首先判断是否插入得下，如果没有足够的空间插入就返回<code>false</code>。</p><p>然后开始遍历所有的<code>tuple</code>(从0到<code>TupleCount()</code>，这里的<code>i</code>就是<code>RID</code>中的<code>slot_num</code>)，。如果某个<code>tuple</code>的<code>size</code>为0，说明这个位置是空闲的(之前<code>ApplyDelete</code>的时候<code>offset</code>和<code>size</code>数组在page中的的位置并没有改变，删除了只是把它们都置为0。</p><p>然后我们把<code>FreeSpacePointer</code>减去<code>tuple.size_</code>，并把<code>tuple.data_</code>搬运到这个位置上，最后设置<code>rid</code>，<code>rid-&gt;Set(GetTablePageId(), i)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> <span class="hljs-title function_">TablePage::InsertTuple</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;tuple, RID *rid, Transaction *txn, LockManager *lock_manager,</span><br><span class="hljs-params">                            LogManager *log_manager)</span> -&gt; <span class="hljs-type">bool</span> &#123;<br>  BUSTUB_ASSERT(tuple.size_ &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Cannot have empty tuples.&quot;</span>);<br>  <span class="hljs-comment">// If there is not enough space, then return false.</span><br>  <span class="hljs-keyword">if</span> (GetFreeSpaceRemaining() &lt; tuple.size_ + SIZE_TUPLE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Try to find a free slot to reuse.</span><br>  <span class="hljs-type">uint32_t</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; GetTupleCount(); i++) &#123;<br>    <span class="hljs-comment">// If the slot is empty, i.e. its tuple has size 0,</span><br>    <span class="hljs-keyword">if</span> (GetTupleSize(i) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Then we break out of the loop at index i.</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// If there was no free slot left, and we cannot claim it from the free space, then we give up.</span><br>  <span class="hljs-keyword">if</span> (i == GetTupleCount() &amp;&amp; GetFreeSpaceRemaining() &lt; tuple.size_ + SIZE_TUPLE) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Otherwise we claim available free space..</span><br>  SetFreeSpacePointer(GetFreeSpacePointer() - tuple.size_);<br>  <span class="hljs-built_in">memcpy</span>(GetData() + GetFreeSpacePointer(), tuple.data_, tuple.size_);<br><br>  <span class="hljs-comment">// Set the tuple.</span><br>  SetTupleOffsetAtSlot(i, GetFreeSpacePointer());<br>  SetTupleSize(i, tuple.size_);<br><br>  rid-&gt;Set(GetTablePageId(), i);<br>  <span class="hljs-keyword">if</span> (i == GetTupleCount()) &#123;<br>    SetTupleCount(GetTupleCount() + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bustub中并发控制</title>
    <link href="/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Bustub%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/03/05/%E6%95%B0%E6%8D%AE%E5%BA%93/CMU_15445/Bustub%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a><strong>可串行化</strong></h2><p>在数据库系统中，事务是并发的，那么应该如何保证事务并发的正确性。比如说事务T1从A账户转账50到B账户，事务T2计算A账户和B账户的和，T1和T2是并发执行的，那么可能会存在事务T2计算的结果并不等于A+B的原本的和。</p><p>最容易理解的正确性保证就是串行调度，即不允许事务并发，所有事务排队，一个接着一个串行执行，其正确性是显然的，同时，执行效率低也是显然的。</p><p>为了提高数据库的执行效率，显然我们需要并发的执行各个事务，如果存在调度S，对于数据库的任何状态，其执行结果完全等价于另一个串行调度S’，称这样的调度S为可串行化调度。</p><h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a><strong>两阶段锁</strong></h2><p>我们再以上面的转账为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CQL">-- T1: 从 A 向 B 转账 100 元--<br>BEGIN<br>A = A - 100<br>B = B + 100<br>COMMIT<br>-- T2: 计算并输出 A、B 账户的总和 --<br>BEGIN<br>ECHO A + B<br>COMMIT<br></code></pre></td></tr></table></figure><p><img src="/img/bustub/2pl-1.png"></p><p>我们先来看最左边的调度，我们看到事务二出现了不正确的结果，并且我们看到了出现了不正确结果的原因是由于事务T1过早地释放了A的独占锁。</p><p>如果我们采用二阶段锁协议，要求每个事务分两个阶段提出加锁和解锁申请就不会出现这种结果。</p><ol><li><strong>增长阶段</strong>：一个事务可以获得锁，但不能解锁</li><li><strong>缩减阶段</strong>：一个事务可以释放锁，但不能获得新锁</li></ol><p>我们希望调度不仅是可串行化的，还希望调度是无级联的。但普通的二阶段锁有导致级<strong>联回滚</strong>的问题，我们来看下面的例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">T1                   T2                  T3<br>-----------------------------------------------<br><span class="hljs-built_in">lock-X</span>(A) <br><span class="hljs-built_in">read</span>(A)<br><span class="hljs-built_in">lock-S</span>(B)<br><span class="hljs-built_in">read</span>(B)<br><span class="hljs-built_in">write</span>(A)<br><span class="hljs-built_in">unlock</span>(A)<br>                 <span class="hljs-built_in">lock-X</span>(A)<br>                 <span class="hljs-built_in">read</span>(A)<br>                 <span class="hljs-built_in">write</span>(A)<br>                 <span class="hljs-built_in">unlock</span>(A)<br>                                      <span class="hljs-built_in">lock-S</span>(A)<br>                                      <span class="hljs-built_in">read</span>(A)<br></code></pre></td></tr></table></figure><p>上面的调度遵循二阶段锁协议，假如T3<code>read(A)</code>后T1发生了故障后abort，那么T2、T3都读取到了T1写的无效的数据，那么除了T1要回滚之外，T2、T3也要级联回滚。这就严重降低了效率了。</p><p>级联回滚可以通过<strong>严格的二阶段锁协议</strong>来避免，这种协议不但要求封锁是两阶段的，还要求事务持有的<strong>所有排他模式锁必须在事务提交之后才可以释放</strong>。</p><p><strong>缺点</strong>:二阶段锁并不保证不会发生死锁，所以需要进行死锁检测，人为地abort某一个事务，使数据库系统继续运行。</p><p>我们回顾一下，二阶段锁的主要任务就是解决可串行化的问题(证明略)，还有更进一步，如果使用强二阶段锁，还可以避免级联回滚(由脏读引起)。</p><h2 id="锁兼容矩阵"><a href="#锁兼容矩阵" class="headerlink" title="锁兼容矩阵"></a><strong>锁兼容矩阵</strong></h2><p>如果一个事务需要更新十亿条数据，那么 lock manager 中的 lock table 就要撑爆了。为了避免这种开销，DBMS 可以使用一个锁的层次结构，允许事务在系统中获取更多的粗粒度的锁。</p><p>Database Lock Hierarchy:</p><ol><li>Database level (Slightly Rare)</li><li>Table level (Very Common)</li><li>Page level (Common)</li><li>Tuple level (Very Common)</li><li>Attribute level (Rare)</li></ol><p>在多粒度封锁中，若对一个节点加锁（X、S），意味着这个点的后裔节点也被加以同样的锁。若对一个节点加意向锁，则说明<strong>正在</strong>对其子节点加（对应的）锁（可理解为一个事务中的先后次序）。</p><h3 id="为什么需要意向锁"><a href="#为什么需要意向锁" class="headerlink" title="为什么需要意向锁"></a><strong>为什么需要意向锁</strong></h3><p>考虑这个例子：</p><p>事务A锁住了表中的<strong>一行</strong>，让这一行只能读，不能写。之后，事务B申请<strong>整个表</strong>的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。</p><p>数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁。那么数据库要怎么判断这个冲突呢？</p><p>step1：判断表是否已被其他事务用表锁锁表。</p><p>step2：判断表中的每一行是否已被行锁锁住(但这个需要遍历这一张表呀，效率会很低)。</p><p>于是就有了意向锁。</p><p>在意向锁存在的情况下，事务A必须先申请表的意向共享锁，成功后再申请一行的行锁。在意向锁存在的情况下，上面的判断可以改成</p><p>step1：不变</p><p>step2：发现表上有意向共享锁，说明表中有些行被共享行锁被锁住了，因此，事务B申请表的写锁会被阻塞。</p><p>也就是说，意向锁是在存在行锁场景下的表锁快速失败机制。</p><p><strong>意向锁</strong> (Intention Lock)：意向锁允许将更高级别的节点锁定为共享或独占模式，而<strong>无需检查所有后代节点</strong>。如果节点处于意向模式，则显式锁定在树中的较低级别完成。</p><ul><li><strong>意向共享锁</strong> Intention-Shared (IS)：若一个节点被加上 IS 锁，则将在树的较低层使用 S 锁进行显式锁定。</li><li><strong>意向排他锁</strong> Intention-Exclusive (IX)：若一个节点被加上 IX 锁，则将在树的较低层使用 X 或 S 锁进行显示锁定。</li><li><strong>意向共享排他锁</strong> Shared+Intention-Exclusive (SIX)：若一个节点被加上 SIX 锁，则对以该节点为 root 的树使用 S 锁显示锁定，且将在树的较低层使用 X 锁进行显示锁定。<strong>SIX 锁可理解为 S + IX</strong></li></ul><h3 id="一些应用场景"><a href="#一些应用场景" class="headerlink" title="一些应用场景"></a><strong>一些应用场景</strong></h3><p>比如事务T想要读取表A中的所有tuple，那么需要给A加S锁，表示表A和它所有的子节点都加了S锁。如果事务T只需要读取表A中的一些tuple，那只需要对表A加IS锁，再向下对需要读的tuple加S锁。对于X和IX也类似。</p><ul><li>那为什么还需要SIX锁呢？</li></ul><p>如果有一个事务，读取了一张表的所有 record，然后只更新一小部分 record，我们应该加什么锁？</p><p>如果没有 SIX 锁，有两个方案：</p><ol><li>对目标表（或者一些更大的锁定对象，例如 database）加 X 锁。</li><li>对目标表加 IX 锁，然后对它的所有 record 加 S 锁，最后对更新的 record 加 X 锁。</li></ol><p>显然方案1的并发度很低，方案 2 除了目标表以外，对每个 record 加锁都会有一次加锁请求，并且需要在内存中为每个 record 维护一个锁对象。这就有了SIX锁，我们可以通过对目标表加 SIX 锁，然后对更新的 record 加 X 锁来解决。</p><blockquote><p>SIX 锁 &#x3D; S 锁 + IX 锁。对目标表加上 SIX 锁后，S 锁这一属性保证了别的事务能知道我们要读取目标表的所有 record，它们就不会去并发地更新任意的 record；IX 锁这一属性保证了别的事务能知道我们要更新目标表的一部分 record，它们就不会去并发地读取所有的 record。</p></blockquote><h2 id="锁兼容矩阵-1"><a href="#锁兼容矩阵-1" class="headerlink" title="锁兼容矩阵"></a><strong>锁兼容矩阵</strong></h2><p>锁的兼容矩阵如下：</p><img src="/img/bustub/lock-matrix.png" style="zoom: 33%;"><p>我在这里尝试解释一下这个兼容矩阵。</p><p>对于IS锁，它读取某一张表下的某一些tuple，对需要读取的才加S锁，所以IS锁与IS，S兼容，这是显而易见的；IS还与IX兼容，因为我们不确定哪些tuple需要加相应类型的锁(S或X)，这里在粗粒度上还是可以并发的，不冲突，下面是否冲突就交给tuple级别进行兼容矩阵的判断(tuple级别只能加S或X型锁)。</p><p>对于IX，它与IS和IX兼容上面说过；所以在S或X锁下，表中的所有数据都被锁定了，所以IX和S并不兼容；而SIX也有S的属性，所以IX和SIX也不兼容。</p><h2 id="Bustub中的隔离级别"><a href="#Bustub中的隔离级别" class="headerlink" title="Bustub中的隔离级别"></a><strong>Bustub中的隔离级别</strong></h2><p>Bustub中实现了三种隔离级别，分别是<strong>可重复读、读已提交、读未提交</strong>。</p><ol><li><p><strong>脏读</strong>: 脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。</p></li><li><p><strong>不可重复读</strong>:对比可重复读，不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的。</p></li><li><p><strong>幻读</strong>：幻读是针对数据<strong>插入（INSERT）</strong>操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。</p></li></ol><img src="/img/bustub/isolation-level.png" style="zoom:50%;"><p>Bustub实现三种隔离级别的机制：</p><p>在Bustub中，就是通过魔改的二阶段锁，加上特定的加解锁规则来实现不同隔离级别的。下面分别来讲讲这几种隔离级别和相应的加解锁规则。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a><strong>读已提交</strong></h3><p>读已提交可以解决脏读的问题，但不能解决可重复读和幻读的问题。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">READ_COMMITTED:<br>   * The transaction is required <span class="hljs-keyword">to</span> take <span class="hljs-literal">all</span> locks.<br>   * All locks are allowed <span class="hljs-keyword">in</span> the GROWING <span class="hljs-keyword">state</span><br>   * Only IS, S locks are allowed <span class="hljs-keyword">in</span> the SHRINKING <span class="hljs-keyword">state</span><br>   * Unlocking X locks should <span class="hljs-built_in">set</span> the transaction <span class="hljs-keyword">state</span> <span class="hljs-keyword">to</span> SHRINKING.<br>   * Unlocking S locks does not affect transaction <span class="hljs-keyword">state</span>.<br></code></pre></td></tr></table></figure><ul><li><p>如何解决脏读问题的?</p><p>在Bustub中，不支持Update操作，对于数据更改，只支持Insert和Delete操作。并且这两个操作首先是在高层节点获取IX锁，再对tuple获取X锁。<strong>这两种锁锁在 Commit&#x2F;Abort 时统一释放，不能手动释放</strong>(每一种隔离机制都一样)。这也就保证了如果需要更改的事务先拿到了某条tuple的写锁，那么要等到该事务提交或者终止后其他事务才能够读取这条tuple。</p></li><li><p>为什么不可重复读?</p><p>因为上面有一条规则，只有解X型锁才会把状态设置为<code>SHRINKING</code>，解S型锁并不改变状态。所以一个事务如果是读已提交的，那么可能会出现下面的加解锁顺序: <code>Lock-S(A)，Read(A)，UnLock(A) ...... Lock-S(A)，Read(A)，UnLock(A)</code>，这样就可能读到不一样的数据。</p></li></ul><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a><strong>读未提交</strong></h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">READ_UNCOMMITTED:<br>   * The transaction is required <span class="hljs-keyword">to</span> take only IX, X locks.<br>   * X, IX locks are allowed <span class="hljs-keyword">in</span> the GROWING <span class="hljs-keyword">state</span>.<br>   * S, IS, SIX locks are never allowed<br>   * Unlocking X locks should <span class="hljs-built_in">set</span> the transaction <span class="hljs-keyword">state</span> <span class="hljs-keyword">to</span> SHRINKING.<br>   * S locks are not permitted under READ_UNCOMMITTED.<br>   * The behaviour upon unlocking an S lock under this isolation level is undefined.<br></code></pre></td></tr></table></figure><p>对于读未提交，这种隔离机制只允许加IX和X类型的锁(对于写而言)，不允许加S类型的锁，也就是说读取的时候是不加锁直接在数据中读取的，而其他事务可能已经对该数据进行了更改，但还没有提交，所以就会出现脏读。</p><h3 id="可重复复读"><a href="#可重复复读" class="headerlink" title="可重复复读"></a><strong>可重复复读</strong></h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">REPEATABLE_READ:<br>   * The transaction is required <span class="hljs-keyword">to</span> take <span class="hljs-literal">all</span> locks.<br>   * All locks are allowed <span class="hljs-keyword">in</span> the GROWING <span class="hljs-keyword">state</span><br>   * No locks are allowed <span class="hljs-keyword">in</span> the SHRINKING <span class="hljs-keyword">state</span><br>   * Unlocking S/X locks should <span class="hljs-built_in">set</span> the transaction <span class="hljs-keyword">state</span> <span class="hljs-keyword">to</span> SHRINKING<br></code></pre></td></tr></table></figure><p>可重复读相比于读已提交解决了不可重复读的问题。那么它又是如何解决这个问题的呢?</p><p>上面有一条规则是，解S型锁或者是X型锁都会把把状态设置为<code>SHRINKING</code>，也就是说，所有的读取操作只能夹在单词的Lock和UnLock之间，并且只要解锁了，就不能再进行加锁(也就不能再次读取了，因为读取前就要加读锁)。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>CMU_15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>CMU_15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页表</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E9%A1%B5%E8%A1%A8/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E9%A1%B5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a><strong>Page Table</strong></h2><p>xv6是采用了三级页表。每一个<code>pte</code>页表条目都是8字节(8*512 &#x3D; 4096刚好是一个page的大小)，其中低10位表示标志位，还有44位表示PPN，因为xv6中一个页的大小为4096个字节，也就是12位，所以整个页表可以表示的物理地址范围是[0, 2^56-1]。</p><img src="/img/xv6-labs/pagetable-1.png" style="zoom:50%;"><p>我们先来看<code>walk</code>函数：这个函数给定一个虚拟地址<code>va</code>和一个<code>pagetable</code>，也就是第一级页表的起始位置，需要返回这个<code>va</code>对应的物理地址的位置。</p><p>宏<code>PX(level,va)</code>就是得到<code>va</code>这个虚拟地址在某一级页表下的偏移位置。这里有一个参数为<code>alloc</code>，这个参数为1的话，如果遇到某一个<code>pte</code>是无效的，还需要分配新的物理页(这个物理页可能是某一级页表的位置或者是最终映射的物理位置)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span>* <span class="hljs-title function_">walk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span>&#123;<br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;walk&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> level = <span class="hljs-number">2</span>; level &gt; <span class="hljs-number">0</span>; level--) &#123;<br>    <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<br>      pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>      *pte = PA2PTE(pagetable) | PTE_V;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">0</span>, va)];<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一个很重要的函数是<code>mappages</code>，这个函数的作用就是建立起虚拟地址到物理地址的页表映射，虚拟地址从<code>va</code>开始，物理地址从<code>pa</code>开始，映射大小为<code>size</code>。</p><p>这个函数的逻辑就是不断使用上面的<code>walk</code>函数，从顶往下设置每一级的<code>pte</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-type">int</span> perm)</span>&#123;<br>  uint64 a, last;<br>  <span class="hljs-type">pte_t</span> *pte;<br><br>  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size&quot;</span>);<br>  <br>  a = PGROUNDDOWN(va);<br>  last = PGROUNDDOWN(va + size - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<br>      panic(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内核的Page-Table"><a href="#内核的Page-Table" class="headerlink" title="内核的Page Table"></a><strong>内核的Page Table</strong></h2><p>内核也有一个Page Table，内核会通过一个特殊的函数<code>pagetable_t kvmmake(void)</code>来初始化它的页表我们来看一下这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs pagetable_t">pagetable_t kvmmake(void)&#123;<br>  pagetable_t kpgtbl;<br><br>  kpgtbl = (pagetable_t) kalloc();<br>  memset(kpgtbl, 0, PGSIZE);<br><br>  // uart registers<br>  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);<br><br>  // virtio mmio disk interface<br>  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);<br><br>  // PLIC<br>  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);<br><br>  // map kernel text executable and read-only.<br>  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);<br><br>  // map kernel data and the physical RAM we&#x27;ll make use of.<br>  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);<br><br>  // map the trampoline for trap entry/exit to<br>  // the highest virtual address in the kernel.<br>  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);<br><br>  // map kernel stacks<br>  proc_mapstacks(kpgtbl);<br>  <br>  return kpgtbl;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>kvmmap</code>函数是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">kvmmap</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span>&#123;<br>  <span class="hljs-keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kvmmap&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以内核的映射，虚拟地址和物理地址很多都是相等的。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管道的实现</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%AE%A1%E9%81%93%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E7%AE%A1%E9%81%93%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="管道的实现"><a href="#管道的实现" class="headerlink" title="管道的实现"></a><strong>管道的实现</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span>*)</span>;<br></code></pre></td></tr></table></figure><p>在Linux中，一切皆文件，管道也是一种文件！</p><p>我们来看在xv6中，管道究竟是如何被实现的。我们直接来看<code>sys_pipe</code>函数。</p><p>我们首先获取到传进来的数组<code>fdarray</code>，这是数组在进程地址空间中虚拟地址，然后就调用<code>pipealloc</code>向向操作系统内核申请两个文件。</p><blockquote><p><code>struct file</code>是操作系统管理的，而文件描述符则是进程所有的。操作系统有一个<code>ftable</code>的<code>file</code>数组，管理所有打开的文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_pipe</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  uint64 fdarray; <span class="hljs-comment">// user pointer to array of two integers</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">rf</span>, *<span class="hljs-title">wf</span>;</span><br>  <span class="hljs-type">int</span> fd0, fd1;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;fdarray) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (pipealloc(&amp;rf, &amp;wf) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  fd0 = <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><p>我们接着来看<code>pipealloc</code>函数的代码：</p><p>这个函数获取两个<code>file</code>，并把其中一个文件设置为只读，一个文件设置为只写，将文件类型设置为管道类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pipealloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file **f0, <span class="hljs-keyword">struct</span> file **f1)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pi</span>;</span><br><br>  pi = <span class="hljs-number">0</span>;<br>  *f0 = *f1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>((*f0 = filealloc()) == <span class="hljs-number">0</span> || (*f1 = filealloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>((pi = (<span class="hljs-keyword">struct</span> pipe*)kalloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  pi-&gt;readopen = <span class="hljs-number">1</span>;<br>  pi-&gt;writeopen = <span class="hljs-number">1</span>;<br>  pi-&gt;nwrite = <span class="hljs-number">0</span>;<br>  pi-&gt;nread = <span class="hljs-number">0</span>;<br>  initlock(&amp;pi-&gt;lock, <span class="hljs-string">&quot;pipe&quot;</span>);<br>  (*f0)-&gt;type = FD_PIPE;<br>  (*f0)-&gt;readable = <span class="hljs-number">1</span>;<br>  (*f0)-&gt;writable = <span class="hljs-number">0</span>;<br>  (*f0)-&gt;pipe = pi;<br>  (*f1)-&gt;type = FD_PIPE;<br>  (*f1)-&gt;readable = <span class="hljs-number">0</span>;<br>  (*f1)-&gt;writable = <span class="hljs-number">1</span>;<br>  (*f1)-&gt;pipe = pi;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> bad:<br>  <span class="hljs-keyword">if</span>(pi)<br>    kfree((<span class="hljs-type">char</span>*)pi);<br>  <span class="hljs-keyword">if</span>(*f0)<br>    fileclose(*f0);<br>  <span class="hljs-keyword">if</span>(*f1)<br>    fileclose(*f1);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后还做了一件事，申请了一个<code>pipe</code>结构体,这个<code>pipe</code>结构体中就有一个缓冲区，这样就实现了一个管道了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">char</span> data[PIPESIZE];<br>  uint nread;     <span class="hljs-comment">// number of bytes read</span><br>  uint nwrite;    <span class="hljs-comment">// number of bytes written</span><br>  <span class="hljs-type">int</span> readopen;   <span class="hljs-comment">// read fd is still open</span><br>  <span class="hljs-type">int</span> writeopen;  <span class="hljs-comment">// write fd is still open</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>获取到两个文件后，再调用<code>fdalloc</code>函数，进程分配两个文件描述符指向这个<code>file</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((fd0 = fdalloc(rf)) &lt; <span class="hljs-number">0</span> || (fd1 = fdalloc(wf)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span> (fd0 &gt;= <span class="hljs-number">0</span>)<br>      p-&gt;ofile[fd0] = <span class="hljs-number">0</span>;<br>    fileclose(rf);<br>    fileclose(wf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得了两个文件描述符后，就要用<code>copyout</code>函数将这两个文件描述符写该进程地址空间地址的<code>fdarray</code> 和<code>fdarray+sizeof(fd0)</code> 处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, fdarray, (<span class="hljs-type">char</span> *)&amp;fd0, <span class="hljs-keyword">sizeof</span>(fd0)) &lt; <span class="hljs-number">0</span> ||<br>      copyout(p-&gt;pagetable, fdarray + <span class="hljs-keyword">sizeof</span>(fd0), (<span class="hljs-type">char</span> *)&amp;fd1, <span class="hljs-keyword">sizeof</span>(fd1)) &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    p-&gt;ofile[fd0] = <span class="hljs-number">0</span>;<br>    p-&gt;ofile[fd1] = <span class="hljs-number">0</span>;<br>    fileclose(rf);<br>    fileclose(wf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>之后，在对进行管道读取操作时，<code>sys_read</code> 系统调用会调用函数<code>fileread</code> ，<code>fileread</code> 函数会判断文件的类型，如果该文件是管道，那么就会调用<code>piperead</code>函数，这个函数就会从<code>pipe</code>结构体的缓冲区中读取，前提是<code>nwrite</code> 要大于<code>nread</code>，否则就会阻塞。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统的构建</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="xv6文件系统的构建"><a href="#xv6文件系统的构建" class="headerlink" title="xv6文件系统的构建"></a>xv6文件系统的构建</h2><p>我们再次回到如何通过qemu启动xv6操作系统的问题，qemu的命令是：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-riscv64 -machine virt -bios <span class="hljs-literal">none</span> -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">3</span> -nographic -drive <span class="hljs-built_in">file</span>=fs.img,<span class="hljs-keyword">if</span>=<span class="hljs-literal">none</span>,<span class="hljs-built_in">format</span>=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus<span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>我们看到有这个选项<code>-drive file=fs.img,if=none,format=raw,id=x0</code><br>这条命令指定镜像文件为 fs.img。这个文件包含了虚拟机将要访问的文件系统的内容。<br>指定虚拟磁盘驱动器的镜像文件格式为 raw。这表示 fs.img 文件中的数据将按原始字节顺序存储，而不会进行额外的格式化。</p><p>那么引出问题：<br>这个<code>fs.img</code>是怎么来的，他需不需要进行一些基本的设置来满足xv6对文件系统的要求，<code>fs.img</code>中一定有一些硬编码的内容，不然，我们刚开始启动xv6的时候输入<code>ls</code>，怎么会有那么多的文件？</p><h3 id="Makefle"><a href="#Makefle" class="headerlink" title="Makefle"></a>Makefle</h3><p>我们尝试从Makefile中找到答案,Makefile中有这一行：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">fs.img: mkfs/mkfs README <span class="hljs-variable">$(UEXTRA)</span> <span class="hljs-variable">$(UPROGS)</span></span><br>mkfs/mkfs fs.img README <span class="hljs-variable">$(UEXTRA)</span> <span class="hljs-variable">$(UPROGS)</span><br></code></pre></td></tr></table></figure><p><code>mkfs</code>是一个C程序，并不在xv6中运行。我们发现，README、$(UEXTRA)、$(UPROGS)都是我们在<code>ls</code>得到的文件。那么我们去<code>mkfs/mkfs.c</code>文件中一探究竟吧！</p><h3 id="mkfs-mkfs-c"><a href="#mkfs-mkfs-c" class="headerlink" title="mkfs&#x2F;mkfs.c"></a>mkfs&#x2F;mkfs.c</h3><p>首先来看一下fs.img中block的布局，mkfs.c主要就是构建这个布局。</p><p><img src="/img/xv6-labs/fsimg-layout.png"></p><p>第一部分，构建superblock。<code>wsect(uint sec, void *buf)</code>是往fs.img第sec个扇区写入内容，这个函数很简单，<code>lseek</code>函数就可以解决。</p><blockquote><p>superblock位于扇区1,它保存文件系统最基本的一些信息，例如扇区的总数，data blocks的数量,inode扇区的数量，log山区的数量等</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">fsfd = open(argv[<span class="hljs-number">1</span>], O_RDWR|O_CREAT|O_TRUNC, <span class="hljs-number">0666</span>);<br><span class="hljs-keyword">if</span>(fsfd &lt; <span class="hljs-number">0</span>)<br>  die(argv[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">// 1 fs block = 1 disk sector</span><br>nmeta = <span class="hljs-number">2</span> + nlog + ninodeblocks + nbitmap;<br>nblocks = FSSIZE - nmeta;<br><br>sb.magic = FSMAGIC;<br>sb.size = xint(FSSIZE);<br>sb.nblocks = xint(nblocks);<br>sb.ninodes = xint(NINODES);<br>sb.nlog = xint(nlog);<br>sb.logstart = xint(<span class="hljs-number">2</span>);<br>sb.inodestart = xint(<span class="hljs-number">2</span>+nlog);<br>sb.bmapstart = xint(<span class="hljs-number">2</span>+nlog+ninodeblocks);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nmeta %d (boot, super, log blocks %u inode blocks %u, bitmap blocks %u) blocks %d total %d\n&quot;</span>,<br>       nmeta, nlog, ninodeblocks, nbitmap, nblocks, FSSIZE);<br><br>freeblock = nmeta;     <span class="hljs-comment">// the first free block that we can allocate</span><br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; FSSIZE; i++)<br>  wsect(i, zeroes);<br><br><span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));<br>memmove(buf, &amp;sb, <span class="hljs-keyword">sizeof</span>(sb));<br>wsect(<span class="hljs-number">1</span>, buf);<br><br></code></pre></td></tr></table></figure><p>构建好基本结构后，就是往文件系统中写入内容了。<br>首先要创建一个根目录文件，然后在根目录里面写入两个目录，一个是<code>.</code>一个是<code>..</code>。</p><blockquote><p>实现也比较简单，就是在inode block中写入一个新的dinode结构体。（ialloc函数）<br>再用iappend函数写入一个个dirent结构体表示新的文件。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c">rootino = ialloc(T_DIR);<br>assert(rootino == ROOTINO);<br><br>bzero(&amp;de, <span class="hljs-keyword">sizeof</span>(de));<br>de.inum = xshort(rootino);<br><span class="hljs-built_in">strcpy</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>);<br>iappend(rootino, &amp;de, <span class="hljs-keyword">sizeof</span>(de));<br><br>bzero(&amp;de, <span class="hljs-keyword">sizeof</span>(de));<br>de.inum = xshort(rootino);<br><span class="hljs-built_in">strcpy</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>);<br>iappend(rootino, &amp;de, <span class="hljs-keyword">sizeof</span>(de));<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt; argc; i++)&#123;<br>  <span class="hljs-comment">// get rid of &quot;user/&quot;</span><br>  <span class="hljs-type">char</span> *shortname;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(argv[i], <span class="hljs-string">&quot;user/&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>)<br>    shortname = argv[i] + <span class="hljs-number">5</span>;<br>  <span class="hljs-keyword">else</span><br>    shortname = argv[i];<br>  <br>  assert(index(shortname, <span class="hljs-string">&#x27;/&#x27;</span>) == <span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">if</span>((fd = open(argv[i], <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    die(argv[i]);<br><br>  <span class="hljs-comment">// Skip leading _ in name when writing to file system.</span><br>  <span class="hljs-comment">// The binaries are named _rm, _cat, etc. to keep the</span><br>  <span class="hljs-comment">// build operating system from trying to execute them</span><br>  <span class="hljs-comment">// in place of system binaries like rm and cat.</span><br>  <span class="hljs-keyword">if</span>(shortname[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;_&#x27;</span>)<br>    shortname += <span class="hljs-number">1</span>;<br><br>  inum = ialloc(T_FILE);<br><br>  bzero(&amp;de, <span class="hljs-keyword">sizeof</span>(de));<br>  de.inum = xshort(inum);<br>  <span class="hljs-built_in">strncpy</span>(de.name, shortname, DIRSIZ);<br>  iappend(rootino, &amp;de, <span class="hljs-keyword">sizeof</span>(de));<br><br>  <span class="hljs-keyword">while</span>((cc = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)<br>    iappend(inum, buf, cc);<br><br>  close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><p>这一步过后，一个well defined，完全按照手册定义的xv6文件系统就诞生了！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6的启动</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%90%AF%E5%8A%A8/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9A%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="xv6启动-1"><a href="#xv6启动-1" class="headerlink" title="xv6启动(1)"></a>xv6启动(1)</h2><p>我们的xv6操作系统是运行在qemu模拟器上的，如果我想要知道究竟是如何启动这个操作系统的，那么我就要知道是如何启动qemu,并传入一些什么参数的。<br>通过<code>make -nB</code>，有如下命令：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">qemu-<span class="hljs-keyword">system</span>-riscv64 -machine virt -bios <span class="hljs-literal">none</span> -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">3</span> -nographic -drive <span class="hljs-built_in">file</span>=fs.img,<span class="hljs-keyword">if</span>=<span class="hljs-literal">none</span>,<span class="hljs-built_in">format</span>=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus<span class="hljs-number">.0</span><br></code></pre></td></tr></table></figure><p>我们发现<code>-kernel kernel/kernel</code>这个选项，这可能是我们目前需要的答案。<br><img src="/img/xv6-labs/xv6-boot.png" alt="xv6-boot" style="zoom:50%;"></p><ul><li>题外话：如何调试我们的xv6 kernel</li></ul><ol><li>打开一个终端。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">CPUS</span>=1 qemu-gdb<br></code></pre></td></tr></table></figure></li><li>一个终端，输入三条命令。<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">gdb-multiarch kernel/kernel<br><span class="hljs-keyword">set</span> architecture <span class="hljs-comment">riscv:rv64</span><br>target <span class="hljs-comment">remote localhost:26000</span><br></code></pre></td></tr></table></figure></li></ol><p>首先，qemu的第一条指令在<code>0x1000</code>处，这里执行四条指令，跳转到地址为<code>0x80000000</code>处，这个地址有什么内容呢？这里会执行<code>_entry.S</code>出的汇编代码，这是通过什么实现的呢？</p><blockquote><p>kernel.ld连接脚本</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ENTRY( <span class="hljs-params">_entry</span> )</span><br><br>SECTIONS<br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * ensure that entry.S / _entry is at 0x80000000,</span><br><span class="hljs-comment">   * where qemu&#x27;s -kernel jumps.</span><br><span class="hljs-comment">   */</span><br>  . = <span class="hljs-number">0x80000000</span>;<br><br>  .text : &#123;<br>    *(.text .text.*)<br>    . = <span class="hljs-constructor">ALIGN(0x1000)</span>;<br>    _trampoline = .;<br>    *(trampsec)<br>    . = <span class="hljs-constructor">ALIGN(0x1000)</span>;<br>    <span class="hljs-constructor">ASSERT(. - <span class="hljs-params">_trampoline</span> <span class="hljs-operator">==</span> 0x1000, <span class="hljs-string">&quot;error: trampoline larger than one page&quot;</span>)</span>;<br>    <span class="hljs-constructor">PROVIDE(<span class="hljs-params">etext</span> = .)</span>;<br>  &#125; <br>.................<br></code></pre></td></tr></table></figure><p>这里要确保_entry在地址0x80000000处。<br>_entry.S为各个cpu设置好栈，现在我们就进入C语言的世界了。</p><p>接下来执行<code>start</code>函数，这个函数我觉得可以先跳过，这部分内容主要是一些与riscv相关的设置，然后跳转到<code>main</code>函数。</p><p><code>main</code>函数就开始启动分页，启动trap，启动文件系统等，再执行<code> userinit()</code>函数，这是第一个应用程序。<br>这个应用程序做了一件什么事情？<br>这个应用程序是用二进制硬编码的，所以很小，做的事情很有限，它只做一件事情，就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">execve(<span class="hljs-string">&quot;/init&quot;</span>)<br></code></pre></td></tr></table></figure><p>这就是<code>init.c</code>，<code>init.c</code>做些什么呢？<br>它开启虚拟终端console,开启三个文件描述符0,1,2指向这个console。<br>然后它<code>fork</code>一份：<br>子进程执行<code>execve(&quot;sh, argv&quot;)</code>，就是我们的终端了。<br>父进程<code>init</code>不断<code>wait</code>等待子进程<code>sh</code>的结束。</p><p>至此，我们的操作系统算是成功跑起来了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9Ashell/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9Ashell/</url>
    
    <content type="html"><![CDATA[<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>这部分的笔记主要来源于<code>user/sh.c</code>文件，这里面有很多代码的技巧，很值得学习。这部分主要弄清楚xv6中的shell是如何工作的。</p><ol><li>一条完整的命令是如何开始运行的</li><li><strong>是如何实现重定向的</strong>  （ &gt; 符号)</li><li><strong>是如何执行管道命令的</strong>  （ | 符号）</li><li>以及List命令，后台执行等。</li></ol><p>首先sh程序会打开三次<code>console</code> 文件，使得0,1,2三个文件描述符都指向<code>console</code> 。然后就可以从终端得到命令不断执行。</p><ol><li>判断输入的命令是不是cd。</li><li>如果是cd，则用系统调用chdir()切换当前进程的工作目录。</li><li>如果不是，则用系统调用fork()，派生一个子进程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>((fd = open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(fd &gt;= <span class="hljs-number">3</span>)&#123;<br>      close(fd);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Read and run input commands.</span><br>  <span class="hljs-keyword">while</span>(getcmd(buf, <span class="hljs-keyword">sizeof</span>(buf)) &gt;= <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>(buf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>      <span class="hljs-comment">// Chdir must be called by the parent, not the child.</span><br>      buf[<span class="hljs-built_in">strlen</span>(buf)<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// chop \n</span><br>      <span class="hljs-keyword">if</span>(chdir(buf+<span class="hljs-number">3</span>) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;cannot cd %s\n&quot;</span>, buf+<span class="hljs-number">3</span>);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>      runcmd(parsecmd(buf));<br>    wait(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="如何解析命令"><a href="#如何解析命令" class="headerlink" title="如何解析命令"></a>如何解析命令</h2><p>指令解析函数<code>parsecmd</code>执行的核心函数的<code>parseline</code>，这个函数是递归执行的，其执行流程如下：</p><ol><li>首先执行<code>parsepipe</code>的核心函数<code>parseexec</code>，调用<code>execcmd</code>，生成一个<code>execcmd</code>的结构体，然后调用<code>parseredirs</code>函数，检查是否有重定向符号”&lt;“或”&gt;”，如果有，则将之前的<code>execcmd</code>改为<code>redircmd</code>。将命令的入参保存在cmd-&gt;argv中；</li><li>接着，检查用户输入的命令中是否有管道命令，如果有，递归调用<code>parsepipe</code>，则建立管道连接；</li><li>返回parseline，执行命令中是否有&amp;（返回命令），如果有，则生成一个新的backcmd；</li><li>检查是否有；（多条命令分别要执行），如果有，递归调用<code>parseline</code>，将所有的命令分别解析后连接起来。</li></ol><p>这里面有一个技巧，在命令构造的过程中，用到了递归的链式连接的形式构造命令。因为一个命令可能非常复杂，例如<code>ls &lt; y; ls | sort; who</code>这样的命令，这条命令就可以构造起如下这个链式的命令串：</p><img src="/img/xv6-labs/shell-1.png" style="zoom: 67%;"><p><code>parsecmd()</code>是命令构造函数，它简单地把工作转交给<code>parseline()</code>函数。</p><p><code>parseline</code>顾名思义就是处理一行的输入字符串，把它转化成命令。这一行的概念有点抽象，实际上应该是可以视作一个命令整体的一行字符串，在这行字符串里可以包含各种命令，也就是<code>|&amp;&lt;&gt;();</code>这些字符都可以处理。所有需要处理全部类型字符的工作都可以交给<code>parseline()</code>完成。<code>parseline()</code>里还可以递归地调用<code>parseline()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cmd*<br><span class="hljs-title function_">parseline</span><span class="hljs-params">(<span class="hljs-type">char</span> **ps, <span class="hljs-type">char</span> *es)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmd</span> *<span class="hljs-title">cmd</span>;</span><br><br>  cmd = parsepipe(ps, es);<br>  <span class="hljs-keyword">while</span>(peek(ps, es, <span class="hljs-string">&quot;&amp;&quot;</span>))&#123;<br>    gettoken(ps, es, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cmd = backcmd(cmd);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(peek(ps, es, <span class="hljs-string">&quot;;&quot;</span>))&#123;<br>    gettoken(ps, es, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cmd = listcmd(cmd, parseline(ps, es));<br>  &#125;<br>  <span class="hljs-keyword">return</span> cmd;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为什么先调用 <code>parsepipe</code> 函数呢？这是因为在命令行中，管道操作符 <code>|</code> 的优先级高于分号 <code>;</code>，而且后台执行符 <code>&amp;</code> 的优先级也高于分号。因此，在构建命令树时，首先要确保管道部分正确解析，然后再考虑后台执行和顺序执行。这种先处理高优先级操作符的策略有助于正确构建命令树的结构。</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>这部分代码在函数<code>runcmd</code>中。</p><h3 id="EXEC类型命令"><a href="#EXEC类型命令" class="headerlink" title="EXEC类型命令"></a>EXEC类型命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> EXEC:<br>    ecmd = (<span class="hljs-keyword">struct</span> execcmd*)cmd;<br>    <span class="hljs-keyword">if</span>(ecmd-&gt;argv[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    exec(ecmd-&gt;argv[<span class="hljs-number">0</span>], ecmd-&gt;argv);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;exec %s failed\n&quot;</span>, ecmd-&gt;argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h3 id="REDIR类型命令"><a href="#REDIR类型命令" class="headerlink" title="REDIR类型命令"></a>REDIR类型命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// runcmd</span><br><span class="hljs-keyword">case</span> REDIR:<br>    rcmd = (<span class="hljs-keyword">struct</span> redircmd*)cmd;<br>    close(rcmd-&gt;fd);<br>    <span class="hljs-keyword">if</span>(open(rcmd-&gt;file, rcmd-&gt;mode) &lt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;open %s failed\n&quot;</span>, rcmd-&gt;file);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    runcmd(rcmd-&gt;cmd);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>在 shell 编程中，&gt; 和 &lt; 是用于重定向输入和输出的符号，它们之间有以下区别：</p><ol><li><code>&gt;</code>符号：<br><code>&gt;</code>符号用于将命令的标准输出重定向到指定文件，即将命令的输出写入到指定文件中。如果指定的文件不存在，则会创建该文件；如果文件已经存在，则会覆盖原有内容。</li><li><code>&lt;</code> 符号：<br><code>&lt;</code> 符号用于将文件的内容作为命令的标准输入，即从指定文件中读取数据作为命令的输入。</li></ol><p>所以，对于<code>&lt;</code>符号，程序要从标准输入也就是文件描述符为0的文件中读取内容，所以在上面的处理中，一次<code>close</code>一次<code>open</code>，这个<code>rcmd-&gt;file</code>文件打开后，文件描述符就为0了。所以实现了程序<code>read(0,...)</code>从该文件中读取的效果<br>同理对于<code>&gt;</code>符号，程序要往该文件中写入内容，我们知道<code>printf()</code>函数默认是往文件描述符为1的文件中写入内容的，同上。<br>对于<code>+</code>追加操作，这里要注意一下文件打开的方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cmd*<br><span class="hljs-title function_">parseredirs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cmd *cmd, <span class="hljs-type">char</span> **ps, <span class="hljs-type">char</span> *es)</span><br>&#123;<br>  <span class="hljs-type">int</span> tok;<br>  <span class="hljs-type">char</span> *q, *eq;<br><br>  <span class="hljs-keyword">while</span>(peek(ps, es, <span class="hljs-string">&quot;&lt;&gt;&quot;</span>))&#123;<br>    tok = gettoken(ps, es, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class="hljs-string">&#x27;a&#x27;</span>)<br>      panic(<span class="hljs-string">&quot;missing file for redirection&quot;</span>);<br>    <span class="hljs-keyword">switch</span>(tok)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>      cmd = redircmd(cmd, q, eq, O_RDONLY, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE|O_TRUNC, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:  <span class="hljs-comment">// &gt;&gt;</span><br>      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cmd;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="LIST类型命令"><a href="#LIST类型命令" class="headerlink" title="LIST类型命令"></a>LIST类型命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> LIST:<br>    lcmd = (<span class="hljs-keyword">struct</span> listcmd*)cmd;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>      runcmd(lcmd-&gt;left);<br>    wait(<span class="hljs-number">0</span>);<br>    runcmd(lcmd-&gt;right);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>比较简单，就是一个链表。</p><h3 id="PIPE类型命令"><a href="#PIPE类型命令" class="headerlink" title="PIPE类型命令"></a>PIPE类型命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> PIPE:<br>    pcmd = (<span class="hljs-keyword">struct</span> pipecmd*)cmd;<br>    <span class="hljs-keyword">if</span>(pipe(p) &lt; <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;pipe&quot;</span>);<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)&#123;<br>      close(<span class="hljs-number">1</span>);<br>      dup(p[<span class="hljs-number">1</span>]);<br>      close(p[<span class="hljs-number">0</span>]);<br>      close(p[<span class="hljs-number">1</span>]);<br>      runcmd(pcmd-&gt;left);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)&#123;<br>      close(<span class="hljs-number">0</span>);<br>      dup(p[<span class="hljs-number">0</span>]);<br>      close(p[<span class="hljs-number">0</span>]);<br>      close(p[<span class="hljs-number">1</span>]);<br>      runcmd(pcmd-&gt;right);<br>    &#125;<br>    close(p[<span class="hljs-number">0</span>]);<br>    close(p[<span class="hljs-number">1</span>]);<br>    wait(<span class="hljs-number">0</span>);<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>这个也和重定向的思路一样，管道命令就是把left命令的输出当作right命令的输入，left命令把内容输出到文件描述符为0的文件中，right命令往文件描述符为1的文件中读取内容。<br>所以left程序执行<code>close(1); dup(p[1]); close(p[0]); close(p[1])</code>后(<code>p[1]</code>是管道的写口)，管道的写口的文件描述符就为1了(查看<code>dup</code>系统调用的效果)<br>同样，right程序也是这一个思路。<br>这样的设置后，两个进程就可以通过管道进行通信了。</p><h3 id="BACK类型命令"><a href="#BACK类型命令" class="headerlink" title="BACK类型命令"></a>BACK类型命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> BACK:<br>    bcmd = (<span class="hljs-keyword">struct</span> backcmd*)cmd;<br>    <span class="hljs-keyword">if</span>(fork1() == <span class="hljs-number">0</span>)<br>      runcmd(bcmd-&gt;cmd);<br>    <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>这个命令的实现也很简单，父进程不再等待子进程的结束就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Printf的实现</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9Aprintf%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9Aprintf%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="printf函数的实现"><a href="#printf函数的实现" class="headerlink" title="printf函数的实现"></a><strong>printf函数的实现</strong></h2><p>在介绍<code>printf</code> 函数之前，我们先要来了解一下C语言里面是如何实现边长参数的。<code>printf</code> 正是通过变长参数来实现格式化的打印的。</p><h3 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a><strong>C 可变参数</strong></h3><p>声明方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span> <span class="hljs-params">(<span class="hljs-type">int</span> arg1, ...)</span>;<br></code></pre></td></tr></table></figure><p>其中<code>...</code> 表示可变参数列表。</p><p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（**…**），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数（这里只是在我们的例子中这样规定，实际上没有任何关系）。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p><ul><li>定义好函数，最后一个参数为省略号，省略号前面设置自定义参数</li><li>在函数定义中创建一个<code>va_list</code> 类型变量。</li><li>使用int参数和<code>va_start()</code> 宏来初始化<code>va_list</code> 变量为一个参数列表。</li><li>使用<code>va_arg()</code> 宏和<code>va_list</code> 变量访问参数列表每一项。</li><li>使用宏<code>va_end()</code> 来青绿赋予<code>va_list</code> 变量的内存。</li></ul><p>常用的宏有：</p><ul><li><code>va_start(ap, last_arg)</code>：初始化可变参数列表。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>last_arg</code> 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 <code>ap</code> 指向可变参数列表中的第一个参数。</li><li><code>va_arg(ap, type)</code>：获取可变参数列表中的下一个参数。<code>ap</code> 是一个 <code>va_list</code> 类型的变量，<code>type</code> 是下一个参数的类型。该宏返回类型为 <code>type</code> 的值，并将 <code>ap</code> 指向下一个参数。</li><li><code>va_end(ap)</code>：结束可变参数列表的访问。<code>ap</code> 是一个 <code>va_list</code> 类型的变量。该宏将 <code>ap</code> 置为 <code>NULL</code>。</li></ul><p>我们看一个小例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br> <br><span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span> num,...)</span>&#123;<br>    va_list valist;<br>    <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">int</span> i;<br> <br>    <span class="hljs-comment">/* 初始化 valist, num 为最后一个固定参数，valist指向了可变参数列表的第一个参数 */</span><br>    va_start(valist, num);<br> <br>    <span class="hljs-comment">/* 访问所有赋给 valist 的参数 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>       sum += va_arg(valist, <span class="hljs-type">int</span>);<br>    &#125;<br>    <span class="hljs-comment">/* 清理为 valist 保留的内存 */</span><br>    va_end(valist);<br> <br>    <span class="hljs-keyword">return</span> sum/num;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average of 2, 3, 4, 5 = %f\n&quot;</span>, average(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Average of 5, 10, 15 = %f\n&quot;</span>, average(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="printf格式化打印"><a href="#printf格式化打印" class="headerlink" title="printf格式化打印"></a><strong>printf格式化打印</strong></h3><p>有了可边长参数的知识，我们就可以实现一个简单的<code>printf</code> 函数了。</p><p>发现这个<code>printf</code> 函数实现也确实比较容易。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>  va_list ap;<br>  <span class="hljs-type">int</span> i, c, locking;<br>  <span class="hljs-type">char</span> *s;<br><br>  locking = pr.locking;<br>  <span class="hljs-keyword">if</span>(locking)<br>    acquire(&amp;pr.lock);<br><br>  <span class="hljs-keyword">if</span> (fmt == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;null fmt&quot;</span>);<br><br>  va_start(ap, fmt);<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; (c = fmt[i] &amp; <span class="hljs-number">0xff</span>) != <span class="hljs-number">0</span>; i++)&#123;<br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-string">&#x27;%&#x27;</span>)&#123;<br>      consputc(c);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    c = fmt[++i] &amp; <span class="hljs-number">0xff</span>;<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">switch</span>(c)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>      printint(va_arg(ap, <span class="hljs-type">int</span>), <span class="hljs-number">10</span>, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;x&#x27;</span>:<br>      printint(va_arg(ap, <span class="hljs-type">int</span>), <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:<br>      printptr(va_arg(ap, uint64));<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>      <span class="hljs-keyword">if</span>((s = va_arg(ap, <span class="hljs-type">char</span>*)) == <span class="hljs-number">0</span>)<br>        s = <span class="hljs-string">&quot;(null)&quot;</span>;<br>      <span class="hljs-keyword">for</span>(; *s; s++)<br>        consputc(*s);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;%&#x27;</span>:<br>      consputc(<span class="hljs-string">&#x27;%&#x27;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-comment">// Print unknown % sequence to draw attention.</span><br>      consputc(<span class="hljs-string">&#x27;%&#x27;</span>);<br>      consputc(c);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(locking)<br>    release(&amp;pr.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>char* fmt</code> 就是最后一个固定参数，也是一个字符串，比如这样<code>a is %d, b is %d \n</code> ，这样，我们的目的就是遍历这个<code>fmt</code> 的字符数组，找到所有以<code>%</code> 开头的，这都是一个潜在的格式化打印的地方。</p><p>我们来看<code>printint</code> 函数，因为只是一个数字，我们的<code>consputc</code> 只能打印字符，所以我们不仅需要把整数转换成字符串，还需要考虑正负号(<code>sign</code> 为1表示要打印符号)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">printint</span><span class="hljs-params">(<span class="hljs-type">int</span> xx, <span class="hljs-type">int</span> base, <span class="hljs-type">int</span> sign)</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">int</span> i;<br>  uint x;<br><br>  <span class="hljs-keyword">if</span>(sign &amp;&amp; (sign = xx &lt; <span class="hljs-number">0</span>))<br>    x = -xx;<br>  <span class="hljs-keyword">else</span><br>    x = xx;<br><br>  i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">do</span> &#123;<br>    buf[i++] = digits[x % base];<br>  &#125; <span class="hljs-keyword">while</span>((x /= base) != <span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">if</span>(sign)<br>    buf[i++] = <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>  <span class="hljs-keyword">while</span>(--i &gt;= <span class="hljs-number">0</span>)<br>    consputc(buf[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实这个<code>printf</code> 实现还是很简单，例如没有考虑到<code>%ld</code> 这种<code>%</code> 后面跟两个字符的格式化标志。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fork&amp;&amp;Execve的实现</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9Afork&amp;&amp;execve/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/xv6%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%EF%BC%9Afork&amp;&amp;execve/</url>
    
    <content type="html"><![CDATA[<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a><strong>Fork</strong></h2><p>我们来看一下<code>fork</code>函数是如何实现的，<code>fork</code>是完全把父进程的状态机复制了一份。</p><p>首先，先获取当前进行系统调用的线程，然后再<code>allocproc</code>申请一个新的进程。在xv6操作系统中，进程的管理是一个<code>proc</code>数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>然后就把页表复制一份给子进程。再设置一下子进程的<code>trapframe</code>。</p><blockquote><p>回忆一下，trapframe是什么，trapframe就是进行系统调用陷入内核的时候需要保存的一些寄存器现场等相关的Context。</p></blockquote><p>接下来设置<code>np-&gt;trapframe-&gt;a0 = 0;</code>，也就是子进程返回值是0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Copy user memory from parent to child.</span><br><span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>  freeproc(np);<br>  release(&amp;np-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>np-&gt;sz = p-&gt;sz;<br>*(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>接下来，由于子进程会完整地继承父进程打开的文件，所以这里需要<code>filedup</code>。设置子进程当前的工作目录<code>cwd</code>，然后就是把子进程的状态设置为<code>RUNNABLE</code>，再下次线程切换的时候，子进程就可以执行了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  release(&amp;np-&gt;lock);<br><br>  acquire(&amp;wait_lock);<br>  np-&gt;parent = p;<br>  release(&amp;wait_lock);<br><br>  acquire(&amp;np-&gt;lock);<br>  np-&gt;state = RUNNABLE;<br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br></code></pre></td></tr></table></figure><p>这里的<code>return pid</code>和<code>np-&gt;trapframe-&gt;a0 = 0;</code>很tricky，调用<code>sys_fork</code>系统调用的只是父进程，所以父进程返回<code>pid</code>；而系统调用的返回值通常保存在寄存器<code>a0</code>中，所以这样设置实现了<code>fork</code>两次返回的效果。</p><h2 id="Exec"><a href="#Exec" class="headerlink" title="Exec"></a><strong>Exec</strong></h2><p><code>exec</code>函数相比之下还是要复杂得多了，这个函数需要解析elf文件格式，将二进制文件加载到进程的地址空间中。</p><p>首先我们打开这个文件，<code>namei</code>函数就是通过文件路径找到文件的<code>inode</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">exec</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>  <span class="hljs-type">char</span> *s, *last;<br>  <span class="hljs-type">int</span> i, off;<br>  uint64 argc, sz = <span class="hljs-number">0</span>, sp, ustack[MAXARG], stackbase;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> <span class="hljs-title">elf</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> <span class="hljs-title">ph</span>;</span><br>  <span class="hljs-type">pagetable_t</span> pagetable = <span class="hljs-number">0</span>, oldpagetable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  begin_op();<br><br>  <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  ilock(ip);<br></code></pre></td></tr></table></figure><p>然后，我们通过<code>readi</code>函数读取elf文件的elf header。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;elf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(elf)) != <span class="hljs-keyword">sizeof</span>(elf))<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(elf.magic != ELF_MAGIC)<br>    <span class="hljs-keyword">goto</span> bad;<br></code></pre></td></tr></table></figure><p>有了elf header，就知道elf文件中程序头表（Program Header Table）的偏移量，程序头表就是一个个程序头(Program Header)的数组的起始位置，然后我们就可以获取它的每一个程序头，这个程序头<code>proghdr</code>有一个虚拟地址<code>ph.vaddr</code>表示它应该被映射到地址空间的位置，<code>ph.filesz</code>表示要映射的大小，<code>ph.off</code>表示要映射的文件内容在文件中的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Load program into memory.</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>, off=elf.phoff; i&lt;elf.phnum; i++, off+=<span class="hljs-keyword">sizeof</span>(ph))&#123;<br>  <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)&amp;ph, off, <span class="hljs-keyword">sizeof</span>(ph)) != <span class="hljs-keyword">sizeof</span>(ph))<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.type != ELF_PROG_LOAD)<br>    <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-keyword">if</span>(ph.memsz &lt; ph.filesz)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(ph.vaddr + ph.memsz &lt; ph.vaddr)<br>    <span class="hljs-keyword">goto</span> bad;<br>  uint64 sz1;<br>  <span class="hljs-keyword">if</span>((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  sz = sz1;<br>  <span class="hljs-keyword">if</span>((ph.vaddr % PGSIZE) != <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span>(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来展示一下<code>loadseg</code>的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">loadseg</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-keyword">struct</span> inode *ip, uint offset, uint sz)</span><br>&#123;<br>  uint i, n;<br>  uint64 pa;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    pa = walkaddr(pagetable, va + i);<br>    <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;loadseg: address should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>(sz - i &lt; PGSIZE)<br>      n = sz - i;<br>    <span class="hljs-keyword">else</span><br>      n = PGSIZE;<br>    <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)pa, offset+i, n) != n)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6代码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6代码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁的实现</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="自旋锁（Spin-lock）的实现"><a href="#自旋锁（Spin-lock）的实现" class="headerlink" title="自旋锁（Spin lock）的实现"></a>自旋锁（Spin lock）的实现</h2><ul><li>什么是自旋锁<br>自旋锁是一种忙等待的锁机制。锁的特性就是只有一个进程可以获取锁，在任何时间点都不能有超过一个锁的持有者。<br>在<code>acquire</code>里面有一个死循环，循环中判断锁对象的locked字段是否为0，如果为0那表明当前锁没有持有者，当前对于<code>acquire</code>的调用可以获取锁。之后我们通过设置锁对象的<code>locked</code>字段为1来获取锁。最后返回。</li></ul><blockquote><p>但两个进程可能同时读到 locked 字段为 0.</p></blockquote><p>这就需要原子指令 <code>test-and-set</code>，在RISC-V上，这个特殊的指令就是<code>amoswap</code>（atomic memory swap）。这个指令接收3个参数，分别是address，寄存器r1，寄存器r2。这条指令会先锁定住address，将address中的数据保存在一个临时变量中（tmp），之后将r1中的数据写入到地址中，之后再将保存在临时变量中的数据写入到r2中，最后再对于地址解锁。</p><ul><li>代码实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Mutual exclusion lock.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>  uint locked;       <span class="hljs-comment">// Is the lock held?</span><br><br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">cpu</span>;</span>   <span class="hljs-comment">// The cpu holding the lock.</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  push_off(); <span class="hljs-comment">// disable interrupts to avoid deadlock.</span><br>  <span class="hljs-keyword">if</span>(holding(lk))<br>    panic(<span class="hljs-string">&quot;acquire&quot;</span>);<br><br>  <span class="hljs-comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span><br>  <span class="hljs-comment">//   a5 = 1</span><br>  <span class="hljs-comment">//   s1 = &amp;lk-&gt;locked</span><br>  <span class="hljs-comment">//   amoswap.w.aq a5, a5, (s1)</span><br>  <span class="hljs-keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    ;<br><br>  <span class="hljs-comment">// Tell the C compiler and the processor to not move loads or stores</span><br>  <span class="hljs-comment">// past this point, to ensure that the critical section&#x27;s memory</span><br>  <span class="hljs-comment">// references happen strictly after the lock is acquired.</span><br>  <span class="hljs-comment">// On RISC-V, this emits a fence instruction.</span><br>  __sync_synchronize();<br><br>  <span class="hljs-comment">// Record info about lock acquisition for holding() and debugging.</span><br>  lk-&gt;cpu = mycpu();<br>&#125;<br></code></pre></td></tr></table></figure>由于关闭了中断，所以这一个进程还是在同一个CPU核上运行的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">holding</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-type">int</span> r;<br>  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>__sync_synchronize() 函数的作用是创建一个内存屏障（memory barrier）或者称为内存栅栏（memory fence）。内存屏障是一种同步机制，用于确保在屏障之前的所有内存访问操作都在屏障之前完成，并且在屏障之后的所有内存访问操作都在屏障之后执行。<br>告诉编译器和处理器在该点之前和之后的内存操作不能被重排序或优化。这样可以确保在自旋锁的临界区代码执行之前，所有对临界区相关的内存访问都已经完成，而在临界区代码执行之后，所有对临界区相关的内存访问都已经生效。</p></blockquote></li></ul><h2 id="睡眠锁"><a href="#睡眠锁" class="headerlink" title="睡眠锁"></a>睡眠锁</h2><p>xv6中还有一种锁比较有趣，叫做睡眠锁。<br>首先我们得知道自旋锁的缺点有什么。</p><blockquote><p>持有锁的进程不会主动出让CPU,其他进程要获取锁，长时间的自旋也会引起长时间的浪费。</p></blockquote><p>这里有一种矛盾，当持有锁的时候让出CPU给其他线程(<code>sched</code>)是违法的，因为其他线程如果也要<code>acquire</code>获取这把锁,就会导致死锁。同时，这种做法同样也违反了当自旋锁被持有的时候中断必须关闭的要求。<br>所以，我们就要设计一种锁，它在被<code>acquire</code>等待的时候能够让出CPU,以及允许持有这种锁的时候让出和中断的锁。</p><h3 id="错误的设计："><a href="#错误的设计：" class="headerlink" title="错误的设计："></a>错误的设计：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">V</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span><br>&#123;<br>    acquire(&amp;s-&gt;lock);<br>    s-&gt;count += <span class="hljs-number">1</span>;<br>    wakeup(s);             <span class="hljs-comment">// change this</span><br>    release(&amp;s-&gt;lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *s)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (s-&gt;count == <span class="hljs-number">0</span>)<br>        sleep(s);          <span class="hljs-comment">// change this</span><br>    acquire(&amp;s-&gt;lock);<br>    s-&gt;count -= <span class="hljs-number">1</span>;<br>    release(&amp;s-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，存在一个问题，就是当一个线程发现<code>count</code>为0时，还没执行<code>sleep</code>函数时，另一个线程执行了V操作，<code>count</code>加了1，<code>wakeup</code>再把所有的<code>chan</code>为<code>s</code>的线程的<code>state</code>从<code>sleeping</code>改为<code>runable</code>。接着P进程接着执行<code>sleep</code>函数，把自己的<code>state</code>改为<code>sleeping</code>。<br>所以这就存在一个问题，P进程可能永远不会被唤醒，除非V进程再次调用了<code>wakeup</code>。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>上面问题的根源就是P只在<code>s-&gt;count==0</code>时睡眠的不变量被正在运行的V给破坏了。<br>但是又不能在P<code>while</code>循环前面申请锁，这样很明显会造成死锁。<br>正确实现：</p><blockquote><p>修改sleep接口来修复上述方案：调用者必须传递一个条件锁给sleep，使得其可以在睡眠调用的进程并在睡眠通道上等待时释放锁。锁会强制并行的V等待直到P将它自己睡眠，因此wakeup会找到一个正在睡眠的消费者并唤醒它。一旦消费者被唤醒，sleep就需要在返回前再次获取锁。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Long-term locks for processes</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> &#123;</span><br>  uint locked;      / Is the lock held?<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lk</span>;</span> <span class="hljs-comment">// spinlock protecting this sleep lock</span><br>  <br>  <span class="hljs-comment">// For debugging:</span><br>  <span class="hljs-type">char</span> *name;        <span class="hljs-comment">// Name of lock.</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process holding lock</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，<code>sleeplock</code>有两把锁。</p><p>在这之前，先简单了解一下<code>sleep</code>函数和<code>wakeup</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//DOC: sleeplock1</span><br>  release(lk);<br><br>  <span class="hljs-comment">// Go to sleep.</span><br>  p-&gt;chan = chan;<br>  p-&gt;state = SLEEPING;<br><br>  sched();<br><br>  <span class="hljs-comment">// Tidy up.</span><br>  p-&gt;chan = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Reacquire original lock.</span><br>  release(&amp;p-&gt;lock);<br>  acquire(lk);<br>&#125;<br><br><span class="hljs-comment">// Wake up all processes sleeping on chan.</span><br><span class="hljs-comment">// Must be called without any p-&gt;lock.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-keyword">if</span>(p != myproc())&#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;<br>        p-&gt;state = RUNNABLE;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在xv6的<code>proc</code>结构体中，有一个<code>chan</code>字段用于实现进程的等待通道的。当一个进程需要等待某一个事件时，需要把<code>chan</code>字段设置为相应的通道或条件。</p><p>下面看<code>acquiresleep</code>和<code>releasesleep</code>函数的代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">acquiresleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span><br>&#123;<br>  acquire(&amp;lk-&gt;lk);<br>  <span class="hljs-keyword">while</span> (lk-&gt;locked) &#123;<br>    sleep(lk, &amp;lk-&gt;lk);<br>  &#125;<br>  lk-&gt;locked = <span class="hljs-number">1</span>;<br>  lk-&gt;pid = myproc()-&gt;pid;<br>  release(&amp;lk-&gt;lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">releasesleep</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sleeplock *lk)</span><br>&#123;<br>  acquire(&amp;lk-&gt;lk);<br>  lk-&gt;locked = <span class="hljs-number">0</span>;<br>  lk-&gt;pid = <span class="hljs-number">0</span>;<br>  wakeup(lk);<br>  release(&amp;lk-&gt;lk);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>acquiresleep</code>函数首先会申请<code>lk-&gt;lk</code>这把锁，这使得在执行<code>while</code>语句的时候不会有其他线程的<code>wakeup</code>操作。<br>在进入<code>sleep</code>函数的时候，就可以释放<code>lk-&gt;lk</code>这把锁，其他线程可能会尝试调用<code>wakeup</code>,但进入<code>sleep</code>的线程会事先<code>aquire(&amp;myproc-&gt;lock)</code>,<code>wakeup</code>也会尝试获取线程的锁，所以这样不会引起唤醒丢失。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程切换(2)</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A22/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A22/</url>
    
    <content type="html"><![CDATA[<h2 id="线程切换过程中锁的限制"><a href="#线程切换过程中锁的限制" class="headerlink" title="线程切换过程中锁的限制"></a>线程切换过程中锁的限制</h2><ul><li><p>在线程切换的过程中需要一直持有p-&gt;lock</p><blockquote><p>防止两个CPU核使用同一个栈运行同一个线程</p></blockquote></li><li><p>XV6中，不允许进程在执行switch函数的过程中，持有任何其他的锁。</p><blockquote><p>防止死锁。<br>示例：如果xv6在内核中关闭了中断，P1的内核线程持有了p-&gt;lock以外的其他锁，这些锁可能是在使用磁盘，UART，console过程中持有的。之后内核线程在持有锁的时候，通过调用switch&#x2F;yield&#x2F;sched函数出让CPU，这会导致进程P1持有了锁，但是进程P1又不在运行。假设P2也想使用磁盘，UART或者console，它会对P1持有的锁调用acquire，这是对于同一个锁的第二个acquire调用。当然这个锁现在已经被P1持有了，所以这里的acquire并不能获取锁。</p></blockquote></li></ul><hr><h2 id="sleep和wakeup接口"><a href="#sleep和wakeup接口" class="headerlink" title="sleep和wakeup接口"></a>sleep和wakeup接口</h2><p>进程有时候需要等待特定事件的。特定事件可能来自于I&#x2F;O，也可能来自于另一个进程，并且它描述了某件事情已经发生。Coordination是帮助我们解决这些问题并帮助我们实现这些需求的工具。<br>实现方式：</p><ol><li>busy-wait:只适用于等待时间很短的事件中</li><li>Coordination:出让CPU，直到等待的事件发生再恢复执行</li></ol><p>sleep函数：睡眠该线程，等待一个特定的事件。<br>wakeup函数：唤醒正在等待刚刚发生的特定事件的线程。<br>sleep函数和wakeup函数都带有一个叫做sleep channel的参数。我们在调用wakeup的时候，需要传入与调用sleep函数相同的sleep channel。不过sleep和wakeup函数只是接收表示了sleep channel的64bit数值，它们并不关心这个数值代表什么。当我们调用sleep函数时，我们通过一个sleep channel表明我们等待的特定事件，当调用wakeup时我们希望能传入相同的数值来表明想唤醒哪个线程。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程切换(1)</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A21/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A21/</url>
    
    <content type="html"><![CDATA[<h2 id="xv6中的线程"><a href="#xv6中的线程" class="headerlink" title="xv6中的线程"></a>xv6中的线程</h2><p>一个线程可以认为是串行执行代码的单元。</p><ol><li>内核线程的概念，对于每个用户进程都有一个内核线程来执行来自用户进程的系统调用。所有的内核线程都共享了内核内存，所以XV6的内核线程的确会共享内存。</li><li>每一个用户进程都有独立的内存地址空间，并且包含了一个线程，这个线程控制了用户进程代码指令的执行。所以XV6中的用户线程之间没有共享内存，你可以有多个用户进程，但是每个用户进程都是拥有一个线程的独立地址空间。XV6中的进程不会共享内存。<blockquote><p>在一些其他更加复杂的系统中，例如Linux，允许在一个用户进程中包含多个线程，进程中的多个线程共享进程的地址空间</p></blockquote></li></ol><hr><h2 id="xv6线程调度"><a href="#xv6线程调度" class="headerlink" title="xv6线程调度"></a>xv6线程调度</h2><p><strong>每个CPU核都创建了一个线程调度器</strong>。<br>对于运算密集型线程，线程调度可以利用定时器中断。定时器中断处理程序会自愿的将CPU让出(yield)给线程调度器，让其他线程运行。<br>线程状态：</p><ol><li>RUNNING，线程当前正在某个CPU上运行</li><li>RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行</li><li>SLEEPING，这个状态意味着线程在等待一些I&#x2F;O事件，它只会在I&#x2F;O事件发生了之后运行</li></ol><hr><h2 id="xv6线程切换"><a href="#xv6线程切换" class="headerlink" title="xv6线程切换"></a>xv6线程切换</h2><p>用户程序在运行时，实际上是用户进程中的一个用户线程在运行。如果程序执行了一个系统调用或者因为响应中断走到了内核中，那么相应的用户空间状态会被保存在程序的<code>trapframe</code>中，同时属于这个用户程序的内核线程被激活。<br>如果XV6内核决定从一个用户进程切换到另一个用户进程，那么首先在内核中第一个进程的内核线程会被切换到第二个进程的内核线程。之后再在第二个进程的内核线程中返回到用户空间的第二个进程，这里返回到用户空间也是通过恢复<code>trapframe</code>完成的。</p><p>完整过程（以时钟切换为例）：</p><ol><li>定时器中断强迫CPU从用户空间切换到内核，用户空间的代码保存在<code>trapframe</code>中。</li><li>内核运行<code>usertrap</code>，这时候运行的是进程1的内核线程。</li><li>调用<code>swtch</code>函数，保存进程1的内核线程寄存器到<code>context</code>对象，在<code>proc</code>结构体中有一个<code>context</code>。(用户寄存器在<code>trapframe</code>，内核线程寄存器在<code>context</code>)。</li><li><code>swtch</code>函数恢复原来在这个CPU上的调度器线程保存的寄存器和stack pointer,<code>swtch</code>函数返回后，CPU寄存器被设置为调度器线程的上下文，然后就在调度下线程的context下执行<code>scheduler</code>函数。</li><li><code>scheduler</code>函数把P1设置成RUNABLE状态，查找下一个RUNABLE进程，再次调用<code>swtch</code>函数, <code>swtch</code>函数完成后，返回到了新线程的上下文中。<blockquote><p>整个xv6中一个CPU核对应一个内核调度线程，它在系统启动时创建。这个内核调度线程是一个死循环，它不断地选择可运行的进程并进行上下文切换，以实现多进程并发。XV6的start.s文件，可以看到为每个CPU核设置好调度器线程。</p></blockquote></li></ol><hr><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><h3 id="yield函数"><a href="#yield函数" class="headerlink" title="yield函数"></a>yield函数</h3><p><code>yield</code>是线程切换的第一步。当触发时钟中断时，会调用<code>yield</code>函数，当前进程会出让CPU并让另一个进程运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);<br>  p-&gt;state = RUNNABLE;<br>  sched();<br>  release(&amp;p-&gt;lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要内容是加锁，防止一个线程在多个CPU核上被调度。将进程的状态改为RUNABLE，表示让出CPU，随后执行<code>sched</code>函数。</p><h3 id="sched函数"><a href="#sched函数" class="headerlink" title="sched函数"></a>sched函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sched</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> intena;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(!holding(&amp;p-&gt;lock))<br>    panic(<span class="hljs-string">&quot;sched p-&gt;lock&quot;</span>);<br>  <span class="hljs-keyword">if</span>(mycpu()-&gt;noff != <span class="hljs-number">1</span>)<br>    panic(<span class="hljs-string">&quot;sched locks&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;state == RUNNING)<br>    panic(<span class="hljs-string">&quot;sched running&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get())<br>    panic(<span class="hljs-string">&quot;sched interruptible&quot;</span>);<br><br>  intena = mycpu()-&gt;intena;<br>  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);<br>  mycpu()-&gt;intena = intena;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="swtch函数"><a href="#swtch函数" class="headerlink" title="swtch函数"></a>swtch函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">.globl swtch<br>swtch:<br>        sd ra, 0(a0)<br>        ....省略<br><br>        ld ra, 0(a1)<br>        ....省略<br>        ret<br></code></pre></td></tr></table></figure><blockquote><p>a0是p-&gt;context的地址，a1是cpu中的context结构体地址</p></blockquote><ol><li>会将当前的内核线程的寄存器(ra,sp,s0等)保存到p-&gt;context中,proc结构体中的context字段就是用来保存该进程内核线程寄存器的。</li><li>然后会把cpu中的context赋值给(ra,sp,s0)等寄存器<blockquote><p><strong>CPU结构体中的context保存了当前CPU核的调度器线程的寄存器!!!</strong><br>内核调度线程没有进程与之对应，并且一个CPU核只有一个内核调度线程，所以把它所需要的context直接放到了cpu的context结构体中保存。而cpu中context结构体中有一个返回地址一定就是scheduler函数的某一条指令。</p></blockquote></li></ol><ul><li><p>swtch函数中只保存并恢复了14个寄存器</p><blockquote><p><strong>switch是按照一个普通函数来调用的</strong>，对于有些寄存器，<code>swtch</code>函数的调用者默认<code>swtch</code>函数会做修改，所以调用者已经在自己的栈上保存了这些寄存器，当函数返回时，这些寄存器会自动恢复。所以<code>swtch</code> 函数里只需要保存Callee Saved Register就行。</p></blockquote></li><li><p>返回地址的妙用</p><blockquote><p>正因为switch是按照一个普通函数来调用的，在这里，所以<code>ra</code>寄存器存储的是内核线程1的返回地址，随后<code>ld ra, 0(a1)</code>指令，<strong>把返回地址给换了</strong>，换成了CPU处理器调度器线程的返回地址，以及后面的一些上下文。随后<code>swtch</code>函数完成后，返回到了<code>scheduler</code>函数。</p></blockquote></li></ul><h3 id="scheduler函数"><a href="#scheduler函数" class="headerlink" title="scheduler函数"></a>scheduler函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">scheduler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cpu</span> *<span class="hljs-title">c</span> =</span> mycpu();<br><br>  c-&gt;proc = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (;;)<br>  &#123;<br>    <span class="hljs-comment">// Avoid deadlock by ensuring that devices can interrupt.</span><br>    intr_on();<br><br>    <span class="hljs-keyword">for</span> (p = proc; p &lt; &amp;proc[NPROC]; p++)<br>    &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span> (p-&gt;state == RUNNABLE)<br>      &#123;<br>        <span class="hljs-comment">// Switch to chosen process.  It is the process&#x27;s job</span><br>        <span class="hljs-comment">// to release its lock and then reacquire it</span><br>        <span class="hljs-comment">// before jumping back to us.</span><br>        p-&gt;state = RUNNING;<br>        c-&gt;proc = p;<br>        swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br><br>        <span class="hljs-comment">// Process is done running for now.</span><br>        <span class="hljs-comment">// It should have changed its p-&gt;state before coming back.</span><br>        c-&gt;proc = <span class="hljs-number">0</span>;<br>      &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调度器线程在<code>scheduler</code>函数中也会调用了<code>swtch</code>函数，同样的，它把CPU上寄存器换成了新线程的，并把调度器线程的寄存器保存到了<code>mycpu()-&gt;context</code>中。所以我们从<code>swtch</code>函数返回时，如果不考虑调度器线程在里面的作用，实际上是返回到了对于<code>switch</code>的另一个调用，而不是调度器线程中的调用。<strong>我们返回到的是调度到的新进程在很久之前对于switch的调用</strong>。这就是线程切换的核心。</p><blockquote><p>在课程的示例中，P1线程由于定时器的中断而被调度，执行<code>yield</code>函数，<code>sched</code>函数，<code>swtch</code>函数后而被阻塞。假设P2线程正在执行，随后P2线程也经过同样的过程再执行调度线程，再执行P1,P1被唤醒的刚开始执行指令的地址就是<code>sched</code>函数中的<code>swtch</code>的返回地址。<br>如果不是因为定时器中断发生的切换，ra寄存器可能指向其他位置。</p></blockquote><p>scheduler函数又会调用swtch函数，但参数稍有不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;state = RUNNING;<br>c-&gt;proc = p;<br>swtch(&amp;c-&gt;context, &amp;p-&gt;context);<br></code></pre></td></tr></table></figure><blockquote><p>这样就把当前调度器线程的寄存器传入cpu的context结构体中。再把寄存器的值换成调度的新进程的内核线程的context。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用和trap</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Ctrap/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8Ctrap/</url>
    
    <content type="html"><![CDATA[<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>这篇笔记主要帮助回顾xv6是如何经过trap陷入到内核去的，介绍相关的代码的重要的细节。</p><ul><li>重要的寄存器</li></ul><ol><li><code>SATP</code>（Supervisor Address Translation and Protection）：它包含了指向page table的物理内存地址</li><li><code>STVEC</code>（Supervisor Trap Vector Base Address Register）：它指向了内核中处理trap的指令的起始地址。</li><li><code>SEPC</code>（Supervisor Exception Program Counter）：在trap的过程中保存程序计数器的值。</li><li><code>SSRATCH</code>（Supervisor Scratch Register）寄存器：在ecall指令前指向的是进程trapframe的地址<blockquote><p>trapframe在虚拟地址空间中位于trampoline的上一页(地址低于trampoline)。</p></blockquote></li></ol><ul><li>trap 调用的函数<blockquote><p>uservec -&gt; usertrap -&gt; usertrapret -&gt; userret.</p></blockquote></li></ul><h2 id="ecall指令做了什么？"><a href="#ecall指令做了什么？" class="headerlink" title="ecall指令做了什么？"></a>ecall指令做了什么？</h2><ol><li><code>ecall</code>将代码从user mode改到supervisor mode。</li><li><code>ecall</code>将程序计数器的值保存在了SEPC寄存器。</li><li><code>ecall</code>会跳转到STVEC寄存器指向的指令<blockquote><p>ecall并没有切换到内核的页表。也没有找到一个内核栈(C代码的执行需要栈)</p></blockquote></li></ol><h2 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h2><p>执行完<code>ecall</code>指令，会跳转到<code>STVEC</code>所指向的地址处，这是位于<code>trampoline</code>页面的第一条地址。</p><blockquote><p>内核已经事先设置好了STVEC寄存器的内容为0x3ffffff000。</p></blockquote><ol><li><p>首先交换<code>a0</code>和<code>SSRATCH</code>寄存器的值</p><blockquote><p>腾出一个通用寄存器, a0指向trapframe,注意此时还没有切换页表。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">csrrw a0, sscratch, a0<br></code></pre></td></tr></table></figure></li><li><p>将各种寄存器的值保存在trapframe中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">sd ra, 40(a0)<br>sd sp, 48(a0)<br>.....<br></code></pre></td></tr></table></figure></li><li><p>在trapframe中获取一些相关的信息，比如说<code>usertrap</code>的地址， kernel stack， current hartid</p></li><li><p>切换到内核的页表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">ld t1, 0(a0)<br>csrw satp, t1<br></code></pre></td></tr></table></figure></li><li><p>然后跳转到<code>usertrap</code>函数中。</p></li></ol><h2 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h2><p>这时候已经在内核的页表中了。</p><ol><li><p>更改<code>stvec</code>寄存器的值,获取当前进程</p><blockquote><p>trap如果从内核空间发起，将会是一个非常不同的处理流程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">w_stvec((uint64)kernelvec);<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br></code></pre></td></tr></table></figure><blockquote><p>myproc函数实际上会查找一个根据当前CPU核的编号索引的数组，CPU核的编号是hartid，如果你还记得，我们之前在uservec函数中将它存在了tp寄存器。这是myproc函数找出当前运行进程的方法。</p></blockquote></li><li><p>保存pc</p><blockquote><p>中途可能切换到另一个进程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br></code></pre></td></tr></table></figure></li><li><p>检查trap的原因，并执行相应的操作。例如如果是系统调用就调用syscall函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br></code></pre></td></tr></table></figure><blockquote><p>epc还需要+4，是因为在RISC-V中，存储在SEPC寄存器中的程序计数器，是用户程序中触发trap的指令的地址。但是当我们恢复用户程序时，我们希望在下一条指令恢复，也就是ecall之后的一条指令。</p></blockquote></li><li><p>调用<code>usertrapret</code>函数</p></li></ol><h2 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h2><p>返回到用户空间之前内核要做的工作.</p><ol><li>关闭了中断,stvec指向用户空间的trap处理代码</li><li>设置trapframe中的数据，这样下一次从用户空间转换到内核空间时可以用到这些数据。</li><li>跳转到函数userret。<blockquote><p>这个跳转有一点细节</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 fn = TRAMPOLINE + (userret - trampoline);<br>((<span class="hljs-type">void</span> (*)(uint64, uint64))fn)(TRAPFRAME, satp);<br></code></pre></td></tr></table></figure><blockquote><p>首先计算出 userret 在trampoline页面的地址，然后再进行一次函数跳转<br>此时<strong>a0寄存器的值为 TRAPFRAME</strong>,<strong>a1寄存器的值为进程的satp</strong>。</p></blockquote></li></ol><h2 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h2><blockquote><p>这段代码也在trampoline页中,所以切换页表后pc并不会出现错误。</p></blockquote><ol><li><p>切换page table。</p></li><li><p>恢复寄存器现场</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm"># put the saved user a0 in sscratch, so we<br># can swap it with our a0 (TRAPFRAME) in the last step.<br>ld t0, 112(a0)<br>csrw sscratch, t0<br><br># restore all but a0 from TRAPFRAME<br>ld ra, 40(a0)<br>ld sp, 48(a0)<br>ld gp, 56(a0)<br>.....<br></code></pre></td></tr></table></figure><p>此时<code>sscratch</code>寄存器的值是系统调用的返回值。<br>回顾一下，在<code>syscall</code>函数中有下面一行,系统调用的返回值覆盖了我们保存在<code>trapframe</code>中的<code>a0</code>寄存器的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/syscall.c</span><br>p-&gt;trapframe-&gt;a0 = syscalls[num]();<br></code></pre></td></tr></table></figure></li><li><p>交换a0和sscratch的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm"># restore user a0, and save TRAPFRAME in sscratch<br>csrrw a0, sscratch, a0<br></code></pre></td></tr></table></figure><p>这样<code>a0</code>就是系统调用的返回值了。<code>sscratch</code>就指向<code>trapframe</code>的地址了。</p></li><li><p>最后调用<code>sret</code>指令</p></li></ol><ul><li>程序会切换回user mode</li><li>SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）</li><li>重新打开中断</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统层级结构</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="1-文件系统组织架构"><a href="#1-文件系统组织架构" class="headerlink" title="1.文件系统组织架构"></a>1.文件系统组织架构</h2><img src="/img/xv6-labs/file-1.png" style="zoom:50%;"><ul><li><p><code>disk</code>层：对硬盘上的块进行读写操作</p></li><li><p><code>buffer cache</code>层：在内存中对磁盘块进行缓存，并确保只有1个内核进程能在一段时间内修改文件块上存储的数据。</p></li><li><p><code>logging</code>层：让更高的层级能够将对文件块的所有<code>update</code>打包到一个<code>transaction</code>中，从而能保证所有文件块能够在将要崩溃时原子地进行<code>update</code></p></li><li><p><code>inode</code>层：为每个文件提供独一无二的inode number</p></li><li><p><code>directory</code>层：每个文件夹也作为一个特殊的inode结构体，不过内容是一条一条的entry</p></li><li><p><code>pathname</code>层：将文件夹组织为层级，解析路径、</p></li><li><p><code>file descriptor</code>层：将所有的资源都抽象为<code>struct file</code>,如设备，文本文件，管道等</p><hr></li></ul><h2 id="2-Disk-层"><a href="#2-Disk-层" class="headerlink" title="2.Disk 层"></a>2.Disk 层</h2><p>xv6文件系统的磁盘块布局如下：</p><img src="/img/xv6-labs/file-2.png" style="zoom:50%;"><ul><li><p><code>block 0</code>：启动区域，文件系统不会使用，包含了操作系统启动所需要的代码</p></li><li><p><code>blcok 1</code>: <code>superblock</code>，存储了文件系统的元数据（block的大小、block的数目、inode的数目等），里面有一个mkfs的程序，用来构建初始的文件系统</p></li><li><p><code>block 2-31</code>：<code>log block</code></p></li><li><p><code>block 32-44</code>: <code>inode</code>，一个<code>inode</code>的大小为64字节，一个<code>block</code>的大小为1024字节，因此<code>block32</code>为<code>inode 1-16</code>，block33为<code>inode 17-32</code></p></li><li><p><code>block 45 bitmap block</code>，用来跟踪哪些<code>block</code>是在使用</p></li><li><p>最后从<code>block 46</code>开始是<code>data block</code>，要么是在<code>bitmap</code>中被标记为空闲状态，要么存储了文件&#x2F;文件夹的内容</p><hr></li></ul><h2 id="3-Buffer-cache层"><a href="#3-Buffer-cache层" class="headerlink" title="3.Buffer cache层"></a>3.Buffer cache层</h2><h3 id="buffer-cache层的作用"><a href="#buffer-cache层的作用" class="headerlink" title="buffer cache层的作用"></a>buffer cache层的作用</h3><ol><li>将对磁盘块的访问权限进行同步，保证内存中只保存一个该磁盘块的拷贝，且一次只有一个内核线程访问这个拷贝，但同时可以有多个对这个<code>block</code>的引用</li><li>将被频繁访问的块缓存到内存中(局部性原理)</li></ol><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p><code>bcache</code>就是内存中对硬盘<code>block</code>的缓冲，<code>head</code>的作用是把<code>bcache</code>组织为一个链表，缓冲区的使用早晚就是通过<code>head</code>来判断的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br></code></pre></td></tr></table></figure><p>buffer cache有两个接口，分别是<code>bread()</code>和<code>bwrite()</code>。<br><code>bread</code>通过<code>bget</code>获取一个指定了设备<code>dev</code>和<code>blockno</code>的<code>buf *</code>，这是从硬盘指定的块中获取的一个缓冲数据结构体。<code>valid</code>表示的是内存中的某个<code>block</code>有无磁盘块的一份拷贝，如果没有就要调用<code>virtio_disk_rw</code>函数从磁盘写到内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，可以允许多个文件指向内存中同一个<code>buffer</code>，这里的替换算法也是相当简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf*<br><span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  acquire(&amp;bcache.lock);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Not cached.</span><br>  <span class="hljs-comment">// Recycle the least recently used (LRU) unused buffer.</span><br>  <span class="hljs-keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;<br>    <span class="hljs-keyword">if</span>(b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>      b-&gt;dev = dev;<br>      b-&gt;blockno = blockno;<br>      b-&gt;valid = <span class="hljs-number">0</span>;<br>      b-&gt;refcnt = <span class="hljs-number">1</span>;<br>      release(&amp;bcache.lock);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为什么要<code>acquiresleep</code>?<blockquote><p>获取这个锁之后立即让这个进程进入睡眠，一旦这个锁可用，该线程就会立刻被唤醒。</p></blockquote></li></ul><p><code>bwrite</code>是向硬盘指定块写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">bwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;bwrite&quot;</span>);<br>  virtio_disk_rw(b, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>brelse</code>是释放操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  acquire(&amp;bcache.lock);<br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    b-&gt;next-&gt;prev = b-&gt;prev;<br>    b-&gt;prev-&gt;next = b-&gt;next;<br>    b-&gt;next = bcache.head.next;<br>    b-&gt;prev = &amp;bcache.head;<br>    bcache.head.next-&gt;prev = b;<br>    bcache.head.next = b;<br>  &#125;<br>  <br>  release(&amp;bcache.lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="4-Block-层"><a href="#4-Block-层" class="headerlink" title="4.Block 层"></a>4.Block 层</h2><p>block allocator为磁盘的是否空闲的状态准备了一个bitmap，每一位对应一个磁盘块，0表示空闲1表示正在使用，<code>mkfs</code>负责设置这些位。</p><p><code>sb</code>是一个super block,它记录了文件系统一些基本信息。<br><code>BBLOCK</code>宏是判断某个逻辑块号的信息在哪个<code>bitmap</code>块中。<br>一个<code>bitmap</code>块中，总共用<code>BSIZE</code>个字节，也就是<code>BPB</code>个bit。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BPB           (BSIZE*8)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</span><br></code></pre></td></tr></table></figure><p>下面的代码中<code>bp</code>是获取到的<code>bitmap</code>块，一个<code>bitmap</code>的每一个bit都用来标记该<code>blockno</code>是不是空闲的。<code>b</code>是遍历到的位图的第0个bit表示的逻辑块号。<code>bi</code>就是偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">balloc</span><span class="hljs-params">(uint dev)</span><br>&#123;<br>  <span class="hljs-type">int</span> b, bi, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  bp = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(b = <span class="hljs-number">0</span>; b &lt; sb.size; b += BPB)&#123;<br>    bp = bread(dev, BBLOCK(b, sb));<br>    <span class="hljs-keyword">for</span>(bi = <span class="hljs-number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123;<br>      m = <span class="hljs-number">1</span> &lt;&lt; (bi % <span class="hljs-number">8</span>);<br>      <span class="hljs-keyword">if</span>((bp-&gt;data[bi/<span class="hljs-number">8</span>] &amp; m) == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// Is block free?</span><br>        bp-&gt;data[bi/<span class="hljs-number">8</span>] |= m;  <span class="hljs-comment">// Mark block in use.</span><br>        log_write(bp);<br>        brelse(bp);<br>        bzero(dev, b + bi);<br>        <span class="hljs-keyword">return</span> b + bi;<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;balloc: out of blocks&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样还需要<code>bfree</code>函数释放硬盘块。</p><hr><h2 id="5-Inode-层"><a href="#5-Inode-层" class="headerlink" title="5.Inode 层"></a>5.Inode 层</h2><p>这里就开始涉及文件是如何组织的了。</p><ol><li><code>inode</code>:内存中的结构，用于文件描述。</li><li><code>dinode</code>:硬盘中的结构，64字节大小，例如<code>inode block</code>中就是存放这些结构体的。它们在硬盘中占据连续的一些块。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-type">short</span> major;<br>  <span class="hljs-type">short</span> minor;<br>  <span class="hljs-type">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// File type</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> nlink;          <span class="hljs-comment">// Number of links to inode in file system</span><br>  uint size;            <span class="hljs-comment">// Size of file (bytes)</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>也就是说内存中的inode是active inodes，即内存中有C指针指向这个inode,ref是指向这个inode指针的数量。ref为0时要删除这个inode</p></blockquote></li></ol><p><code>NDIRECT</code>个<code>addr</code>叫做direct blocks，最后一个<code>addr</code>给出了indirect block的地址，因此一个文件的前12kB（<code>NDIRECT</code> x <code>BSIZE</code>）可以从inode中的direct block <code>addr</code>直接读取，后256kB（<code>NINDIRECT</code> x<code>BSIZE</code>）可以通过indirect block addr翻译得到。因此xv6支持的最大的文件大小为268kB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> <span class="hljs-title">inode</span>[<span class="hljs-title">NINODE</span>];</span><br>&#125; itable;<br></code></pre></td></tr></table></figure><p>内存中的itable也是对<code>dinode block</code>的缓存,也就是<code>inode cache</code> ,<code>inode</code>中的valid就是对这个缓存是否有效的标记。<br><code>iget</code>函数和<code>iput</code>函数在此之上实现对inode指针的获取和释放。<br>典型用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">ip = iget(dev, inum);<br>ilock(ip);<br>...examine and modify ip-&gt;xxx<br><span class="hljs-title function_">iunlock</span><span class="hljs-params">(ip)</span>;<br>iput(ip);<br></code></pre></td></tr></table></figure><p><code>iget</code>返回了一个直到调用<code>iput</code>都有效的<code>inode</code>，任何代码均可同时访问，因此可以有很多指针指向同一个<code>inode</code>。</p><p><code>ialloc</code>负责从硬盘上的inode blocks中寻找空闲的inode，当找到之后将新的type写入到disk中然后通过调用<code>iget</code>返回一个内存中的inode（将这个inode写入到inode cache）中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">ialloc</span><span class="hljs-params">(uint dev, <span class="hljs-type">short</span> type)</span><br>&#123;<br>  <span class="hljs-type">int</span> inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> *<span class="hljs-title">dip</span>;</span><br><br>  <span class="hljs-keyword">for</span>(inum = <span class="hljs-number">1</span>; inum &lt; sb.ninodes; inum++)&#123;<br>    bp = bread(dev, IBLOCK(inum, sb));<br>    dip = (<span class="hljs-keyword">struct</span> dinode*)bp-&gt;data + inum%IPB;<br>    <span class="hljs-keyword">if</span>(dip-&gt;type == <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// a free inode</span><br>      <span class="hljs-built_in">memset</span>(dip, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(*dip));<br>      dip-&gt;type = type;<br>      log_write(bp);   <span class="hljs-comment">// mark it allocated on the disk</span><br>      brelse(bp);<br>      <span class="hljs-keyword">return</span> iget(dev, inum);<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  panic(<span class="hljs-string">&quot;ialloc: no inodes&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>iget</code>在inode cache中查找和传入的device、inode no相同的active entry，如果找到了这个entry就返回对这个inode的一个新的指针，否则找到一个空的entry将其dev、inum等设置为对应的数值，并设置valid为0待后续从block中读取数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">iget</span><span class="hljs-params">(uint dev, uint inum)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">empty</span>;</span><br><br>  acquire(&amp;icache.lock);<br><br>  <span class="hljs-comment">// Is the inode already cached?</span><br>  empty = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(ip = &amp;icache.inode[<span class="hljs-number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;ref &gt; <span class="hljs-number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;<br>      ip-&gt;ref++;<br>      release(&amp;icache.lock);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span> &amp;&amp; ip-&gt;ref == <span class="hljs-number">0</span>)    <span class="hljs-comment">// Remember empty slot.</span><br>      empty = ip;<br>  &#125;<br><br>  <span class="hljs-comment">// Recycle an inode cache entry.</span><br>  <span class="hljs-keyword">if</span>(empty == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;iget: no inodes&quot;</span>);<br><br>  ip = empty;<br>  ip-&gt;dev = dev;<br>  ip-&gt;inum = inum;<br>  ip-&gt;ref = <span class="hljs-number">1</span>;<br>  ip-&gt;valid = <span class="hljs-number">0</span>;<br>  release(&amp;icache.lock);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>bmap()</code>负责获取inode中的第n块data block的地址。当<code>bn&lt;NDIRECT</code>时直接返回<code>ip-&gt;addrs[bn]</code>，如果没有这个地址就调用<code>balloc</code>分配一个data block。当<code>NDIRECT&lt;bn&lt;NINDIRECT</code>时先<code>bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT])</code>，然后获取<code>bp-&gt;data[bn-NDIRECT]</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123;<br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br><br>  panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="6-Directory层"><a href="#6-Directory层" class="headerlink" title="6.Directory层"></a>6.Directory层</h2><p>和文件类似，只不过这个inode结构体类型为T_DIR,数据部分是<code>directory entry</code>,每一个<code>entry</code>数据类型为<code>struct dirent</code>,因为每一个<code>entry</code>仍旧是一个条目，所以还应该包含一个<code>inode number</code>.<br><code>dirlookup</code> 是在directoy中查找名称为<code>name</code>的<code>directoy entry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">dirlookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint *poff)</span><br>&#123;<br>  uint off, inum;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br><br>  <span class="hljs-keyword">if</span>(dp-&gt;type != T_DIR)<br>    panic(<span class="hljs-string">&quot;dirlookup not DIR&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlookup read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span>(namecmp(name, de.name) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// entry matches path element</span><br>      <span class="hljs-keyword">if</span>(poff)<br>        *poff = off;<br>      inum = de.inum;<br>      <span class="hljs-keyword">return</span> iget(dp-&gt;dev, inum);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>readi</code>函数就是在<code>struct inode* ip</code>的文件读取<code>off</code>偏移的内容，这里需要用到<code>bmap</code>函数来打开逻辑块号，再把内容复制到内核空间中或者用户空间(根据<code>user_dst</code>为1或者为0) 中地址为<code>dst</code>的地方去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">readi</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, <span class="hljs-type">int</span> user_dst, uint64 dst, uint off, uint n)</span><br>&#123;<br>  uint tot, m;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span> (off &gt; ip-&gt;size || off + n &lt; off)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (off + n &gt; ip-&gt;size)<br>    n = ip-&gt;size - off;<br><br>  <span class="hljs-keyword">for</span> (tot = <span class="hljs-number">0</span>; tot &lt; n; tot += m, off += m, dst += m)<br>  &#123;<br>    bp = bread(ip-&gt;dev, bmap(ip, off / BSIZE));<br>    m = min(n - tot, BSIZE - off % BSIZE);<br>    <span class="hljs-keyword">if</span> (either_copyout(user_dst, dst, bp-&gt;data + (off % BSIZE), m) == <span class="hljs-number">-1</span>)<br>    &#123;<br>      brelse(bp);<br>      tot = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    brelse(bp);<br>  &#125;<br>  <span class="hljs-keyword">return</span> tot;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>dirlink</code>讲一个新的<code>directory entry</code>写入文件夹<code>dp</code>中，查找<code>dp</code>中尚未分配的<code>entry</code>,如果找到就要用<code>writei</code>在文件中写入内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">dirlink</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dp, <span class="hljs-type">char</span> *name, uint inum)</span><br>&#123;<br>  <span class="hljs-type">int</span> off;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-comment">// Check that name is not present.</span><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Look for an empty dirent.</span><br>  <span class="hljs-keyword">for</span>(off = <span class="hljs-number">0</span>; off &lt; dp-&gt;size; off += <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span>(readi(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>      panic(<span class="hljs-string">&quot;dirlink read&quot;</span>);<br>    <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">strncpy</span>(de.name, name, DIRSIZ);<br>  de.inum = inum;<br>  <span class="hljs-keyword">if</span>(writei(dp, <span class="hljs-number">0</span>, (uint64)&amp;de, off, <span class="hljs-keyword">sizeof</span>(de)) != <span class="hljs-keyword">sizeof</span>(de))<br>    panic(<span class="hljs-string">&quot;dirlink&quot;</span>);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="7-Pathname-层"><a href="#7-Pathname-层" class="headerlink" title="7.Pathname 层"></a>7.Pathname 层</h2><p><code>namei</code>函数对pathname进行解析，返回<code>inode</code>。<code>namei</code>调用了<code>namex</code>函数，<code>namex</code>函数传入参数<code>nameiparent</code>,当为1是返回的<code>inode</code>是传入path的父文件夹。<br>例如，如果path地第一个字符为&#x2F;,则表示这是绝对路径，那么首先需要得到<code>ROOTINO</code>的<code>inode</code>；否则就是相对路径，则要把<code>myproc-&gt;cwd</code>的引用计数加1,<code>proc</code>中的<code>cwd</code>类型是<code>struct inode*</code>。<br>然后不断用<code>skipelem</code>函数解析path中的&#x2F;,不断查找下一级的<code>inode</code>,最后<code>namei</code>返回目标<code>inode</code>。<br>主要内容见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">namex</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> nameiparent, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">next</span>;</span><br><br>  <span class="hljs-keyword">if</span>(*path == <span class="hljs-string">&#x27;/&#x27;</span>)<br>    ip = iget(ROOTDEV, ROOTINO);<br>  <span class="hljs-keyword">else</span><br>    ip = idup(myproc()-&gt;cwd);<br><br>  <span class="hljs-keyword">while</span>((path = skipelem(path, name)) != <span class="hljs-number">0</span>)&#123;<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(ip-&gt;type != T_DIR)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nameiparent &amp;&amp; *path == <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>      <span class="hljs-comment">// Stop one level early.</span><br>      iunlock(ip);<br>      <span class="hljs-keyword">return</span> ip;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((next = dirlookup(ip, name, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)&#123;<br>      iunlockput(ip);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    iunlockput(ip);<br>    ip = next;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(nameiparent)&#123;<br>    iput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="8-File-descriptor层"><a href="#8-File-descriptor层" class="headerlink" title="8.File descriptor层"></a>8.File descriptor层</h2><p>File descriptor层让UNIX中所有的资源，包括设备都可以同一表示为文件。每个打开的文件都可以用<code>struct file</code>来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-type">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-type">char</span> readable;<br>  <span class="hljs-type">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-type">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>open</code>可以增加文件，一个进程打开的文件都保存在结构体<code>proc</code>中的<code>struct file *ofile[NOFILE]</code>数组中。<br>所有打开的文件都保存在global file table，即<code>ftable</code>中。<br><code>filealloc</code>负责在file table中分配一个文件，在<code>ftable</code>中扫描<code>ref==0</code>的file，增加<code>ref</code>后返回这个<code>file *</code>。<br><code>filedup</code>负责对这个file descriptor的<code>ref++</code>并返回这个文件的<code>file *</code>。<br><code>fileclose</code>负责对file descriptor的<code>ref–</code>，当<code>ref==0</code>时根据这个file的类型释放掉<code>pipe</code>或者<code>inode</code>。</p><hr><h2 id="9-相关系统调用"><a href="#9-相关系统调用" class="headerlink" title="9.相关系统调用"></a>9.相关系统调用</h2><p><code>sys_link</code>和<code>sys_unlink</code>这两个系统调用实现对<code>inode</code>的增加或者删除引用。<br><code>sys_link</code>传入一个参数<code>old</code>和一个参数<code>new</code>,<code>new</code>是需要链接到<code>old</code>的路径。<code>sys_link</code>首先增加<code>struct inode* ip</code>的<code>nlink</code>,然后调用<code>nameiparent</code>查找<code>new</code>的父文件夹，调用<code>dirlink</code>在父文件夹中创建一个名为<code>new</code>的<code>directory entry</code>。<br>主要内容见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64<br><span class="hljs-title function_">sys_link</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">char</span> name[DIRSIZ], new[MAXPATH], old[MAXPATH];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">dp</span>, *<span class="hljs-title">ip</span>;</span><br><br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, old, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, new, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br>  <span class="hljs-keyword">if</span>((ip = namei(old)) == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ilock(ip);<br>  <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR)&#123;<br>    iunlockput(ip);<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  ip-&gt;nlink++;<br>  iupdate(ip);<br>  iunlock(ip);<br><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(new, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">goto</span> bad;<br>  ilock(dp);<br>  <span class="hljs-keyword">if</span>(dp-&gt;dev != ip-&gt;dev || dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    <span class="hljs-keyword">goto</span> bad;<br>  &#125;<br>  iunlockput(dp);<br>  iput(ip);<br><br>  end_op();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>bad:<br>  ilock(ip);<br>  ip-&gt;nlink--;<br>  iupdate(ip);<br>  iunlockput(ip);<br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>系统调用<code>open</code>可能会调用<code>create</code>函数。<br><code>create</code>首先调用<code>nameiparent</code>获取父文件夹，然后调用<code>dirlookup</code>来查看这个文件夹下是否已经存在同名的inode，如果存在且调用这个<code>create</code>的是<code>open</code>来创建一个文件的话，那么直接返回这个inode。如果这个名称不存在，则调用ialloc。如果是<code>mkdir</code>调用的<code>create</code>（即<code>type==T_DIR</code>)，则要创建<code>..</code>和<code>.</code>作为对父级inode和当前inode的引用，最终将当前的<code>name</code> <code>dirlink</code>到当前inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> inode*<br><span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">short</span> type, <span class="hljs-type">short</span> major, <span class="hljs-type">short</span> minor)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>, *<span class="hljs-title">dp</span>;</span><br>  <span class="hljs-type">char</span> name[DIRSIZ];<br><br>  <span class="hljs-keyword">if</span>((dp = nameiparent(path, name)) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  ilock(dp);<br><br>  <span class="hljs-keyword">if</span>((ip = dirlookup(dp, name, <span class="hljs-number">0</span>)) != <span class="hljs-number">0</span>)&#123;<br>    iunlockput(dp);<br>    ilock(ip);<br>    <span class="hljs-keyword">if</span>(type == T_FILE &amp;&amp; (ip-&gt;type == T_FILE || ip-&gt;type == T_DEVICE))<br>      <span class="hljs-keyword">return</span> ip;<br>    iunlockput(ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>((ip = ialloc(dp-&gt;dev, type)) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: ialloc&quot;</span>);<br><br>  ilock(ip);<br>  ip-&gt;major = major;<br>  ip-&gt;minor = minor;<br>  ip-&gt;nlink = <span class="hljs-number">1</span>;<br>  iupdate(ip);<br><br>  <span class="hljs-keyword">if</span>(type == T_DIR)&#123;  <span class="hljs-comment">// Create . and .. entries.</span><br>    dp-&gt;nlink++;  <span class="hljs-comment">// for &quot;..&quot;</span><br>    iupdate(dp);<br>    <span class="hljs-comment">// No ip-&gt;nlink++ for &quot;.&quot;: avoid cyclic ref count.</span><br>    <span class="hljs-keyword">if</span>(dirlink(ip, <span class="hljs-string">&quot;.&quot;</span>, ip-&gt;inum) &lt; <span class="hljs-number">0</span> || dirlink(ip, <span class="hljs-string">&quot;..&quot;</span>, dp-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;create dots&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(dirlink(dp, name, ip-&gt;inum) &lt; <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;create: dirlink&quot;</span>);<br><br>  iunlockput(dp);<br><br>  <span class="hljs-keyword">return</span> ip;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中断与设备驱动程序</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p>中断对应的场景很简单，就是硬件想要得到操作系统的关注。<br>操作系统需要做的是，保存当前的工作，处理中断，处理完成之后再恢复之前的工作。这里的保存和恢复工作，与我们之前看到的系统调用过程非常相似。所以系统调用，page fault，中断，都使用相同的机制。</p><ul><li><strong>中断与系统调用的区别</strong></li></ul><ol><li>asynchronous（异步性）：当硬件生成中断时，Interrupt handler与当前运行的进程在CPU上没有任何关联。而系统调用会发生在运行进程的context下。</li><li>concurrency（并发）：CPU和设备之间是真正的并行的。</li><li>program device：设备需要被编程。</li></ol><ul><li><strong>PLIC</strong></li></ul><p>所有的设备都连接到处理器上，处理器上是通过Platform Level Interrupt Control，简称PLIC来处理设备中断。PLIC会路由这些中断,PLIC会将中断路由到某一个CPU的核。如果所有的CPU核都正在处理中断，PLIC会保留中断直到有一个CPU核可以用来处理中断。</p><h2 id="什么是设备驱动"><a href="#什么是设备驱动" class="headerlink" title="什么是设备驱动"></a>什么是设备驱动</h2><p>通常来说，管理设备的代码称为驱动，所有的驱动都在内核中。我们今天要看的是UART设备的驱动，代码在uart.c文件中。</p><blockquote><p>大部分驱动都分为两个部分，bottom 和 top。</p></blockquote><ul><li><p>bottom部分<br>通常是Interrupt handler。中断处理程序并不运行在任何特定进程的上下文  中，它只是处理中断。</p></li><li><p>top部分<br>是用户进程，或者内核的其他部分调用的接口。例如 <code>read</code> 和 <code>write</code></p></li></ul><p>通常情况下，驱动中会有一些队列（或者说buffer），top部分的代码会从队列中读写数据，而Interrupt handler（bottom部分）同时也会向队列中读写数据。这里的队列可以将并行运行的设备和CPU解耦开来。</p><ul><li>memory mapped I&#x2F;O<br>I&#x2F;O设备的寄存器被映射到系统内存地址空间的一段地址范围内，程序可以通过读写内存地址的方式来进行对I&#x2F;O设备的控制和访问。</li></ul><h2 id="在xv6中设置中断"><a href="#在xv6中设置中断" class="headerlink" title="在xv6中设置中断"></a>在xv6中设置中断</h2><h3 id="Console-input"><a href="#Console-input" class="headerlink" title="Console input"></a>Console input</h3><p>当用户输入一个字符后，UART硬件将产生一个中断，这个中断将触发xv6进入trap，随后调用<code>devintr</code>来通过<code>scause</code>寄存器判断是外部设备触发了这个中断，然后硬件将调用PLIC判断是哪个外部设备触发了这个外部中断，如果是UART触发的,<code>devintr</code>将调用<code>uartintr</code>。<code>uartintr</code>将读取从UART硬件中写入的字符然后将其传送给<code>consoleintr</code>，<code>consoleintr</code>将积累这些字符直到整行都已经被读取，然后将唤醒仍在sleep的<code>consoleread</code>。当<code>consoleread</code>被唤醒后，将这一行命令复制给user space然后返回。</p><h3 id="Console-output"><a href="#Console-output" class="headerlink" title="Console output"></a>Console output</h3><p>对console上的文件描述符进行<code>write</code> system call，最终到达kernel&#x2F;uart.c的<code>uartputc</code>函数。输出的字节将缓存在<code>uart_tx_buf</code>中，这样写入进程就不需要等待UART硬件完成字节的发送，只要当这个缓存区满了的情况下<code>uartputc</code>才会等待。当UART完成了一个字符的发送之后，将产生一个中断，<code>uartintr</code>将调用<code>uartstart</code>来判断设备是否确实已经完成发送，然后将下一个需要发送的字符发送给UART。因此让UART传送多个字符时，第一个字符由<code>uartputc</code>对<code>uartstart</code>的调用传送，后面的字符由<code>uartintr</code>对<code>uartstart</code>的调用进行传送。</p><h3 id="UART驱动的top部分"><a href="#UART驱动的top部分" class="headerlink" title="UART驱动的top部分"></a>UART驱动的top部分</h3><p>当XV6启动时，Shell会输出提示符“$ ”，如果我们在键盘上输入ls，最终可以看到“$ ls”。我们接下来通过研究Console是如何显示出“$ ls”，来看一下设备中断是如何工作的。</p><p>首先，系统启动后运行第一个进程init,这个进程会创建一个Console设备。然后再进行两次dup后，文件描述符0,1,2都指向了这个Console设备。随后这个进程会fork，然后子进程进入shell。</p><p>在shell的<code>getcmd</code>函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;$ &quot;</span>);<br></code></pre></td></tr></table></figure><p>执行write系统调用，<code>sys_write</code>函数又会调用file.c中的<code>filewrite</code>函数。<br>这个<code>filewrite</code>函数判断文件的类型，(这里还会用到<code>argfd</code>函数，用一个<code>struct file*</code>的类型获取fd的文件描述符指向的文件)。<br><code>filewrite</code>函数发现这个文件类型是属于一个设备后，就会为这个特定的设备执行相应的<code>write</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">ret = devsw[f-&gt;major].write(<span class="hljs-number">1</span>,addr,n);<br></code></pre></td></tr></table></figure><p>因为设备是Console，所以会调用console.c中的<code>consolewrite</code>函数。</p><blockquote><p>consolewrite是UART驱动的top部分</p></blockquote><p><code>consolewrite</code>会调用<code>uartputc</code>函数，首先把数据存在一个缓冲区里<code>uart_tx_buf</code>中。</p><p>再然后会调用<code>uartstart</code>函数，通知UART设备执行操作。取出数据放入THR发送寄存器。<br>一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。与此同时，UART设备会将数据送出。</p><blockquote><p>UART连接了两个设备，一个是键盘，另一个是显示设备，也就是Console。</p></blockquote><p>然后呢。。。会发生中断。</p><h3 id="UART驱动的bottom部分"><a href="#UART驱动的bottom部分" class="headerlink" title="UART驱动的bottom部分"></a>UART驱动的bottom部分</h3><p>trap.c的<code>devintr</code>函数中，首先会通过<code>SCAUSE</code>寄存器判断当前中断是否是来自于外设的中断。如果是的话，再调用plic_claim函数来获取中断。如果是UART中断，那么会调用<code>uartintr</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">uartintr(<span class="hljs-type">void</span>)&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-type">int</span> c = uartgetc();<br><span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>consoleintr();<br>&#125;<br>acquire(&amp;uart_tx_lock);<br>uartstart();<br>release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们没有在键盘上敲下任何一个键(这里纯粹说一下”$”是如何被处理的)，所以会直接执行uartsatrt函数。</p><ul><li>小疑问：为什么interrupt和write都会调用了uartstart函数？<blockquote><p>首先，如果是write多个字节的话，第一次通过uartputc调用uartstart，把第一个字节发送出去。第一个字节发送完成后，会产生中断，紧接着把余下的字节都发送出去。<br>A general pattern to note is the decoupling of device activity from process activity via buffering and interrupts.</p></blockquote></li></ul><blockquote><p>Interrupt handler，也就是uartintr函数，在这个场景下是consumer，每当有一个中断，并且读指针落后于写指针，uartintr函数就会从读指针中读取一个字符再通过UART设备发送，并且将读指针加1。当读指针追上写指针，也就是两个指针相等的时候，buffer为空，这时就不用做任何操作。</p></blockquote><h3 id="UART读取键盘输入"><a href="#UART读取键盘输入" class="headerlink" title="UART读取键盘输入"></a>UART读取键盘输入</h3><p>类似的，shell会调用<code>read</code>从键盘读取字符。再会调用<code>fileread</code>函数，如果文件类型是设备，在这里是<code>console</code>设备，所以会调用<code>consoleread</code>函数。这里也有一个Buffer。<br>大体流程如下：<br>假设用户通过键盘输入了“l”，这会导致“l”被发送到主板上的UART芯片，产生中断之后再被PLIC路由到某个CPU核，之后会触发<code>devintr</code>函数，<code>devintr</code>可以发现这是一个UART中断，然后通过<code>uartgetc</code>函数获取到相应的字符，之后再将字符传递给<code>consoleintr</code>函数。<br>默认情况下，字符会通过<code>consputc</code>，输出到console上给用户查看。之后，字符被存放在buffer中。在遇到换行符的时候，唤醒之前sleep的进程，也就是Shell，再从buffer中将数据读出。<br>所以这里也是通过buffer将consumer和producer之间解耦，这样它们才能按照自己的速度，独立的并行运行。如果某一个运行的过快了，那么buffer要么是满的要么是空的，consumer和producer其中一个会sleep并等待另一个追上来。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sleep&amp;&amp;Wakeup</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/sleep&amp;wakeup/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/sleep&amp;wakeup/</url>
    
    <content type="html"><![CDATA[<h2 id="Sleep-wakeup"><a href="#Sleep-wakeup" class="headerlink" title="Sleep &amp; wakeup"></a>Sleep &amp; wakeup</h2><p><code>sleep</code>是当一个进程在等待某一个事件时陷入休眠状态，当这个事件发生时另外一个进程唤醒它。陷入休眠状态可以让这个进程不在等待的时候占用CPU资源</p><p><code>sleep(chan)</code>让这个进程睡眠在<code>chan</code>这个wait channel上，<code>wakeup(chan)</code>将所有睡眠在<code>chan</code>上的进程全部唤醒。</p><p>lost wake-up problem：当一个进程A即将睡眠时，另外一个进程B发现已经满足了唤醒它的条件进行了唤醒，但是这时还没有进程睡眠在<code>chan</code>上，当进程A开始进入睡眠后，进程B可能不会再对进程A进行唤醒，进程A永远进入睡眠状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan, <span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  acquire(&amp;p-&gt;lock);  <span class="hljs-comment">//DOC: sleeplock1</span><br>  release(lk);<br><br>  <span class="hljs-comment">// Go to sleep.</span><br>  p-&gt;chan = chan;<br>  p-&gt;state = SLEEPING;<br><br>  sched();<br><br>  <span class="hljs-comment">// Tidy up.</span><br>  p-&gt;chan = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// Reacquire original lock.</span><br>  release(&amp;p-&gt;lock);<br>  acquire(lk);<br>&#125;<br><br><span class="hljs-comment">// Wake up all processes sleeping on chan.</span><br><span class="hljs-comment">// Must be called without any p-&gt;lock.</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span> *chan)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    <span class="hljs-keyword">if</span>(p != myproc())&#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;<br>        p-&gt;state = RUNNABLE;<br>       &#125;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>sleep</code>函数调用前，首先要获取<code>lk</code>这把锁，这把锁是用来保护访问的共享资源的。<code>sleep</code>最后调用<code>acquire(lk)</code>也是为了在进程需要被唤醒时，能够安全地访问之前释放的共享资源。</p><p>下面直接看<code>sleep</code>和<code>wakeup</code>运用的场景。</p><h2 id="Code-Pipes"><a href="#Code-Pipes" class="headerlink" title="Code: Pipes"></a>Code: Pipes</h2><p>每一个<code>pipe</code>都有一个<code>struct pipe</code>，包括了一个<code>lock</code>和一个<code>data</code>缓冲数组。此外，还有一个读和一个写的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">char</span> data[PIPESIZE];<br>  uint nread;     <span class="hljs-comment">// number of bytes read</span><br>  uint nwrite;    <span class="hljs-comment">// number of bytes written</span><br>  <span class="hljs-type">int</span> readopen;   <span class="hljs-comment">// read fd is still open</span><br>  <span class="hljs-type">int</span> writeopen;  <span class="hljs-comment">// write fd is still open</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>pipewrite()</code>往管道中写入n个字节。</p><p>首先需要获取<code>pipe</code>的锁，这是为了保护<code>pi</code>结构体里面的共享资源。<br>通过<code>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE</code>判断缓冲区是否已经满了，如果已经满了就唤醒睡在<code>&amp;pi-&gt;nread</code>上的<code>piperead</code>进程对缓冲区进行读取，自己睡在<code>&amp;pi-&gt;nwrite</code>等待唤醒，否则就从user space的<code>addr</code>中<code>copyin</code>到内核态中的<code>pi</code>缓冲区内，完成n字节的读取之后将<code>piperead</code>进程唤醒，释放<code>&amp;pi-&gt;lock</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">pipewrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">while</span>(i &lt; n)&#123;<br>    <span class="hljs-keyword">if</span>(pi-&gt;readopen == <span class="hljs-number">0</span> || pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi-&gt;nwrite == pi-&gt;nread + PIPESIZE)&#123; <span class="hljs-comment">//DOC: pipewrite-full</span><br>      wakeup(&amp;pi-&gt;nread);<br>      sleep(&amp;pi-&gt;nwrite, &amp;pi-&gt;lock);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">char</span> ch;<br>      <span class="hljs-keyword">if</span>(copyin(pr-&gt;pagetable, &amp;ch, addr + i, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">break</span>;<br>      pi-&gt;data[pi-&gt;nwrite++ % PIPESIZE] = ch;<br>      i++;<br>    &#125;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nread);<br>  release(&amp;pi-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>piperead</code>从管道中读取n个字节。</p><p>也要先获取<code>pi-&gt;lock</code>，判断当前缓冲区内是不是空的，如果是空的就进入睡眠，等待<code>pipewrite</code>进行写入并唤醒，否则循环读取n字节缓冲区数据，将缓冲区的数据<code>copyout</code>到用户空间的<code>addr</code>地址中，待n字节数据全部读取完成之后将<code>pipewrite</code>唤醒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">piperead</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pipe *pi, uint64 addr, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">pr</span> =</span> myproc();<br>  <span class="hljs-type">char</span> ch;<br><br>  acquire(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">while</span>(pi-&gt;nread == pi-&gt;nwrite &amp;&amp; pi-&gt;writeopen)&#123;  <span class="hljs-comment">//DOC: pipe-empty</span><br>    <span class="hljs-keyword">if</span>(pr-&gt;killed)&#123;<br>      release(&amp;pi-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sleep(&amp;pi-&gt;nread, &amp;pi-&gt;lock); <span class="hljs-comment">//DOC: piperead-sleep</span><br>  &#125;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;  <span class="hljs-comment">//DOC: piperead-copy</span><br>    <span class="hljs-keyword">if</span>(pi-&gt;nread == pi-&gt;nwrite)<br>      <span class="hljs-keyword">break</span>;<br>    ch = pi-&gt;data[pi-&gt;nread++ % PIPESIZE];<br>    <span class="hljs-keyword">if</span>(copyout(pr-&gt;pagetable, addr + i, &amp;ch, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  wakeup(&amp;pi-&gt;nwrite);  <span class="hljs-comment">//DOC: piperead-wakeup</span><br>  release(&amp;pi-&gt;lock);<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Code-wait-exit"><a href="#Code-wait-exit" class="headerlink" title="Code: wait &amp; exit"></a>Code: wait &amp; exit</h2><h3 id="wait代码实现"><a href="#wait代码实现" class="headerlink" title="wait代码实现"></a>wait代码实现</h3><p><code>wait</code>中是一个无限循环，每个循环中先对所有的进程循环查找自己的子进程，当发现有子进程并且子进程的状态为<code>ZOMBIE</code>时，将子进程的退出状态<code>np-&gt;xstate</code> <code>copyout</code>到<code>wait</code>传入的用户空间的<code>addr</code>中，然后释放掉子进程占用的所有的内存空间，返回子进程的pid。如果没有发现任何<code>ZOMBIE</code>子进程，睡眠在<code>p</code>上以等待子进程<code>exit</code>时唤醒<code>p</code>。</p><blockquote><p>exit函数会调用wakeup(p-&gt;parent)唤醒父进程。</p></blockquote><p><strong>注意</strong>：<br><code>wait()</code>先要获取调用进程的<code>p-&gt;lock</code>作为<code>sleep</code>的condition lock，然后在发现<code>ZOMBIE</code>子进程后获取子进程的<code>np-&gt;lock</code>，因此xv6中必须遵守先获取父进程的锁才能获取子进程的锁这一个规则。因此在循环查找<code>np-&gt;parent == p</code>时，不能先获取<code>np-&gt;lock</code>，因为<code>np</code>很有可能是自己的父进程，这样就违背了先获取父进程锁再获取子进程锁这个规则，可能造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">wait</span><span class="hljs-params">(uint64 addr)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-type">int</span> havekids, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">// Scan through table looking for exited children.</span><br>    havekids = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;<br>      <span class="hljs-keyword">if</span>(np-&gt;parent == p)&#123;<br>        <span class="hljs-comment">// make sure the child isn&#x27;t still in exit() or swtch().</span><br>        acquire(&amp;np-&gt;lock);<br><br>        havekids = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(np-&gt;state == ZOMBIE)&#123;<br>          <span class="hljs-comment">// Found one.</span><br>          pid = np-&gt;pid;<br>          <span class="hljs-keyword">if</span>(addr != <span class="hljs-number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;np-&gt;xstate,<br>                                  <span class="hljs-keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="hljs-number">0</span>) &#123;<br>            release(&amp;np-&gt;lock);<br>            release(&amp;wait_lock);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>          &#125;<br>          freeproc(np);<br>          release(&amp;np-&gt;lock);<br>          release(&amp;wait_lock);<br>          <span class="hljs-keyword">return</span> pid;<br>        &#125;<br>        release(&amp;np-&gt;lock);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// No point waiting if we don&#x27;t have any children.</span><br>    <span class="hljs-keyword">if</span>(!havekids || p-&gt;killed)&#123;<br>      release(&amp;wait_lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Wait for a child to exit.</span><br>    sleep(p, &amp;wait_lock);  <span class="hljs-comment">//DOC: wait-sleep</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exit代码实现"><a href="#exit代码实现" class="headerlink" title="exit代码实现"></a>exit代码实现</h3><p><code>exit</code>关闭所有打开的文件，将自己的子进程reparent给<code>init</code>进程，因为<code>init</code>进程永远在调用<code>wait</code>，这样就可以让自己的子进程在<code>exit</code>后由<code>init</code>进行<code>freeproc</code>等后续的操作。然后获取进程锁，设置退出状态和当前状态为<code>ZOMBIE</code>，进入<code>scheduler</code>中并且不再返回。</p><p>注意：在将<code>p-&gt;state</code>设置为<code>ZOMBIE</code>之后才能释放掉<code>wait_lock</code>，否则<code>wait()</code>的进程被唤醒之后发现了<code>ZOMBIE</code>进程之后直接将其释放，此时<code>ZOMBIE</code>进程还没运行完毕。</p><p><code>exit</code>是让自己的程序进行退出，<code>kill</code>是让一个程序强制要求另一个程序退出。<code>kill</code>不能立刻终结另一个进程，因为另一个进程可能在执行敏感命令，因此kill仅仅设置了<code>p-&gt;killed</code>为1，且如果该进程在睡眠状态则将其唤醒。当被<code>kill</code>的进程进入<code>usertrap</code>之后，将会查看<code>p-&gt;killed</code>是否为1，如果为1则将调用<code>exit</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  begin_op();<br>  iput(p-&gt;cwd);<br>  end_op();<br>  p-&gt;cwd = <span class="hljs-number">0</span>;<br><br>  acquire(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Give any children to init.</span><br>  reparent(p);<br><br>  <span class="hljs-comment">// Parent might be sleeping in wait().</span><br>  wakeup(p-&gt;parent);<br>  <br>  acquire(&amp;p-&gt;lock);<br><br>  p-&gt;xstate = status;<br>  p-&gt;state = ZOMBIE;<br><br>  release(&amp;wait_lock);<br><br>  <span class="hljs-comment">// Jump into the scheduler, never to return.</span><br>  sched();<br>  panic(<span class="hljs-string">&quot;zombie exit&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab9:File System</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab9%20file%20system/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab9%20file%20system/</url>
    
    <content type="html"><![CDATA[<h2 id="Large-Files"><a href="#Large-Files" class="headerlink" title="Large Files"></a><strong>Large Files</strong></h2><p>我们知道，在我们现在的xv6文件系统设计中，每一个文件最大只能有268*BSIZE(12 + 256)，一个文件(inode)有12个direct block，还有1个singlely-indirect block。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">uint addrs[NDIRECT+<span class="hljs-number">1</span>];    <span class="hljs-comment">// struct inode</span><br></code></pre></td></tr></table></figure><p>这里，我们将为文件进行扩容，添加一个doubly-indirect的block，现在<code>addrs</code> 数组仍旧有NDIRECT+1(13个)，我们现在9个direct block,1个singlely-indirect block,1个doubly-indirect block，所以现在文件的最大大小为：(11+256+256*256 ) * BSIZE。</p><p>下面我们看代码实现：</p><ol><li>更改<code>inode</code> 和<code>dinode</code> 结构体。</li><li>修改<code>bmap(struct inode* ip, uint bn)</code> 函数 (这个函数就是获取 inode 中第 bn 个块的块号，如果没有就获取1个Block并返回块号) 和<code>itrunc(struct inode* ip)</code> 函数(这个函数释放inode的所有的数据块)</li></ol><p>先来看<code>bmap</code> ，首先前面的逻辑并不需要更改，这里就是判断<code>bn</code> 是否落在direct block，还是落在singly-indirect block。从singly-indirect block开始，就要把indirect block读取进内存，然后再以<code>uint</code> 数组形式进行访问，具体细节见代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span><br>&#123;<br>  uint addr, *a;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>  <span class="hljs-keyword">if</span>(bn &lt; NDIRECT)&#123;<br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NDIRECT;<br><br>  <span class="hljs-keyword">if</span>(bn &lt; NINDIRECT)&#123; <span class="hljs-comment">// singly-indirect</span><br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br>  bn -= NINDIRECT；<br></code></pre></td></tr></table></figure><p>接下来就是我们需要实现的部分了，其实也比较简单：</p><ol><li>如果doubly-indirect block不存在，就先分配一个block并读取这个block。</li><li>我们要判断<code>bn</code> 在doubly-indirect block的位置，我们知道，在doubly-indirect block中每一项都是一个singly-indirect block的位置，也就是我们需要先判断<code>a[bn/NINDIRECT]</code> 是否存在，如果不存在，我们先要分配，并打开这个下一层级的block。</li><li>然后<code>bn %= NINDIRECT</code> 就是<code>bn</code> 在<code>singly-indirect block</code> 的位置了。如果不存在就分配，并返回这个block number。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(bn &lt; NINDIRECT * NINDIRECT) &#123; <span class="hljs-comment">// doubly-indirect</span><br>    <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>    <span class="hljs-keyword">if</span>((addr = ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)<br>      ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>] = addr = balloc(ip-&gt;dev);<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn/NINDIRECT]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn/NINDIRECT] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    bn %= NINDIRECT;<br>    bp = bread(ip-&gt;dev, addr);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">if</span>((addr = a[bn]) == <span class="hljs-number">0</span>)&#123;<br>      a[bn] = addr = balloc(ip-&gt;dev);<br>      log_write(bp);<br>    &#125;<br>    brelse(bp);<br>    <span class="hljs-keyword">return</span> addr;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>itrunc</code> 函数也就比较简单了，就是不断调用<code>bfree(int dev, uint b)</code> 函数是否每一个文件占用的块。这里就不展开讲了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">itrunc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, j;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br>  uint *a;<br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++)&#123;<br>    <span class="hljs-keyword">if</span>(ip-&gt;addrs[i])&#123;<br>      bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>      ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j])<br>        bfree(ip-&gt;dev, a[j]);<br>    &#125;<br>    brelse(bp);<br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>    ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>])&#123;<br>    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>]);<br>    a = (uint*)bp-&gt;data;<br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++)&#123;<br>      <span class="hljs-keyword">if</span>(a[j]) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp2</span> =</span> bread(ip-&gt;dev, a[j]);<br>        uint *a2 = (uint*)bp2-&gt;data;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; NINDIRECT; k++)&#123;<br>          <span class="hljs-keyword">if</span>(a2[k])<br>            bfree(ip-&gt;dev, a2[k]);<br>        &#125;<br>        brelse(bp2);<br>        bfree(ip-&gt;dev, a[j]);<br>      &#125;<br>    &#125;<br>    brelse(bp);<br>    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+<span class="hljs-number">1</span>]);<br>    ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  ip-&gt;size = <span class="hljs-number">0</span>;<br>  iupdate(ip);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a><strong>Symbolic links</strong></h2><p>首先区分一下什么是硬链接和软链接。</p><ul><li>硬链接：原文件和链接文件共用一个 <code>inode</code>号，指向同一块磁盘区域。</li><li>软链接：原文件和链接文件拥有不同的 <code>inode</code>号，这是两个不同的文件。它包含了指向另一个文件的路径。软链接相当于一个指针，指向另一个文件或目录。</li></ul><p>那么在这个实验中，实现软链接应该新建一个<code>inode</code>，然后再这个<code>inode</code>中填写原文件的地址，如果找出的内容仍然是一个软链接，则继续递归查找。这里要修改<code>sys_open</code> 系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// creates a new symbolic link at path that refers to file named by target</span><br>symlink(<span class="hljs-type">char</span> *target, <span class="hljs-type">char</span> *path)<br></code></pre></td></tr></table></figure><p>我们先来看<code>sys_symlink</code> 系统调用的实现，这个实现比较简单，就是新创建一个文件<code>ip = create(path, T_SYMLINK, 0, 0);</code> 文件类型为软链接，接下来再用<code>writei</code> 函数把<code>target</code> 文件的路径写入inode文件中。</p><blockquote><p><code>int writei(struct inode ip, int user_src, uint64 src, uint off, uint n)</code>  这里<code>user_src</code> 表示是从用户空间地址中写还是从内核空间中写入。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_symlink</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span><br>  <span class="hljs-type">char</span> target[MAXPATH], path[MAXPATH];<br>  <span class="hljs-keyword">if</span>(argstr(<span class="hljs-number">0</span>, target, MAXPATH) &lt; <span class="hljs-number">0</span> || argstr(<span class="hljs-number">1</span>, path, MAXPATH) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  begin_op();<br><br>  ip = create(path, T_SYMLINK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// use the first data block to store target path.</span><br>  <span class="hljs-keyword">if</span>(writei(ip, <span class="hljs-number">0</span>, (uint64)target, <span class="hljs-number">0</span>, <span class="hljs-built_in">strlen</span>(target)) &lt; <span class="hljs-number">0</span>) &#123;<br>    end_op();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  iunlockput(ip);<br><br>  end_op();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>再完成<code>sys_symlink</code> 系统调用后，再来对<code>sys_open</code> 函数进行修改。</p><p>根据实验的提示，我们需要一个<code>O_NOFOLLOW</code> 的标志，在打开软链接文件的时候，是想得到这个软链接文件的真实内容，还是这个软链接文件所指向的文件。</p><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(omode &amp; O_CREATE)&#123;<br>    ip = create(path, T_FILE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ip == <span class="hljs-number">0</span>)&#123;<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">int</span> symlink_depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// recursively follow symlinks</span><br>      <span class="hljs-keyword">if</span>((ip = namei(path)) == <span class="hljs-number">0</span>)&#123;<br>        end_op();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      ilock(ip);<br>      <span class="hljs-keyword">if</span>(ip-&gt;type == T_SYMLINK &amp;&amp; (omode &amp; O_NOFOLLOW) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(++symlink_depth &gt; <span class="hljs-number">10</span>) &#123;<br>          <span class="hljs-comment">// too many layer of symlinks, might be a loop</span><br>          iunlockput(ip);<br>          end_op();<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(readi(ip, <span class="hljs-number">0</span>, (uint64)path, <span class="hljs-number">0</span>, MAXPATH) &lt; <span class="hljs-number">0</span>) &#123;<br>          iunlockput(ip);<br>          end_op();<br>          <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        iunlockput(ip);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;<br>      iunlockput(ip);<br>      end_op();<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab6:Thread</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab6%20thread/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab6%20thread/</url>
    
    <content type="html"><![CDATA[<h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>题目概述：补充代码展现线程调换的机制。代码在文件user&#x2F;uthread.c 和 user&#x2F;uthread_switch.S中。主要内容见课程主页。</p><ol><li>首先需要在thread结构体中添加一个user_context保存上下文。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_context</span>&#123;</span><br>  uint64 ra;<br>  uint64 sp;<br><br>  <span class="hljs-comment">// callee-saved</span><br>  uint64 s0;<br>  uint64 s1;<br>  uint64 s2;<br>  uint64 s3;<br>  uint64 s4;<br>  uint64 s5;<br>  uint64 s6;<br>  uint64 s7;<br>  uint64 s8;<br>  uint64 s9;<br>  uint64 s10;<br>  uint64 s11;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STACK_SIZE]; <span class="hljs-comment">/* the thread&#x27;s stack */</span><br>  <span class="hljs-type">int</span> state;              <span class="hljs-comment">/* FREE, RUNNING, RUNNABLE */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_context</span> <span class="hljs-title">ctx</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>在thread_create函数中添加初始化，把返回地址指向线程第一条指令的地址，同时还需要把栈指针指向线程自己的栈空间。这样当执行thread_schedule函数进行thread_switch时，会把被调度的新线程保存在thread结构体中的user_context.ra正确地填入到ra寄存器重中，<strong>就好像是被调度的新线程调用了这个thread_switch函数而返回</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thread_create</span><span class="hljs-params">(<span class="hljs-type">void</span> (*func)())</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span>;</span><br><br>  <span class="hljs-keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (t-&gt;state == FREE)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  t-&gt;state = RUNNABLE;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  t-&gt;ctx.ra = (uint64)func;<br>  t-&gt;ctx.sp = (uint64)(t-&gt;<span class="hljs-built_in">stack</span> + STACK_SIZE - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>随后在thread_schedule函数中添加thread_switch(?,?)函数。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">thread_schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread</span> *<span class="hljs-title">t</span>, *<span class="hljs-title">next_thread</span>;</span><br><br>  <span class="hljs-comment">/* Find another runnable thread. */</span><br>  next_thread = <span class="hljs-number">0</span>;<br>  t = current_thread + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_THREAD; i++)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (t &gt;= all_thread + MAX_THREAD)<br>      t = all_thread;<br>    <span class="hljs-keyword">if</span> (t-&gt;state == RUNNABLE)<br>    &#123;<br>      next_thread = t;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    t = t + <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (next_thread == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread_schedule: no runnable threads\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (current_thread != next_thread)<br>  &#123; <span class="hljs-comment">/* switch threads?  */</span><br>    next_thread-&gt;state = RUNNING;<br>    t = current_thread;<br>    current_thread = next_thread;<br>    <span class="hljs-comment">/* YOUR CODE HERE</span><br><span class="hljs-comment">     * Invoke thread_switch to switch from t to next_thread:</span><br><span class="hljs-comment">     * thread_switch(??, ??);</span><br><span class="hljs-comment">     */</span><br>    thread_switch((uint64)&amp;t-&gt;ctx, (uint64)&amp;next_thread-&gt;ctx);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>    next_thread = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><p>比较容易，为每一个bucket加一把锁，在put的时候上锁,修改完后释放锁即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> lock_bucket[NBUCKET];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">initial_locks</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++)<br>  &#123;<br>    pthread_mutex_init(&amp;lock_bucket[i], <span class="hljs-literal">NULL</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br><br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br><br>  pthread_mutex_lock(&amp;lock_bucket[i]);<br><br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (e)<br>  &#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    insert(key, value, &amp;table[i], table[i]);<br>  &#125;<br><br>  pthread_mutex_unlock(&amp;lock_bucket[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>只需要在barrier函数中添加代码即可。<br>首先需要知道pthread_cond_wait和pthread_cond_broadcast函数的语义。</p><blockquote><p>pthread_cond_wait: 等待条件变量的信号。当调用线程执行到 pthread_cond_wait 时，它会原子地<strong>释放传入的互斥锁 mutex</strong>，并进入<strong>阻塞状态</strong>，<strong>直到接收到条件变量 cond 的信号</strong><br>pthread_cond_broadcast:发送广播信号给<strong>等待在条件变量 cond 上的所有线程</strong>。这会唤醒所有等待的线程，使它们从 <strong>pthread_cond_wait 函数返回</strong>，并重新<strong>获取 mutex</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>  pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>  bstate.nthread++;<br>  <span class="hljs-keyword">if</span> (bstate.nthread == nthread)<br>  &#123;<br>    pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>    bstate.nthread = <span class="hljs-number">0</span>;<br>    bstate.round++;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>  &#125;<br>  pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab8:Lock</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab8%20lock/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab8%20lock/</url>
    
    <content type="html"><![CDATA[<h2 id="Lock-Lab"><a href="#Lock-Lab" class="headerlink" title="Lock Lab"></a><strong>Lock Lab</strong></h2><h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a><strong>Memory allocator</strong></h2><p>操作系统把物理内存组织成一个链表，每个CPU获取物理内存时都需要在这个链表中进行获取，这样当多个CPU获取时就要通过锁保护好这个链表，而在这个实验中，我们需要为每一个CPU都分配一个物理内存的链表，这样就可以降低<code>kalloc</code>实现中锁的竞争。</p><p>但存在这样一种情况，某一个CPU中<code>kalloc</code>过多导致它自己的链表中空闲的物理页面已经不足了，这就需要它从其他CPU的链表中去“偷”物理页面。</p><p>我们来看代码实现，首先是设置好链表并初始化锁，随后调用<code>freerange</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem[NCPU];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">kinit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  initlock(&amp;kmem.lock, &quot;kmem&quot;);</span><br><span class="hljs-comment">  freerange(end, (void *)PHYSTOP);</span><br><span class="hljs-comment">  */</span><br>  initlock(&amp;kmem[<span class="hljs-number">0</span>].lock, <span class="hljs-string">&quot;kmem0&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">1</span>].lock, <span class="hljs-string">&quot;kmem1&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">2</span>].lock, <span class="hljs-string">&quot;kmem2&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">3</span>].lock, <span class="hljs-string">&quot;kmem3&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">4</span>].lock, <span class="hljs-string">&quot;kmem4&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">5</span>].lock, <span class="hljs-string">&quot;kmem5&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">6</span>].lock, <span class="hljs-string">&quot;kmem6&quot;</span>);<br>  initlock(&amp;kmem[<span class="hljs-number">7</span>].lock, <span class="hljs-string">&quot;kmem7&quot;</span>);<br><br>  freerange(end, (<span class="hljs-type">void</span> *)PHYSTOP);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span> *)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span> (; p + PGSIZE &lt;= (<span class="hljs-type">char</span> *)pa_end; p += PGSIZE)<br>  &#123;<br>    kfree(p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看<code>kfree</code>函数的实现，这个实现非常简单，就是得到当前的CPU号，再把<code>pa</code>插入到free list链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-type">int</span> cpu_id = cpuid();<br><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run *)pa;<br><br>  acquire(&amp;kmem[cpu_id].lock);<br>  r-&gt;next = kmem[cpu_id].freelist;<br>  kmem[cpu_id].freelist = r;<br>  release(&amp;kmem[cpu_id].lock);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>kalloc</code>函数也比较简单，大致流程就是判断当前CPU的链表中有没有空闲的页，如果没有，就要尝试获取其他CPU的free list链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-type">int</span> cpu_id = cpuid();<br><br>  acquire(&amp;kmem[cpu_id].lock);<br>  r = kmem[cpu_id].freelist;<br>  <span class="hljs-keyword">if</span> (r)<br>    kmem[cpu_id].freelist = r-&gt;next;<br>  <span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++)&#123;<br>      <span class="hljs-keyword">if</span> (i == cpu_id)<br>        <span class="hljs-keyword">continue</span>;<br>      <span class="hljs-keyword">if</span> (kmem[i].freelist == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>      acquire(&amp;kmem[i].lock);<br><br>      r = kmem[i].freelist;<br>      <span class="hljs-keyword">if</span> (r)&#123;<br>        <span class="hljs-comment">// 可分配</span><br>        kmem[i].freelist = r-&gt;next;<br>        release(&amp;kmem[i].lock);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>        release(&amp;kmem[i].lock);<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  release(&amp;kmem[cpu_id].lock);<br><br>  <span class="hljs-keyword">if</span> (r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Buffer-Cache"><a href="#Buffer-Cache" class="headerlink" title="Buffer Cache"></a><strong>Buffer Cache</strong></h2><ul><li>这个lab要解决的问题是什么</li></ul><p>我们先来看<code>struct buf* bread(uint dev, uint blockno)</code>函数，这个函数的任务就是从磁盘中获取<code>blockno</code>这个块，并把内容复制到<code>buf</code>缓冲区中，并返回这个<code>buf</code>指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf* <span class="hljs-title function_">bread</span><span class="hljs-params">(uint dev, uint blockno)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>  b = bget(dev, blockno);<br>  <span class="hljs-keyword">if</span>(!b-&gt;valid) &#123;<br>    virtio_disk_rw(b, <span class="hljs-number">0</span>);<br>    b-&gt;valid = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数首先调用<code>bget</code>函数从<code>bcache</code>缓存中获取一个<code>buf</code>，然后再调用<code>virtio_disk_rw</code>函数把磁盘上的内容搬运到内存上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br><br>  <span class="hljs-comment">// Linked list of all buffers, through prev/next.</span><br>  <span class="hljs-comment">// Sorted by how recently the buffer was used.</span><br>  <span class="hljs-comment">// head.next is most recent, head.prev is least.</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">head</span>;</span><br>&#125; bcache;<br><br></code></pre></td></tr></table></figure><p>那么这就有一个性能瓶颈了，当多进程同时需要或许<code>bcache</code>缓存时，都会先对<code>bcache</code>上锁<code>bcache.lock</code>，锁住整个<code>bcache</code>，这样锁的粒度就太大，多个进程不能同时(申请、释放)磁盘缓存。</p><ul><li>解决思路</li></ul><p>我们可以采用哈希表的思想，建立一个从<code>blockno</code>到<code>buf</code>的哈希表，并为每个桶单独加锁。并且如果一个桶的<code>buf</code>已经用完了的时候，它还能从别的桶中偷。原来的<code>bcache</code>结构体中的<code>head</code>头就需要桶的个数个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBUCKET 13</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_FUNCTION(X) (X % NBUCKET)</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>  <span class="hljs-comment">// struct spinlock lock;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">buf</span>[<span class="hljs-title">NBUF</span>];</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">hash_buf</span>[<span class="hljs-title">NBUCKET</span>];</span>   <span class="hljs-comment">// head</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">hash_lock</span>[<span class="hljs-title">NBUCKET</span>];</span><br>&#125; bcache;<br></code></pre></td></tr></table></figure><p>我们初始化的时候，把所有的<code>buf</code>先都挂在第一个桶上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">binit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>  <span class="hljs-comment">// initlock(&amp;bcache.lock, &quot;bcache&quot;);</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++)&#123;<br>    initlock(&amp;bcache.hash_lock[i], <span class="hljs-string">&quot;hash_cache&quot;</span>);<br>    bcache.hash_buf[i].next = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUF; i++)&#123;<br>    b = &amp;bcache.buf[i];<br>    initsleeplock(&amp;b-&gt;lock, <span class="hljs-string">&quot;buffer&quot;</span>);<br>    b-&gt;last_used = <span class="hljs-number">0</span>;<br>    b-&gt;refcnt = <span class="hljs-number">0</span>;<br>    b-&gt;next = bcache.hash_buf[<span class="hljs-number">0</span>].next;<br>    bcache.hash_buf[<span class="hljs-number">0</span>].next = b;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实验文档里面，还提到了using <code>ticks</code> in kernel&#x2F;trap.c，并使用LRU算法。我没看到每一次发生时钟中断的时候都会把时间戳加1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">clockintr</span><span class="hljs-params">()</span>&#123;<br>  acquire(&amp;tickslock);<br>  ticks++;<br>  wakeup(&amp;ticks);<br>  release(&amp;tickslock);<br>&#125;<br></code></pre></td></tr></table></figure><p>实验中还要求<code>begt</code>函数要select the least-recently used block based on the time-stamps。也就是说每一次<code>bget</code>某一个<code>blockno</code>，先要在当前的<code>Hash(blockno)</code>的桶中寻找是否存在该缓存目标，如果不存在，就要在全局的<code>buf</code>中利用LRU算法找到相应的<code>buf</code>。这里容易产生死锁问题。</p><blockquote><p>这里需要为<code>struct buf</code>添加一个字段<code>last_use</code>，什么时候设置这个字段呢，当然是释放某个<code>buf</code>的时候，当这个<code>buf</code>的引用计数为0，就可以把<code>buf</code>的<code>last_use</code>设置为当前的<code>ticks</code>了。</p></blockquote><p>我们先来看<code>bget</code>函数。首先就是判断桶中是否已有了缓存，有了的话直接返回就行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">bget</span><span class="hljs-params">(uint dev, uint blockno)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br><br>  <span class="hljs-type">int</span> key = HASH_FUNCTION(blockno);<br>  acquire(&amp;bcache.hash_lock[key]);<br><br>  <span class="hljs-comment">// Is the block already cached?</span><br>  <span class="hljs-keyword">for</span> (b = bcache.hash_buf[key].next; b; b = b-&gt;next)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)<br>    &#123;<br>      b-&gt;refcnt++;<br>      release(&amp;bcache.hash_lock[key]);<br>      acquiresleep(&amp;b-&gt;lock);<br>      <span class="hljs-keyword">return</span> b;<br>    &#125;<br>  &#125;<br>  release(&amp;bcache.hash_lock[key]);<br></code></pre></td></tr></table></figure><p>接下来就要调用函数<code>find_lru</code>了，这个函数会根据<code>last_use</code>寻找使用哪一个<code>buf</code>，以及找到后，它会设置<code>id_ret</code>表示这个<code>buf</code>当前在哪一个桶的管理下。当这个函数返回时，是必须要获取<code>bcache.hash_lock[id_ret]</code>这把锁的，原因也很明显，就是为了避免发生数据不一致。同时<code>bret</code>指针就是指向<code>buf</code>数组里的某个<code>struct buf</code>了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> id_ret = <span class="hljs-number">-1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b_ret</span> =</span> find_lru(&amp;id_ret);<br><br><span class="hljs-keyword">if</span> (b_ret == <span class="hljs-number">0</span> || id_ret == <span class="hljs-number">-1</span>)&#123;<br>  panic(<span class="hljs-string">&quot;bget: no buffers&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 设置 b_ret,如果不存在bcache.hash_buf[id]数组中,要新加一个引用</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">lru</span> =</span> b_ret-&gt;next;<br>b_ret-&gt;next = lru-&gt;next;<br><br><span class="hljs-comment">// 可以释放 bcache.hash_buf[id_ret]的锁了，因为已经把这个 buf 给删除了</span><br>release(&amp;bcache.hash_lock[id_ret]);<br></code></pre></td></tr></table></figure><p>随后，就是把“偷”来的<code>buf</code>添加当前的桶里面去。<strong>这里再次判断了是当前<code>blockno</code>是否存在于桶的链表中</strong>，就是为了避免这样一种可能，在执行<code>find_lru</code>函数的时候，其他别的进程获取了当前桶的锁，进而把这个相同的<code>blockno</code>插入进了当前桶的链表中。等到当前进程从<code>find_lru</code>返回时，它重新获取了当前桶的锁，它并不知道在它释放锁到获取锁之间发生了什么事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire(&amp;bcache.hash_lock[key]);<br><br> <span class="hljs-keyword">for</span> (b = bcache.hash_buf[key].next; b; b = b-&gt;next)<br> &#123;<br>   <span class="hljs-keyword">if</span> (b-&gt;blockno == blockno &amp;&amp; b-&gt;dev == dev)<br>   &#123;<br>     b-&gt;refcnt++;<br>     release(&amp;bcache.hash_lock[key]);<br>     acquiresleep(&amp;b-&gt;lock);<br>     <span class="hljs-keyword">return</span> b;<br>   &#125;<br> &#125;<br><br> lru-&gt;next = bcache.hash_buf[key].next;<br> bcache.hash_buf[key].next = lru;<br><br> lru-&gt;refcnt = <span class="hljs-number">1</span>;<br> lru-&gt;dev = dev;<br> lru-&gt;blockno = blockno;<br> lru-&gt;valid = <span class="hljs-number">0</span>;<br><br> <span class="hljs-comment">// 释放这把锁</span><br> release(&amp;bcache.hash_lock[key]);<br> acquiresleep(&amp;lru-&gt;lock);<br> <span class="hljs-keyword">return</span> lru;<br></code></pre></td></tr></table></figure><p>来看一下<code>find_lru</code>函数的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> buf *<span class="hljs-title function_">find_lru</span><span class="hljs-params">(<span class="hljs-type">int</span> *ret_id)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">b</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">tmp_buf_ans</span> =</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NBUCKET; i++)&#123;<br>    acquire(&amp;bcache.hash_lock[i]);<br>    <span class="hljs-type">int</span> find_new = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (b = &amp;bcache.hash_buf[i]; b-&gt;next; b = b-&gt;next)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (b-&gt;next-&gt;refcnt == <span class="hljs-number">0</span> &amp;&amp; (!tmp_buf_ans || tmp_buf_ans-&gt;next-&gt;last_used &gt; b-&gt;next-&gt;last_used))<br>      &#123;<br>        find_new = <span class="hljs-number">1</span>;<br>        tmp_buf_ans = b;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 需要释放掉之前那把锁，而不是当前这把</span><br>    <span class="hljs-keyword">if</span> (find_new)&#123;<br>      <span class="hljs-keyword">if</span> ((*ret_id) != <span class="hljs-number">-1</span>)<br>        release(&amp;bcache.hash_lock[*ret_id]);<br><br>      *ret_id = i;<br>    &#125;<br>    <span class="hljs-comment">// 需要释放掉当前这把锁</span><br>    <span class="hljs-keyword">else</span>&#123;<br>      release(&amp;bcache.hash_lock[i]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> tmp_buf_ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后来看一下<code>brelse</code>函数。这个函数就比较容易理解，需要注意的一点就是，当<code>buf-&gt;refcnt==0</code>时，需要把<code>last_used</code>设置成<code>ticks</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">brelse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *b)</span>&#123;<br>  <span class="hljs-keyword">if</span> (!holdingsleep(&amp;b-&gt;lock))<br>    panic(<span class="hljs-string">&quot;brelse&quot;</span>);<br><br>  releasesleep(&amp;b-&gt;lock);<br><br>  <span class="hljs-type">int</span> key = HASH_FUNCTION(b-&gt;blockno);<br>  acquire(&amp;bcache.hash_lock[key]);<br><br>  b-&gt;refcnt--;<br>  <span class="hljs-keyword">if</span> (b-&gt;refcnt == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// no one is waiting for it.</span><br>    b-&gt;last_used = ticks;<br>  &#125;<br><br>  release(&amp;bcache.hash_lock[key]);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab5:COW</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab5%20cow/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab5%20cow/</url>
    
    <content type="html"><![CDATA[<h2 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a><strong>实验背景</strong></h2><p>大概就是说我们需要实现 UNIX 中的写时复制技术 （copy on write）。在没有写时复制的系统中，调用 <code>fork()</code> 时，我们会把父进程的所有的内存都拷贝到子进程的空间，自然，这个耗时是巨大且不可接受的。</p><p>并且在实际应用中，<code>fork()</code> 时拷贝的大部分内存都时不会被用到的，比如，在 UNIX 中新建一个进程的通常会先调用 <code>fork()</code>，然后调用 <code>exec()</code>。那么原先复制过来的数据就全部没用了。</p><p>在 <code>fork()</code> 时，只有一种情况是需要复制内存的。就是写入数据时，如果父进程或子进程尝试往某个地址写入值，那么为了确保写入的这个值不会影响别的进程，我们需要复制这个页帧。</p><p>而写时复制就是这样的一个技术，我们会把父进程和子进程共享页帧的 PTE 标为不可写的。那么有任何一个进程尝试往这个页帧写入时，就会产生缺页错误。在 <code>usertrap()</code> 函数中，我们可以处理这样的情况，也就是把共享页帧复制一份给尝试写入的进程，这个被复制的页帧会被标记为可写的。</p><p>实现写时复制后，可能会有多个进程同时共享一个页帧，那么只有所有的进程都不需要这个共享页帧时，我们才能真正的释放这个页帧。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h2><ol><li><p>修改<code>uvmcopy</code>函数，使得子进程的所有虚拟页都指向父进程相应虚拟页所对应的物理地址。在子进程和父进程的PTE中，都要把W属性给抹掉。这里可以使用pte中预留的两位。</p></li><li><p>修改<code>usertrap</code>函数，在里面增加页错误的处理逻辑。</p></li><li><p>物理页面的引用计数。</p></li><li><p>最后还需要注意<code>copyout</code>函数。</p></li></ol><h3 id="uvmcopy函数"><a href="#uvmcopy函数" class="headerlink" title="uvmcopy函数"></a>uvmcopy函数</h3><p><code>fork</code>函数中会调用<code>uvmcopy</code>函数来复制一份完整的进程空间，修改后使父进程和子进程的pte都指向同一物理页。</p><blockquote><p><strong>如果页面是可写的，才把PTE_W属性给抹去，同时还添加PTE_COW属性</strong>，表示这个页面将来被某个进程写时会另外分配物理内存给这个进程。<br>这个函数会调用increase_ref(pa)函数来增加物理页的引用计数;</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sz; i += PGSIZE)&#123;<br>    <span class="hljs-keyword">if</span> ((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    <span class="hljs-keyword">if</span> (*pte &amp; PTE_W)&#123;<br>      *pte = *pte &amp; ~(PTE_W);<br>      *pte = *pte | PTE_COW;<br>    &#125;<br>    flags = PTE_FLAGS(*pte);<br>    <span class="hljs-keyword">if</span> (mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>    increase_ref(pa);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err:<br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="usertrap函数"><a href="#usertrap函数" class="headerlink" title="usertrap函数"></a>usertrap函数</h3><p>在<code>usertrap</code>函数中增加COW处理的逻辑。首先得判断是否是COW的页异常is_cow_fault，然后调用<code>cow_alloc</code>函数分配一个物理页面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">15</span> || r_scause() == <span class="hljs-number">13</span>)&#123;<br>    uint64 va = r_stval();<br>    <span class="hljs-keyword">if</span> (is_cow_fault(p-&gt;pagetable, va))&#123;<br>      <span class="hljs-keyword">if</span> (cow_alloc(p-&gt;pagetable, va) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap: cow_alloc failed\n&quot;</span>);<br>        p-&gt;killed = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>      p-&gt;killed = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="is-cow-fault函数"><a href="#is-cow-fault函数" class="headerlink" title="is_cow_fault函数"></a>is_cow_fault函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_cow_fault</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pgtbl, uint64 va)</span>&#123;<br>  va = PGROUNDDOWN(va);<br>  <span class="hljs-type">pte_t</span> *pte = walk(pgtbl, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> ((*pte &amp; PTE_U) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (*pte &amp; PTE_COW)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cow-alloc函数"><a href="#cow-alloc函数" class="headerlink" title="cow_alloc函数"></a>cow_alloc函数</h3><p>在这个函数中，会申请物理内存，再把原来的物理页的内容复制到新的物理页上。<br>在这里<code>memmove</code>函数和<code>uvmunmap</code>函数的顺序不能够颠倒。新的物理页的映射就不需要COW标志位了，但需要添加W位，引用计数也要置为1。这里有一定的技巧，在后面会讲到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cow_alloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pgtbl, uint64 va)</span>&#123;<br>  va = PGROUNDDOWN(va);<br>  <span class="hljs-type">pte_t</span> *pte = walk(pgtbl, va, <span class="hljs-number">0</span>);<br>  <span class="hljs-type">int</span> flag = PTE_FLAGS(*pte);<br>  uint64 pa = PTE2PA(*pte);<br>  <span class="hljs-type">char</span> *mem = kalloc();<br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  memmove(mem, (<span class="hljs-type">void</span> *)pa, PGSIZE);<br>  uvmunmap(pgtbl, va, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>  flag &amp;= ~(PTE_COW);<br>  flag |= PTE_W;<br>  <span class="hljs-keyword">if</span> (mappages(pgtbl, va, PGSIZE, (uint64)mem, flag) &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    kfree(mem);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="kfree函数"><a href="#kfree函数" class="headerlink" title="kfree函数"></a>kfree函数</h3><p>如果该物理页的引用计数为1，那么该页面要被释放掉，否则，该物理页面不应该被释放。在这里要注意锁的使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  acquire(&amp;ref_lock);<br>  <span class="hljs-keyword">if</span> (ref_cnt[(uint64)pa / PGSIZE] &lt;= <span class="hljs-number">0</span>)<br>  &#123;<br>    panic(<span class="hljs-string">&quot;Impossible for page references less than 1\n&quot;</span>);<br>  &#125;<br>  release(&amp;ref_lock);<br><br>  decrease_ref((uint64)pa);<br><br>  acquire(&amp;ref_lock);<br>  <span class="hljs-keyword">if</span> (ref_cnt[(uint64)pa / PGSIZE] &gt;= <span class="hljs-number">1</span>)<br>  &#123;<br>    release(&amp;ref_lock);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  release(&amp;ref_lock);<br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run *)pa;<br><br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="freerange函数"><a href="#freerange函数" class="headerlink" title="freerange函数"></a>freerange函数</h3><p>在<code>freerange</code>遍历所有的物理页面中，首先把物理页面的引用计数记为1，然后执行<code>kfree</code>函数，这样每个物理页面的引用计数会为0，然后所有物理页面也会清除。<br>记得在<code>kinit</code>函数中初始化ref_lock锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> ref_cnt[PHYSTOP / PGSIZE];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">ref_lock</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span> *)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span> (; p + PGSIZE &lt;= (<span class="hljs-type">char</span> *)pa_end; p += PGSIZE)<br>  &#123;<br>    ref_cnt[(uint64)p / PGSIZE] = <span class="hljs-number">1</span>;<br>    kfree(p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="increase-ref函数和decrease-ref函数"><a href="#increase-ref函数和decrease-ref函数" class="headerlink" title="increase_ref函数和decrease_ref函数"></a>increase_ref函数和decrease_ref函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">increase_ref</span><span class="hljs-params">(uint64 pa)</span>&#123;<br>  <span class="hljs-keyword">if</span> (pa &gt;= PHYSTOP)<br>  &#123;<br>    panic(<span class="hljs-string">&quot;increase ref_cnt panic\n&quot;</span>);<br>  &#125;<br>  acquire(&amp;ref_lock);<br>  <span class="hljs-type">int</span> pn = pa / PGSIZE;<br>  ref_cnt[pn] += <span class="hljs-number">1</span>;<br>  release(&amp;ref_lock);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">decrease_ref</span><span class="hljs-params">(uint64 pa)</span>&#123;<br>  <span class="hljs-keyword">if</span> (pa &gt;= PHYSTOP)<br>  &#123;<br>    panic(<span class="hljs-string">&quot;increase ref_cnt panic\n&quot;</span>);<br>  &#125;<br>  acquire(&amp;ref_lock);<br>  <span class="hljs-type">int</span> pn = pa / PGSIZE;<br>  ref_cnt[pn] -= <span class="hljs-number">1</span>;<br>  release(&amp;ref_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>想一下，在哪里会调用这两个函数</p><blockquote><p><code>kfree</code>函数会调用<code>decrease_ref</code>函数<br><code>uvmcopy</code>函数应该调用<code>increase_ref</code>函数<br><code>kalloc</code>分配物理页面时把引用计数记为1</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab4:Traps</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab4%20traps/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab4%20traps/</url>
    
    <content type="html"><![CDATA[<h2 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h2><p>首先，做这个实验前，需要先了解gdb如何调试内核。</p><p>编译 xv6 操作系统并运行在 QEMU 模拟器中，并启动 GDB 调试器。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-variable">$make</span> <span class="hljs-attribute">CPUS</span>=1 qemu-gdb<br>*** Now <span class="hljs-built_in">run</span> <span class="hljs-string">&#x27;gdb&#x27;</span> <span class="hljs-keyword">in</span> another window.<br>qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 1 -nographic -drive <span class="hljs-attribute">file</span>=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,<span class="hljs-attribute">drive</span>=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000<br><br></code></pre></td></tr></table></figure><blockquote><p>-machine virt：使用virt机器模型<br>-bios none：不使用BIOS<br>-kernel kernel&#x2F;kernel：指定内核文件的路径<br>-m 128M：设置虚拟机的内存大小为128M<br>-smp 1：设置虚拟机的CPU数量为1<br>-S：在启动时暂停虚拟机<br>-gdb tcp::26000：启动一个GDB服务器，监听端口号为26000，等待GDB客户端连接。</p></blockquote><p>然后再另一个shell终端执行：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">gdb-multiarch kernel/kernel<br><span class="hljs-keyword">set</span> architecture <span class="hljs-comment">riscv:rv64</span><br>target <span class="hljs-comment">remote localhost:26000</span><br></code></pre></td></tr></table></figure><blockquote><p>gdb-multiarch 是一个支持多种架构的 GDB 调试器，可以用于调试不同架构的程序。在使用 gdb-multiarch 命令时，您需要指定要调试的可执行文件的架构类型。<br>kernel&#x2F;kernel 是一个可执行文件的路径，它指向了一个操作系统内核的二进制文件。在使用 gdb-multiarch kernel&#x2F;kernel 命令时，gdb-multiarch 将会以多架构模式启动，并加载 kernel&#x2F;kernel 文件以进行调试。</p></blockquote><p>如果要调试用户空间的程序</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">gdb</span>)file user/_call<br>(<span class="hljs-name">gdb</span>)b main<br>(<span class="hljs-name">gdb</span>)c<br></code></pre></td></tr></table></figure><p>接下来在原来的那个终端上就可以开始输入你想要执行的命令了。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">blackghost@LAPTOP<span class="hljs-number">-6</span>BH4BGNM ~/D/M/xv6-labs<span class="hljs-number">-2021</span> (traps) [<span class="hljs-number">1</span>]&gt; <br>qemu-<span class="hljs-keyword">system</span>-riscv64 -machine virt -bios <span class="hljs-literal">none</span> -kernel kernel/kernel -m <span class="hljs-number">128</span>M -smp <span class="hljs-number">1</span> -nographic -drive <span class="hljs-built_in">file</span>=fs.img,<span class="hljs-keyword">if</span>=<span class="hljs-literal">none</span>,<span class="hljs-built_in">format</span>=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus<span class="hljs-number">.0</span> -S -gdb tcp::<span class="hljs-number">26000</span><br><br>xv6 kernel is booting<br><br>init: starting sh<br>$ <br></code></pre></td></tr></table></figure><p>有没有感觉比较熟悉，其实在jyy的操作系统硬件视角的操作系统这一节课上，也谈到了如何用gdb调试内核。</p><hr><h2 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h2><p>这是risc-v的栈帧。riscv的栈帧和x86的栈帧有些许区别。</p><img src="/img/vx6-labs/stack.png" style="zoom: 33%;"><p>我们看到上面这张图，上面的栈帧是更早的函数调用，下面的栈帧是最新的函数调用，<code>sp</code>寄存器指向当前栈的栈顶，可以发现，在 riscv 中，fp 指向的是当前栈帧返回地址前面的一个位置（地址更高）。<code>fp-8</code>就得到当前栈帧的返回地址，<code>fp-16</code>记录的是Prev Frame。在 riscv 的定义中，返回地址也是属于当前栈帧的的一部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">()</span>&#123;<br>  uint64 fp = r_fp();  <br>  uint64 upper_bound = PGROUNDUP(fp);<br>  <span class="hljs-keyword">while</span> (fp != upper_bound)<br>  &#123;<br>    uint64 ret_addr = *(uint64 *)(fp - <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, ret_addr);<br>    fp = *(uint64 *)(fp - <span class="hljs-number">16</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h2><p>实验背景：<br>当一个进程在使用CPU的时候，我们希望每隔一段特定的时间都会使该进程去执行另外一段用户态的代码。时钟中断是一直在触发的，这个问题不需要我们去关心。</p><p>实现一个 <code>sigalarm(interval, handler)</code> 的系统调用。及每过 interval 个时钟周期，就执行一遍 <code>handler</code> 这个函数(进程实现)。此外还要实现一个 <code>sigreturn()</code> 系统调用，如果 <code>handler</code> 调用了这个系统调用，就应该停止执行 <code>handler</code> 这个函数，然后恢复正常的执行顺序。如果说 <code>sigalarm</code> 的两个参数都为 0，就代表停止执行 <code>handler</code> 函数。<code>handler</code>函数结尾需要有一个特殊的系统调用<code>sigreturn</code>。</p><p><code>sigalarm</code>应该如何实现?<br>首先，我们应该明确的一点是，这个<code>handler</code>函数地址我们是必须保存在<code>proc</code>结构体里面的。我们还需要一个域<code>tick</code>来表示周期的长短，还需要一个域<code>ticks_passed</code>来表示距离最近一次执行了<code>handler</code>函数过去了多长时间。<br>这里官方也给了一个提示，就是我们的这个处理函数<code>handler</code>可能执行时间会比较长，它执行的过程中是不允许再次执行<code>handler</code>函数的。所以我们就需要一个开关<code>alarm_on</code>, 如果这个打开则允许执行，关闭就不会执行直接跳过。也就是说，在进入<code>alarm_handler</code>之前，我们应该把<code>alarm_on</code>置为0，在<code>alarm_handler</code>函数返回前，再把<code>alarm_on</code>置为1.<br>所以proc结构体中应该添加三项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 alarm_handler; <span class="hljs-comment">// 函数地址</span><br><span class="hljs-type">int</span> ticks;            <span class="hljs-comment">// 多久少个tick调用一次 alarm_handler</span><br><span class="hljs-type">int</span> ticks_passed;     <span class="hljs-comment">// 最近一次调用alarm_handler是多久之前</span><br><span class="hljs-type">int</span> alarm_on;         <span class="hljs-comment">// 允不允许执行alarm_handler</span><br></code></pre></td></tr></table></figure><p>每发生一次时钟中断，都会进入<code>usertrap</code>函数，<code>ticks_passed</code>也应该加1。如果<code>ticks_passed</code>等于<code>ticks</code>，就要执行函数的跳转。那么怎么跳转，如果跳转到<code>handler</code>，那么应该记录一下<code>handler</code>执行完成后原来应该返回的地址呀。而执行完<code>handler</code>函数<code>sigreturn</code>回去，还应该恢复之前的寄存器现场呀。**我们是不是应该保存整个<code>trapframe</code>**。</p><blockquote><p>当用户态函数跳转时，应该更改<code>trapframe</code>页面的epc,指向<code>p-&gt;alarm_handler</code>。但还有，我们执行完<code>alarm_handler</code>函数再次执行<code>alarmreturn</code>系统调用后，不光是pc指针应该指向原来的位置，寄存器现场也应该是原来的数值。<br>所以我们应该创建一个临时页面(proc结构体里)，当需要进行用户函数<code>alarm_handler</code>的跳转时，就用这个页面把trapframe页面保存起来。<br>最后在<code>alarmreturn</code>系统调用中，再把trapframe页面恢复过来。还要把alarm_on再次打开。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br><span class="hljs-keyword">if</span> (which_dev == <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">if</span> (p-&gt;ticks &gt; <span class="hljs-number">0</span> &amp;&amp; p-&gt;alarm_on == <span class="hljs-number">1</span> &amp;&amp; (p-&gt;ticks_passed++) == p-&gt;ticks)&#123;<br>      p-&gt;alarm_on = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 保存好当前的所有寄存器现场</span><br>      *(<span class="hljs-keyword">struct</span> trapframe *)(p-&gt;alarm_frame) = *(<span class="hljs-keyword">struct</span> trapframe *)(p-&gt;trapframe);<br>      p-&gt;ticks_passed = <span class="hljs-number">0</span>;<br>      p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler;<br>    &#125;<br>    yield();<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  *(<span class="hljs-keyword">struct</span> trapframe *)(p-&gt;trapframe) = *(<span class="hljs-keyword">struct</span> trapframe *)(p-&gt;alarm_frame);<br>  p-&gt;alarm_on = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab3:Page Table</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab3%20page%20tables/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab3%20page%20tables/</url>
    
    <content type="html"><![CDATA[<h2 id="Speed-up-system-calls-easy"><a href="#Speed-up-system-calls-easy" class="headerlink" title="Speed up system calls (easy)"></a>Speed up system calls (easy)</h2><p>这个小实验就是要求实现一个不陷入内核的系统调用 <code>ugetpid</code>。<br>当一个进程被创建时，会在进程的地址空间中映射一个只读的内存区域，地址为USYSCALL。这个页面存储的是一个 struct usyscall 的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// memlayout.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> &#123;</span><br>  <span class="hljs-type">int</span> pid;  <span class="hljs-comment">// Process ID</span><br>  ....<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先需要看一下proc.h的改动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span> <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;           <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;           <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;           <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;              <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span> <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">ucall</span>;</span>      <span class="hljs-comment">// 不陷入内核的系统调用</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>题外话，这里的<code>trapframe</code>结构体和<code>trampoline</code>页面是如何进行映射的呢？我们从代码中找到答案。</p><p><code>trampoline</code>是陷入内核的代码，操作系统内核在启动的时候就设置了映射，这段代码存在于所有进程的虚拟地址空间中，且虚拟地址都是<code>TRAMPOLINE</code>，所有的进程都共享同一个物理页面。所以每一个进程在<code>proc_pagetable</code>中都有这么一个调用，可以看到，所有的进程都共享同一个物理页TRAMPOLINE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc_pagetable</span><br><span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>而<code>trapframe</code>则不一样，它是每一个进程私有的用来保存寄存器现场的，所以它需要先<code>kalloc</code>，然后再<code>mappages</code>，比如摘取到的代码如下。<code>porc</code>结构体中的<code>trapframe</code>是操作系统内核中某一个进程<code>trapframe</code>的物理地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// allocproc函数</span><br><span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>  freeproc(p);<br>  release(&amp;p-&gt;lock);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//proc_pagetable函数</span><br><span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>            (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>  uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmfree(pagetable, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说了上面这些，那么<code>usyscall</code>又应该怎么实现呢，首先，它是每个进程私有的，所以必须在<code>proc</code>结构体里面申明它的存在，其次，为了实现不陷入内核的系统调用，也就是说，用户进程可以直接在自己的某个虚拟地址中找到这些信息，也就是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">u</span> =</span> (<span class="hljs-keyword">struct</span> usyscall *)USYSCALL;   <br></code></pre></td></tr></table></figure><p>其中<code>USYSCALL</code>是我们规定好的一个虚拟地址，那么现在的问题是，我们需要在添加<code>proc-&gt;sysycall</code> (物理地址)到<code>USYSCALL</code>(虚拟地址)的映射就可以了。</p><p>直接读取USYSCALL处的内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ulib.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ugetpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-comment">// 这个虚拟地址处有一个 usyscall 的结构体指针</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">u</span> =</span> (<span class="hljs-keyword">struct</span> usyscall *)USYSCALL;          <span class="hljs-comment">// USYSCALL是一个给定的虚拟地址</span><br>  <span class="hljs-keyword">return</span> u-&gt;pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这些还不够，因为我们还没有建立映射关系，如果直接这样会触发xv6的缺页异常。</p><p>首先我们需要在<code>allocproc</code>函数申请一个进程的时候，为<code>usyscall</code>结构体申请物理内存。并把<code>ucall-&gt;pid</code>设置成进程的<code>pid</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((p-&gt;ucall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// freeproc(p);</span><br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了物理的内存，就可以建立映射关系了。我们在<code>proc_pagetable</code>中建立映射。虚拟地址为<code>USYSCALL</code>，物理地址为<code>p-&gt;ucall</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pagetable_t</span> <span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span>&#123;<br>  .............<br>      <br>  <span class="hljs-comment">// mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</span><br>  <span class="hljs-comment">// 物理地址 p-&gt;ucall, 内核已经分配好了</span><br>  <span class="hljs-keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;ucall), PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  ...........<br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Print-a-page-table-easy"><a href="#Print-a-page-table-easy" class="headerlink" title="Print a page table (easy)"></a>Print a page table (easy)</h2><p>首先我们要清楚 xv6 页表中虚拟地址的结构。</p><ul><li><p>虚拟地址只有39位，划分为：</p><blockquote><p>9(最高级页目录中的偏移) + 9(中级页目录偏移) + 9(最低级页目录偏移) + 12(offset) </p></blockquote></li><li><p>一个页表条目 8 字节，物理地址内存是56bit。</p><blockquote><p>一个条目中，最低10位为flags。还有44位做物理地址，这44位加上12位低位置零，就是56位的物理内存地址</p></blockquote></li></ul><p>实现一个 <code>vmprint()</code> 函数，该函数接收一个 pagetable_t 的参数，然后打印该页表，具体格式参考图片中的样式。在创建 <code>init</code> 进程时，调用这个函数打印页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint dep)</span>&#123;<br>  <span class="hljs-keyword">if</span>(dep == <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span>(pte &amp; PTE_V)&#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dep; j++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. &quot;</span>);<br>      uint64 child = PTE2PA(pte);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..%d: pte %p pa %p\n&quot;</span>, i, pte, child);<br>      <span class="hljs-keyword">if</span>(dep &lt; <span class="hljs-number">2</span>)<br>        <span class="hljs-comment">// 如果层数等于 2 就不需要继续递归了，因为这是叶子节点</span><br>        vmprint((<span class="hljs-type">pagetable_t</span>) child, dep + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Detecting-which-pages-have-been-accessed-hard"><a href="#Detecting-which-pages-have-been-accessed-hard" class="headerlink" title="Detecting which pages have been accessed (hard)"></a>Detecting which pages have been accessed (hard)</h2><p>实验背景：一些垃圾回收器会根据页面是否被访问过来回收不需要的页面，我们要实现一个函数<code>pgaccess</code>系统调用，记录哪些页面被访问过，并记录在一个<code>mask</code>掩码里。</p><img src="https://img-blog.csdnimg.cn/6dbf6d3ce0424bff84502ae0f5c65796.png" alt="xv6 pte结构" style="zoom:50%;"><p>pgaccess系统调用接受3个参数</p><ol><li>起始的虚拟地址</li><li>虚拟页的页数</li><li>一个用户态的掩码存储返回的结果</li></ol><p>The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared.这个A标志位是riscv处理器自己设置的，并不需要我们在软件上进行实现。实验指导上也说明，这个系统调用会把A标志位给清除。什么时候会把这个标志位置1呢，就是解决TLB缓存一次miss的情况下，会把页面的A置位1，也就是表示访问过。</p><p><img src="/img/xv6-labs/riscv_pte_layout.png"></p><p>首先是系统调用的申明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br></code></pre></td></tr></table></figure><p>在这个函数中，先要获取相关的参数。<code>argaddr(0,&amp;va)</code>是获取系统调用第一个参数，起始的虚拟地址。这个函数调用<code>walk</code>来找到第三级的<code>pte</code>，判断并设置<code>mask</code>。最后我们需要把<code>mask</code>写回到用户的地址空间中，这就需要<code>copyout</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-comment">// lab pgtbl: your code here.</span><br>  <span class="hljs-comment">// 获取参数  argaddr() and argint().</span><br>  uint64 va;<br>  <span class="hljs-type">int</span> sz;<br>  uint64 mask_addr;<br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;va) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">2</span>, &amp;mask_addr) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (sz &gt; <span class="hljs-number">32</span> || sz &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 把这个掩码写入进程 p 用户态的地址 mask_addr 中去。</span><br>  <span class="hljs-keyword">if</span> (va &gt; MAXVA)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// va = PGROUNDDOWN(va);</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++)&#123;<br>    <span class="hljs-comment">// 找到相应的 pte 条目。 walk() in kernel/vm.c is very useful for finding the right PTEs.</span><br>    uint vaddr = va + i * PGSIZE;<br>    <span class="hljs-type">pte_t</span> *pte = walk(p-&gt;pagetable, vaddr, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (vaddr &gt;= MAXVA)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (*pte &amp; PTE_A)&#123;<br>      mask |= (<span class="hljs-number">1</span> &lt;&lt; i);<br>      *pte = *pte &amp; (~PTE_A);<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</span><br>  <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, mask_addr, (<span class="hljs-type">char</span> *)(&amp;mask), (uint64)(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后看看<code>copyout</code>函数的实现，<code>walkaddr</code>函数返回的是虚拟地址所在的物理地址，然后调用<code>memmove</code>函数实现复制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">copyout</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 dstva, <span class="hljs-type">char</span> *src, uint64 len)</span><br>&#123;<br>  uint64 n, va0, pa0;<br><br>  <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    va0 = PGROUNDDOWN(dstva);<br>    pa0 = walkaddr(pagetable, va0);<br>    <span class="hljs-keyword">if</span> (pa0 == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    n = PGSIZE - (dstva - va0);<br>    <span class="hljs-keyword">if</span> (n &gt; len)<br>      n = len;<br>    memmove((<span class="hljs-type">void</span> *)(pa0 + (dstva - va0)), src, n);<br><br>    len -= n;<br>    src += n;<br>    dstva = va0 + PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2:System Call</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab2%20system%20call/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab2%20system%20call/</url>
    
    <content type="html"><![CDATA[<h2 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h2><p>这篇笔记主要记录一下lab2 system call遇到的困难和一些思考，以及在做这个实验要求要看的xv6源码的整理。</p><h2 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo (moderate)"></a>Sysinfo (moderate)</h2><ul><li>实验目的</li></ul><p>在这个小实验中，需要实现一个系统调用 <code>sysinfo</code>, 返回系统运行时的一些信息，例如进程的数目，物理内存的多少等。我们需要定义一个<code>sysinfo</code>的结构体，这个结构体中有一些系统运行时的信息。</p><ul><li>实验流程</li></ul><ol><li><p>把 $U&#x2F;_sysinfotest 添加到Makefile中的 UPROGS。</p></li><li><p>为用户进程调用该系统调用提供一个接口： user&#x2F;user.h 中。</p></li><li><p>在 usys.pl文件中添加一行 <code>entry(&quot;sysinfo&quot;)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// user/user.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sysinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sysinfo *)</span>;<br><span class="hljs-comment">// usys.pl</span><br>entry(<span class="hljs-string">&quot;sysinfo&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>在 usys.pl文件中有对应的一行 entry(“sysinfo”)，会直接生成相应的汇编代码。生成的汇编代码中指明了系统调用号，还有一条 ecall 指令陷入系统内核。</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">entry</span> </span>&#123;<br>    <span class="hljs-keyword">my</span> $name = <span class="hljs-keyword">shift</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;.global $name\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>:\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; li a7, SYS_<span class="hljs-subst">$&#123;name&#125;</span>\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ecall\n&quot;</span>;<br>    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ret\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在kernel&#x2F;syscall.h中新定义相应的系统调用号。</p></li><li><p>在kernel&#x2F;sysproc.c中实现 <code>sys_sysinfo</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 由于已经进入内核，相应的参数存在寄存器中。</span><br>uint64 <span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><blockquote><p>  实际上，用户程序执行完 ecall 指令后，会执行 syscall 函数(关于 ecall 指令的具体细节会在下一次trapoline章节中详细讲到)。</p></blockquote></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])&#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br><br>    <span class="hljs-keyword">if</span> (((<span class="hljs-number">1</span> &lt;&lt; num) &amp; (p-&gt;mask)) &gt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d \n&quot;</span>, p-&gt;pid, table[num], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>           p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>syscall函数又会调用 <code>syscalls[num]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123;<br>    [SYS_fork] sys_fork,       <span class="hljs-comment">// SYS_fork是宏，展开后是数字</span><br>    [SYS_exit] sys_exit,<br>    .....<br>    [SYS_sysinfo] sys_sysinfo,<br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>这几行代码定义了一个名为 <code>syscalls</code>的静态数组，数组的每个元素都是一个指向函数的指针。</p></blockquote><ol start="6"><li>实现 <code>sys_sysinfo</code>函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-comment">// 有一个参数，表示 sysinfo 结构体的地址</span><br>  uint64 addr;<br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-comment">// freemem    还剩下多少个字节(物理内存)</span><br>  <span class="hljs-comment">// nproc      number of processes whose state is not UNUSED</span><br>  uint64 np;<br>  uint64 fm;<br>  np = cal_proc_unused();<br>  fm = cal_freemem();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">tmp</span>;</span><br>  tmp.freemem = fm;<br>  tmp.nproc = np;<br>  <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)(&amp;tmp), <span class="hljs-keyword">sizeof</span>(tmp)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><ul><li>内核中物理内存的组织 (kalloc.c文件)<blockquote><p>xv6 将物理内存组织成一个链表。<br>kmem是指向空闲物理页的链表。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br></code></pre></td></tr></table></figure></li></ul><p>分配物理页和回收物理页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span> (r)<br>    kmem.freelist = r-&gt;next;<br>  release(&amp;kmem.lock);<br><br>  <span class="hljs-keyword">if</span> (r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span> *)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span> *)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run *)pa;<br><br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上面的提示，就可以写出计算剩余物理内存的函数了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">cal_freemem</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  uint64 mem = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// acquire(&amp;kmem.lock);</span><br>  r = kmem.freelist;<br>  <span class="hljs-keyword">while</span> (r)<br>  &#123;<br>    r = r-&gt;next;<br>    mem++;<br>  &#125;<br>  <span class="hljs-comment">// release(&amp;kmem.lock);</span><br>  <span class="hljs-keyword">return</span> mem * PGSIZE;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab10:mmap</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab10%20mmap/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab10%20mmap/</url>
    
    <content type="html"><![CDATA[<h2 id="mmap-lab"><a href="#mmap-lab" class="headerlink" title="mmap lab"></a><strong>mmap lab</strong></h2><p>这个实验需要我们完成mmap系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><p>意思是映射描述符为 <code>fd</code> 的文件，的前 <code>length</code> 个字节到 <code>addr</code> 开始的位置。并且加上 <code>offset</code> 的偏移量（即不从文件的开头映射）    如果 <code>addr</code> 参数为 0，系统会自动分配一个空闲的内存区域来映射，并返回这个地址。</p><p>在实验中我们只需要支持 <code>addr</code> 和 <code>offset</code> 都为 0 的情况，也就是完全不用考虑用户指定内存和文件偏移量。</p><p>根据实验的hints，我们需要在<code>struct proc</code> 中定义一个<code>vma</code> 数组:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> <span class="hljs-title">vmas</span>[<span class="hljs-title">NVMA</span>];</span><br></code></pre></td></tr></table></figure><p>这个<code>struct vma</code> 如下，每一个<code>vma</code> 都表示一个需要进行mmap的文件，里面记录了起始的虚拟地址，映射的大小，权限，以及文件的偏移位置(这里应该默认为0)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>&#123;</span><br>  <span class="hljs-type">int</span> valid;<br>  uint64 vastart;<br>  uint64 sz;<br><br>  <span class="hljs-type">int</span> prot;<br>  <span class="hljs-type">int</span> flags;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>  uint64 offset;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NVMA 16</span><br></code></pre></td></tr></table></figure><p>在调用mmap系统调用的时候，并不会立马就为进程进行该文件分配真实的物理地址到虚拟地址的映射，只是占用一个<code>vma</code> ，将相应的变量设置好，然后就立马返回。等到进程需要访问这段mmap的虚拟地址时，会触发缺页中断，再在缺页中断处理中进行物理内存分配和虚拟地址的映射。</p><p>我们再来看一下进程的地址空间:</p><img src="/img/xv6-labs/addrspace.png" style="zoom: 50%;"><p>在mmap映射中，只能在heap中，不能超过trapframe。我们从heap顶端开始进行向下分配，所以我们需要记录一个<code>vaend</code> 表示最上面已被占用的地址空间。</p><h3 id="sys-mmap"><a href="#sys-mmap" class="headerlink" title="sys_mmap"></a><strong>sys_mmap</strong></h3><p>首先我们来看<code>sys_mmap</code> 系统调用，主要逻辑就是在<code>vmas</code> 数组中找到一个未被占用的<code>struct vma</code> 。等到缺页中断发生时就用这个<code>vma</code> 进行物理内存的分配和地址的映射。返回文件映射的起始地址<code>vastart</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>  uint64 addr, sz, offset;<br>  <span class="hljs-type">int</span> prot, flags, fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br><br>  <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span> || argfd(<span class="hljs-number">4</span>, &amp;fd, &amp;f) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">5</span>, &amp;offset) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">if</span> ((!f-&gt;readable &amp;&amp; (prot &amp; (PROT_READ))) || (!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; !(flags &amp; MAP_PRIVATE)))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  sz = PGROUNDUP(sz);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>  uint64 vaend = MMAPEND; <span class="hljs-comment">// non-inclusive，不能超过trapframe</span><br><br>  <span class="hljs-comment">// mmaptest never passed a non-zero addr argument.</span><br>  <span class="hljs-comment">// so addr here is ignored and a new unmapped va region is found to</span><br>  <span class="hljs-comment">// map the file</span><br>  <span class="hljs-comment">// our implementation maps file right below where the trapframe is,</span><br>  <span class="hljs-comment">// from high addresses to low addresses.</span><br><br>  <span class="hljs-comment">// Find a free vma, and calculate where to map the file along the way.</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NVMA; i++)&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">vv</span> =</span> &amp;p-&gt;vmas[i];<br>    <span class="hljs-keyword">if</span> (vv-&gt;valid == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0</span>)&#123;<br>        v = &amp;p-&gt;vmas[i];<br>        <span class="hljs-comment">// found free vma;</span><br>        v-&gt;valid = <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vv-&gt;vastart &lt; vaend)&#123;<br>      vaend = PGROUNDDOWN(vv-&gt;vastart);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0</span>)&#123;<br>    panic(<span class="hljs-string">&quot;mmap: no free vma&quot;</span>);<br>  &#125;<br><br>  v-&gt;vastart = vaend - sz;<br>  v-&gt;sz = sz;<br>  v-&gt;prot = prot;<br>  v-&gt;flags = flags;<br>  v-&gt;f = f; <span class="hljs-comment">// assume f-&gt;type == FD_INODE</span><br>  v-&gt;offset = offset;<br><br>  filedup(v-&gt;f);<br><br>  <span class="hljs-keyword">return</span> v-&gt;vastart;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a><strong>缺页中断处理</strong></h3><p>首先得到引发缺页异常的虚拟地址，再调用<code>mmap_solve(va)</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 va = r_stval();<br><span class="hljs-keyword">if</span> (r_scause() == <span class="hljs-number">13</span> || r_scause() == <span class="hljs-number">15</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (mmap_solve(va) == <span class="hljs-number">-1</span>)<br>  &#123;<br>    <span class="hljs-keyword">goto</span> error;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap_solve</code> 函数也很明显了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mmap_solve</span><span class="hljs-params">(uint64 va)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">v</span> =</span> findvma(p, va);<br>  <span class="hljs-keyword">if</span> (v == <span class="hljs-number">0</span>)<br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// printf(&quot;vma mapping: %p =&gt; %d\n&quot;, va, v-&gt;offset + PGROUNDDOWN(va - v-&gt;vastart));</span><br><br>  <span class="hljs-comment">// allocate physical page</span><br>  <span class="hljs-type">void</span> *pa = kalloc();<br>  <span class="hljs-keyword">if</span> (pa == <span class="hljs-number">0</span>)<br>  &#123;<br>    panic(<span class="hljs-string">&quot;vmalazytouch: kalloc&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br><br>  <span class="hljs-comment">// read data from disk</span><br>  begin_op();<br>  ilock(v-&gt;f-&gt;ip);<br>  readi(v-&gt;f-&gt;ip, <span class="hljs-number">0</span>, (uint64)pa, v-&gt;offset + PGROUNDDOWN(va - v-&gt;vastart), PGSIZE);<br>  iunlock(v-&gt;f-&gt;ip);<br>  end_op();<br><br>  <span class="hljs-comment">// set appropriate perms, then map it.</span><br>  <span class="hljs-type">int</span> perm = PTE_U;<br>  <span class="hljs-keyword">if</span> (v-&gt;prot &amp; PROT_READ)<br>    perm |= PTE_R;<br>  <span class="hljs-keyword">if</span> (v-&gt;prot &amp; PROT_WRITE)<br>    perm |= PTE_W;<br>  <span class="hljs-keyword">if</span> (v-&gt;prot &amp; PROT_EXEC)<br>    perm |= PTE_X;<br><br>  <span class="hljs-keyword">if</span> (mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, PTE_R | PTE_W | PTE_U) &lt; <span class="hljs-number">0</span>)<br>  &#123;<br>    panic(<span class="hljs-string">&quot;vmalazytouch: mappages&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>到此好像都结束了，还有什么遗漏的细节吗？</p><blockquote><p>fork函数也需要把vma数组都复制给子进程！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1:Unix Utilities</title>
    <link href="/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab1%20unix%20utilities/"/>
    <url>/2024/02/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/xv6-labs/lab1%20unix%20utilities/</url>
    
    <content type="html"><![CDATA[<h2 id="Prime"><a href="#Prime" class="headerlink" title="Prime"></a>Prime</h2><p>这道编程题目是lab1中最难的一个了。我们观察它课程网站上给的算法图示，我们可以知道，第一个进程通过管道不断往子进程写入这些数，然后子进程会特别地接收第一个管道里的数，记为<code>first_num</code>，然后打印这个<code>first_num</code>，因为这个数一定是素数。然后在它后续接收到的数中，判断这个数是否是<code>first_num</code>的整数倍，如果不是，证明它可能是素数，然后它通过管道再向它自己的子进程写入这个数，如此往复。</p><ul><li>代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> *fd)</span>&#123;<br>    <span class="hljs-type">int</span> first_number = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (read(fd[<span class="hljs-number">0</span>], &amp;first_number, <span class="hljs-keyword">sizeof</span>(first_number)) == <span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d \n&quot;</span>, first_number);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> newfd[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (pipe(newfd) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)&#123;<br>        close(newfd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 一边从 fd[0] 端读取，一边向 newfd[1] 写入</span><br>        <span class="hljs-type">int</span> receive_data;<br>        <span class="hljs-keyword">while</span> (read(fd[<span class="hljs-number">0</span>], &amp;receive_data, <span class="hljs-keyword">sizeof</span>(receive_data)) == <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-keyword">if</span> (receive_data % first_number)&#123;<br>                write(newfd[<span class="hljs-number">1</span>], &amp;receive_data, <span class="hljs-keyword">sizeof</span>(receive_data));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        solve(newfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    n = atoi(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (pipe(fd) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)&#123;<br>        solve(fd);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<br>            write(fd[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>本质是一道阅读理解题和字符串处理题，要求是读取标准输出流（文件描述符为0）的内容作为某一次<code>xargs</code>的<code>argv</code>参数，需要执行多少次就执行多少次。</p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>仿照<code>ls.c</code>可以写出来,需要注意<code>..</code>和<code>.</code>这两个特殊的文件，放置避免无穷递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *currentp, <span class="hljs-type">char</span> *filename)</span>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>  <span class="hljs-type">char</span> *p;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>  <span class="hljs-keyword">if</span> ((fd = open(currentp, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Cannot open %s\n&quot;</span>, currentp);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Cannot stat %s\n&quot;</span>, currentp);<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (st.type == T_FILE)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Find argv[1] must be a DIR\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(currentp) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-built_in">strcpy</span>(buf, currentp);<br>  p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>  *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>  <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>    <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    memmove(p, de.name, DIRSIZ);<br>    p[DIRSIZ] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cannot stat %s\n&quot;</span>, buf);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.type == T_FILE)&#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(de.name, filename))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.type == T_DIR)&#123;<br>      find(buf, filename);<br>    &#125;<br>  &#125;<br>  close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>  <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: find error\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br><br>  find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>xv6-labs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>xv6-labs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析9-FilterBlock解析</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909-FilterBlock%E8%A7%A3%E6%9E%90/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909-FilterBlock%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么需要FilterBlock"><a href="#为什么需要FilterBlock" class="headerlink" title="为什么需要FilterBlock"></a>为什么需要FilterBlock</h2><p>Filter block为SST中一个区块，filter block由多个filter组成，每个data block对应一个filter（但是一个filter可能对应多个data block）。LevelDB在进入data block中查找前会先检查filter，如果filter判断key不在，那么key一定不在这个block中，就不用进入data block查找了，filter判断key可能存在才会进入data block查找。</p><p>Filter block由FilterBlockBuilder负责构建，下面我们先看一下FilterBlockBuilder的结构和成员函数。最后举个例子详细解释创建filter的完整过程，以方便理解。</p><h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a><strong>Bloom Filter</strong></h2><p>Bloom Filter 底层使用一个位数组（bit array），初始，所表示集合为空时，所有位都为 0：</p><img src="/img/leveldb/bloom-1.png" style="zoom:67%;"><p>当往集合中插入一个元素 x 时，利用 k 个<strong>独立</strong>的哈希函数分别对 x 进行散列，然后将 k 个散列值按数组长度取余后分别将数组中对应位置置为 1：</p><img src="/img/leveldb/bloom-2.jpg" style="zoom:67%;"><p>查找过程和插入过程类似，也是利用同样的 k 个哈希函数对待查找元素按顺序进行哈希，得到 k 个位置。如果位数组中 k 个位置上的位均为 1，则该元素<strong>有可能</strong>存在；否则，若任意一位置上值为 0，则该值<strong>一定</strong>不存在。对于下图来说，x1 有可能存在，x2 一定不存在。</p><img src="/img/leveldb/bloom-3.jpg" style="zoom:67%;"><p>当持续插入一些元素后，数组中会有大量位置被置 1，可以想象，肯定会有一些位置冲突，造成误判。使用 k 个独立哈希函数可以部分解决这个问题。但如果对于某个值 y，k 个 hash(y) 计算出来的位置，都恰好被其他时候插入的几个元素值设置为 1，则会误判 y 在集合中。</p><h2 id="参数取舍"><a href="#参数取舍" class="headerlink" title="参数取舍"></a><strong>参数取舍</strong></h2><p>从上面对 Bloom Filter 可以粗略的感受到，其误判率应该和以下参数有关：</p><ol><li>哈希函数的个数 k</li><li>底层位数组的长度 m</li><li>数据集大小 n</li></ol><p>这几个参数与误判率的关系的推导这里不详细展开，可以参考<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Bloom_filter">维基百科</a>，或者这篇 <a href="https://link.zhihu.com/?target=https://blog.csdn.net/jiaomeng/article/details/1495500">CSDN 文章</a>。这里直接给出结论：</p><p>当 <code>k = ln2 * (m/n)</code> 时，Bloom Filter 获取最优的准确率。m&#x2F;n 即 bits per key（集合中每个 key 平均分到的 bit 数）。</p><h2 id="leveldb中的实现"><a href="#leveldb中的实现" class="headerlink" title="leveldb中的实现"></a><strong>leveldb中的实现</strong></h2><p>为了减小读放大，尤其是对磁盘访问的读放大，LevelDB 抽象出了一个 <code>FilterPolicy</code> 接口，用以在查找 key 时快速筛掉不符合条件的 SStable，这些 Filter 信息会和数据在 SSTable 文件中一起存储，并且在需要时加载到内存，这要求 Filter 占空间不能太大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LEVELDB_EXPORT</span> <span class="hljs-title">FilterPolicy</span> &#123;</span><br> public:<br>  virtual ~FilterPolicy();<br><br>  <span class="hljs-comment">// 过滤策略的名字，用来唯一标识该 Filter 持久化、载入内存时的编码方法。</span><br>  virtual <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 给长度为 n 的 keys 集合（可能有重复）创建一个过滤策略，并将策略序列化为 string ，追加到 dst 最后。</span><br>  virtual <span class="hljs-type">void</span> <span class="hljs-title function_">CreateFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice* keys, <span class="hljs-type">int</span> n, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* dst)</span> <span class="hljs-type">const</span> = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// “过滤” 函数。若调用 CreateFilter 时传入的集合为 keys，则如果 key 在 keys 中，则必须返回 true。</span><br>  <span class="hljs-comment">// 若 key 不在 keys 中，可以返回 true，也可以返回 false，但最好大概率返回 false。</span><br>  virtual <span class="hljs-type">bool</span> <span class="hljs-title function_">KeyMayMatch</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; filter)</span> <span class="hljs-type">const</span> = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>抽象出该接口可以让用户根据自己需求实现一些其他的过滤策略。自然的，LevelDB 提供了实现了该接口的一个内置的过滤策略：<code>BloomFilterPolicy</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BloomFilterPolicy</span> :</span> public FilterPolicy &#123;<br> public:<br>  explicit <span class="hljs-title function_">BloomFilterPolicy</span><span class="hljs-params">(<span class="hljs-type">int</span> bits_per_key)</span> : <span class="hljs-title function_">bits_per_key_</span><span class="hljs-params">(bits_per_key)</span> &#123;<br>    <span class="hljs-comment">// 根据上面提到的结论：k = ln2 * (m/n)，获取哈希函数的个数 k。</span><br>    <span class="hljs-comment">// 这里对 k 进行了向下取整、限制最大值，增加了一点误判率，但是也降低了过滤成本。</span><br>    k_ = static_cast&lt;<span class="hljs-type">size_t</span>&gt;(bits_per_key * <span class="hljs-number">0.69</span>);  <span class="hljs-comment">// 0.69 =~ ln(2)</span><br>    <span class="hljs-keyword">if</span> (k_ &lt; <span class="hljs-number">1</span>) k_ = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (k_ &gt; <span class="hljs-number">30</span>) k_ = <span class="hljs-number">30</span>;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">Name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> override &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;leveldb.BuiltinBloomFilter2&quot;</span>; &#125;<br><br>  <span class="hljs-type">void</span> <span class="hljs-title function_">CreateFilter</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice* keys, <span class="hljs-type">int</span> n, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>* dst)</span> <span class="hljs-type">const</span> override &#123;<br>    <span class="hljs-comment">// 计算 bloom filter 的 bit 数组长度 n，会除以 8 向上取整，因为 bit 数组最后会用 char 数组表示</span><br>    <span class="hljs-type">size_t</span> bits = n * bits_per_key_;<br>    <span class="hljs-keyword">if</span> (bits &lt; <span class="hljs-number">64</span>) bits = <span class="hljs-number">64</span>; <span class="hljs-comment">// 如果数组太短，会有很高的误判率，因此这里增加了一个最小长度限定。</span><br>    <span class="hljs-type">size_t</span> bytes = (bits + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;<br>    bits = bytes * <span class="hljs-number">8</span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> init_size = dst-&gt;size();<br>    dst-&gt;resize(init_size + bytes, <span class="hljs-number">0</span>);<br>    dst-&gt;push_back(static_cast&lt;<span class="hljs-type">char</span>&gt;(k_));  <span class="hljs-comment">// 记下哈希函数的个数</span><br>    <span class="hljs-type">char</span>* <span class="hljs-built_in">array</span> = &amp;(*dst)[init_size];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-comment">// 使用 double-hashing 方法，仅使用一个 hash 函数来生成 k 个 hash 值，近似等价于使用 k 个哈希函数的效果</span><br>      <span class="hljs-comment">// 详细分析可以参考：https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf</span><br>      <span class="hljs-type">uint32_t</span> h = BloomHash(keys[i]);<br>      <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> delta = (h &gt;&gt; <span class="hljs-number">17</span>) | (h &lt;&lt; <span class="hljs-number">15</span>);  <span class="hljs-comment">// 循环右移 17 bits 作为步长</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; k_; j++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> bitpos = h % bits;<br>        <span class="hljs-built_in">array</span>[bitpos / <span class="hljs-number">8</span>] |= (<span class="hljs-number">1</span> &lt;&lt; (bitpos % <span class="hljs-number">8</span>));<br>        h += delta;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-type">bool</span> <span class="hljs-title function_">KeyMayMatch</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; bloom_filter)</span> <span class="hljs-type">const</span> override &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len = bloom_filter.size();<br>    <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-built_in">array</span> = bloom_filter.data();<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> bits = (len - <span class="hljs-number">1</span>) * <span class="hljs-number">8</span>; <span class="hljs-comment">// -1 是去掉 k 所占空间</span><br><br>    <span class="hljs-comment">// 取出创建 Filter 时保存的哈希函数个数 k</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> k = <span class="hljs-built_in">array</span>[len - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">30</span>) &#123;<br>      <span class="hljs-comment">// 超过我们设定 k 个数，直接返回 true，不滤掉该 SSTable.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">uint32_t</span> h = BloomHash(key);<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> delta = (h &gt;&gt; <span class="hljs-number">17</span>) | (h &lt;&lt; <span class="hljs-number">15</span>);  <span class="hljs-comment">// 循环右移 17 bits 作为步长</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> bitpos = h % bits;<br>      <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">array</span>[bitpos / <span class="hljs-number">8</span>] &amp; (<span class="hljs-number">1</span> &lt;&lt; (bitpos % <span class="hljs-number">8</span>))) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      h += delta;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br> private:<br>  <span class="hljs-type">size_t</span> bits_per_key_;<br>  <span class="hljs-type">size_t</span> k_;<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据上述源代码，LevelDB 在实现时，有以下几个点需要注意：</p><ol><li>之前提到的 bit 数组在 C++ 语言中，LevelDB 使用 char 数组来表示。因此计算 bit 数组长度时需要对齐到 8 的倍数，计算下标时需要进行适当转换。</li><li>LevelDB 实现时并未真正使用 k 个哈希函数，而是用了 <a href="https://link.zhihu.com/?target=https://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">double-hashing</a> 方法进行了一个优化，号称可以达到相似的正确率。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析7-SSTable(1)</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%907-sstable(1)/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%907-sstable(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="sstable"><a href="#sstable" class="headerlink" title="sstable"></a>sstable</h2><p>首先我们看一下sstable的结构图</p><ol><li><p>文件中的k&#x2F;v对是有序存储的，并且被划分到连续排列的Data Block里面，这些Data Block从文件头开始顺序存储，Data Block的存储格式代码在block_builder.cc中；</p></li><li><p>紧跟在Data Block之后的是Meta Block，其格式代码也在block_builder.cc中；Meta Block存储的是Filter信息，比如Bloom过滤器，用于快速定位key是否在data block中。</p></li><li><p>MetaIndex Block是对Meta Block的索引，它只有一条记录，key是meta index的名字（也就是Filter的名字），value为指向meta index的BlockHandle；BlockHandle是一个结构体，成员offset_是Block在文件中的偏移，成员size_是block的大小；</p></li><li><p>Index block是对Data Block的索引，对于其中的每个记录，其key &gt;&#x3D;Data Block最后一条记录的key，同时&lt;其后Data Block的第一条记录的key；value是指向data index的BlockHandle；</p></li></ol><p><img src="/img/leveldb/leveldb-sstable.png"></p><p>sstbale结构体主要的一些成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">Options options;<br>Options index_block_options;<br>WritableFile* file;                   <span class="hljs-comment">// 要写入的文件</span><br><span class="hljs-type">uint64_t</span> offset;                      <span class="hljs-comment">// 文件已写入的大小  </span><br>Status status;            <br>BlockBuilder data_block;              <span class="hljs-comment">// data_block缓冲，满后写入文件再置空          </span><br>BlockBuilder index_block;             <span class="hljs-comment">// index缓冲，最后才写入文件</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> last_key;                 <span class="hljs-comment">// 上一次插入的 key , 用来前缀压缩</span><br><span class="hljs-type">int64_t</span> num_entries;                 <br><span class="hljs-type">bool</span> closed;  <span class="hljs-comment">// Either Finish() or Abandon() has been called.</span><br>FilterBlockBuilder* filter_block;    <br><span class="hljs-type">bool</span> pending_index_entry;<br>BlockHandle pending_handle;            <span class="hljs-comment">// Handle to add to index block</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> compressed_output;<br></code></pre></td></tr></table></figure><p>sstable构建过程：</p><ol><li>首先往data_block中不断<code>Add</code>插入数据，更新index_block和filter_block</li><li>如果data_block地大小超过了指定大小，就要调用<code>Flush</code>函数，将新的data_block写入文件中，然后再调用data_block的<code>reset</code>函数，把它置为空。</li><li>直到table_builder调用了<code>Finish</code> 函数，整个过程才结束。<code>Finish</code> 函数首先调用<code>Flush</code> 把data_block写入文件，至此，data_block已经全部写入文件中了。然后再把filter_block写入文件，再写meta_index_block,再写index_block,最后为sstable的末尾添加一个footer。</li></ol><h2 id="sstable接口"><a href="#sstable接口" class="headerlink" title="sstable接口"></a>sstable接口</h2><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><ol><li>如果<code>pending_index_entry</code> 为 true, 也就是data_block为空的时候，首先找到一个长度最短的字符串，使得这个字符串的大小大于等于<code>last_key</code> 小于<code>key</code> ，并把这个字符串赋值给<code>last_key</code> 。然后<code>r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding))</code> 为index_block插入一个索引。这就表示了key大于等于<code>last_key</code> 的第一个data_entry的位置在当前文件的<code>offset_</code> 处。</li></ol><blockquote><p>这里的<code>BlockHanle pending_hanle</code> 就是表示Block的信息的一个结构体，有<code>offset_</code> 和<code>size_</code> 两个成员，<code>EncodeTo</code> 函数就是把这两个成员进行encode,把这个字符串当做index_block的Value部分，这样就可以快速定位到文件的指定位置了。<br>初始的时候，pending_index_entry置为false也就不难理解了</p></blockquote><ol start="2"><li>接下来就是往data_block中写入KV，如果Block超过指定大小了，就要进行<code>Flush</code> 操作</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TableBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> &#123;<br>  Rep* r = rep_;<br>  assert(!r-&gt;closed);<br>  <span class="hljs-keyword">if</span> (!ok()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (r-&gt;num_entries &gt; <span class="hljs-number">0</span>) &#123;<br>    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry) &#123;<br>    assert(r-&gt;data_block.empty());<br>    <span class="hljs-comment">// 这里会把结果赋值给 r-&gt;last_key</span><br>    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> handle_encoding;<br>    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);<br>    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));<br>    r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (r-&gt;filter_block != nullptr) &#123;<br>    r-&gt;filter_block-&gt;AddKey(key);<br>  &#125;<br><br>  r-&gt;last_key.assign(key.data(), key.size());<br>  r-&gt;num_entries++;<br>  r-&gt;data_block.Add(key, value);<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();<br>  <span class="hljs-keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;<br>    Flush();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h3><p><code>Flush</code>函数就是把data_block写入文件中，把<code>pending_index_entry</code>置为true.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TableBuilder::Flush</span><span class="hljs-params">()</span> &#123;<br>  Rep* r = rep_;<br>  assert(!r-&gt;closed);<br>  <span class="hljs-keyword">if</span> (!ok()) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (r-&gt;data_block.empty()) <span class="hljs-keyword">return</span>;<br>  assert(!r-&gt;pending_index_entry);<br>  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);<br>  <span class="hljs-keyword">if</span> (ok()) &#123;<br>    r-&gt;pending_index_entry = <span class="hljs-literal">true</span>;<br>    r-&gt;status = r-&gt;file-&gt;Flush();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (r-&gt;filter_block != nullptr) &#123;<br>    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="WriteBlock-和-WriteRawBlock"><a href="#WriteBlock-和-WriteRawBlock" class="headerlink" title="WriteBlock 和 WriteRawBlock"></a>WriteBlock 和 WriteRawBlock</h3><p><code>WriteBlock</code> 这个函数需要进行一些压缩处理的技巧，最后会调用<code>WriteRawBlock</code> 函数</p><p><code>WriteRawBlock</code> 这个函数就是把内容写入文件中，再在末尾添加一个crc32和一个type共5个字节的内容</p><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p><code>Finish</code> 函数表示SST的数据部分(data_block)已经全部<code>Add</code> 了，现在需要把filter_block,index，meta_index_block，index_block，footer写入到文件中了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">TableBuilder::Finish</span><span class="hljs-params">()</span> &#123;<br>  Rep* r = rep_;<br>  Flush();<br>  assert(!r-&gt;closed);<br>  r-&gt;closed = <span class="hljs-literal">true</span>;<br><br>  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;<br><br>  <span class="hljs-comment">// Write filter block</span><br>  <span class="hljs-keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != nullptr) &#123;<br>    WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,<br>                  &amp;filter_block_handle);<br>  &#125;<br><br>  <span class="hljs-comment">// Write metaindex block</span><br>  <span class="hljs-keyword">if</span> (ok()) &#123;<br>    BlockBuilder <span class="hljs-title function_">meta_index_block</span><span class="hljs-params">(&amp;r-&gt;options)</span>;<br>    <span class="hljs-keyword">if</span> (r-&gt;filter_block != nullptr) &#123;<br>      <span class="hljs-comment">// Add mapping from &quot;filter.Name&quot; to location of filter data</span><br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> key = <span class="hljs-string">&quot;filter.&quot;</span>;<br>      key.append(r-&gt;options.filter_policy-&gt;Name());<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> handle_encoding;<br>      filter_block_handle.EncodeTo(&amp;handle_encoding);<br>      meta_index_block.Add(key, handle_encoding);<br>    &#125;<br><br>    <span class="hljs-comment">// TODO(postrelease): Add stats and other meta blocks</span><br>    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);<br>  &#125;<br><br>  <span class="hljs-comment">// Write index block</span><br>  <span class="hljs-keyword">if</span> (ok()) &#123;<br>    <span class="hljs-keyword">if</span> (r-&gt;pending_index_entry) &#123;<br>      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> handle_encoding;<br>      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);<br>      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));<br>      r-&gt;pending_index_entry = <span class="hljs-literal">false</span>;<br>    &#125;<br>    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);<br>  &#125;<br><br>  <span class="hljs-comment">// Write footer</span><br>  <span class="hljs-keyword">if</span> (ok()) &#123;<br>    Footer footer;<br>    footer.set_metaindex_handle(metaindex_block_handle);<br>    footer.set_index_handle(index_block_handle);<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> footer_encoding;<br>    footer.EncodeTo(&amp;footer_encoding);<br>    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);<br>    <span class="hljs-keyword">if</span> (r-&gt;status.ok()) &#123;<br>      r-&gt;offset += footer_encoding.size();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> r-&gt;status;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Footer</code> 中有一些什么信息？</p><blockquote><p>Footer中记录了metaindex_block和index_block的位置，以及一个魔数magic number。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析8-SSTable(2)</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%908-sstable(2)/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%908-sstable(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="sstable的遍历"><a href="#sstable的遍历" class="headerlink" title="sstable的遍历"></a>sstable的遍历</h2><p>这一讲主要介绍是如何遍历sstable的，主要介绍迭代器部分。</p><p>首先是如何打开一个sstable文件</p><p>对于一个sstable文件，我们先读取它的<code>Footer</code> 。然后根据它的<code>Footer</code> 知道这个sstable的<code>metaindex_handle_</code> 和 <code>index_handle_</code> 信息，进而就可以解析整个sstable文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Table::Open</span><span class="hljs-params">(<span class="hljs-type">const</span> Options&amp; options, RandomAccessFile* file,</span><br><span class="hljs-params">                   <span class="hljs-type">uint64_t</span> size, Table** table)</span> &#123;<br>  *table = nullptr;<br>  <span class="hljs-keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;<br>    <span class="hljs-keyword">return</span> Status::Corruption(<span class="hljs-string">&quot;file is too short to be an sstable&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-type">char</span> footer_space[Footer::kEncodedLength];<br>  Slice footer_input;<br>  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,<br>                        &amp;footer_input, footer_space);<br>  <span class="hljs-keyword">if</span> (!s.ok()) <span class="hljs-keyword">return</span> s;<br><br>  Footer footer;<br>  s = footer.DecodeFrom(&amp;footer_input);<br>  <span class="hljs-keyword">if</span> (!s.ok()) <span class="hljs-keyword">return</span> s;<br><br>  <span class="hljs-comment">// Read the index block</span><br>  BlockContents index_block_contents;<br>  ReadOptions opt;<br>  <span class="hljs-keyword">if</span> (options.paranoid_checks) &#123;<br>    opt.verify_checksums = <span class="hljs-literal">true</span>;<br>  &#125;<br>  s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);<br><br>  <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>    <span class="hljs-comment">// We&#x27;ve successfully read the footer and the index block: we&#x27;re</span><br>    <span class="hljs-comment">// ready to serve requests.</span><br>    Block* index_block = new Block(index_block_contents);<br>    Rep* rep = new Table::Rep;<br>    rep-&gt;options = options;<br>    rep-&gt;file = file;<br>    rep-&gt;metaindex_handle = footer.metaindex_handle();<br>    rep-&gt;index_block = index_block;<br>    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="hljs-number">0</span>);<br>    rep-&gt;filter_data = nullptr;<br>    rep-&gt;filter = nullptr;<br>    *table = new Table(rep);<br>    (*table)-&gt;ReadMeta(footer);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是如何创建一个遍历<code>table</code> 的迭代器。这里使用了<code>TwoLevelIterator</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Iterator* <span class="hljs-title function_">Table::NewIterator</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options)</span> <span class="hljs-type">const</span> &#123;<br>  <span class="hljs-keyword">return</span> NewTwoLevelIterator(<br>      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),<br>      &amp;Table::BlockReader, const_cast&lt;Table*&gt;(this), options);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Iterator* <span class="hljs-title function_">NewTwoLevelIterator</span><span class="hljs-params">(Iterator* index_iter, BlockFunction block_function, <span class="hljs-type">void</span>* arg,</span><br><span class="hljs-params">                              <span class="hljs-type">const</span> ReadOptions&amp; options)</span> &#123;<br>  <span class="hljs-keyword">return</span> new TwoLevelIterator(index_iter, block_function, arg, options);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为什么要叫<code>TwoLevelIterator</code> 呢？</p><p>不仅可以迭代其中存储的对象，它还接受了一个函数<strong>BlockFunction</strong>，可以遍历存储的对象，可见它是专门为<strong>Table定制</strong>的。 我们已经知道各种Block的<strong>存储格式</strong>都是<strong>相同</strong>的，但是各自block data存储的<strong>k&#x2F;v</strong>又<strong>互不相同</strong>，于是我们就需要一个途径，能够在使用同一个方式<strong>遍历</strong>不同的block时，又能<strong>解析</strong>这些k&#x2F;v。</p><p><code>TwoLevelIterator</code> 类的主要成员变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">BlockFunction block_function_; <span class="hljs-comment">// block操作函数  </span><br><span class="hljs-type">void</span>* arg_;                    <span class="hljs-comment">// BlockFunction的自定义参数  </span><br><span class="hljs-type">const</span> ReadOptions options_;    <span class="hljs-comment">// BlockFunction的read option参数  </span><br>Status status_;                <span class="hljs-comment">// 当前状态  </span><br>IteratorWrapper index_iter_;   <span class="hljs-comment">// 遍历block的迭代器  </span><br>IteratorWrapper data_iter_;    <span class="hljs-comment">// May be NULL-遍历block data的迭代器  </span><br><span class="hljs-comment">// 如果data_iter_ != NULL，data_block_handle_保存的是传递给  </span><br><span class="hljs-comment">// block_function_的index value，以用来创建data_iter_  </span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data_block_handle_; <br></code></pre></td></tr></table></figure><p><strong>在分析Seek系函数之前</strong>，有必要先了解下面这几个函数的用途。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitDataBlock</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">SetDataIterator</span><span class="hljs-params">(Iterator*data_iter)</span>; <br><span class="hljs-type">void</span> <span class="hljs-title function_">SkipEmptyDataBlocksForward</span><span class="hljs-params">()</span>;  <br><span class="hljs-type">void</span> <span class="hljs-title function_">SkipEmptyDataBlocksBackward</span><span class="hljs-params">()</span>; <br></code></pre></td></tr></table></figure><ol><li>首先是InitDataBlock()，它是根据<code>index_iter</code>来初始化<code>data_iter</code>，当定位到新的block时，需要更新data Iterator，指向该block中k&#x2F;v对的合适位置。这里主要调用了<code>block_function_</code> 函数(<code>BlockReader</code> )，参数<code>args_</code> 是结构体<code>Table</code> 的指针，<code>handle</code> 是需要定位的<code>offset</code> 和 <code>size</code> ，<code>BlockReader</code> 函数就是根据<code>Table</code> (<code>arg_</code> )里面的<code>Rep</code> 中的<code>File</code> 信息以及<code>handle</code> 来读取一个完整的Block的。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TwoLevelIterator::InitDataBlock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (!index_iter_.Valid()) &#123;<br>    SetDataIterator(nullptr);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    Slice handle = index_iter_.value();<br>    <span class="hljs-keyword">if</span> (data_iter_.iter() != nullptr &amp;&amp;<br>        handle.compare(data_block_handle_) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// data_iter_ is already constructed with this iterator, so</span><br>      <span class="hljs-comment">// no need to change anything</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Iterator* iter = (*block_function_)(arg_, options_, handle);<br>      data_block_handle_.assign(handle.data(), handle.size());<br>      SetDataIterator(iter);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>SkipEmptyDataBlocksForward，向前跳过空的datablock。</p><p>实现思路也就是用一个while循环不断判断该data block是否有效，如果无效，那就<code>index_iter_</code> 需要调用<code>Next</code> 方法，同时调用上面讲到的<code>InitDataBlock</code> 函数把<code>data_iter</code> 也指向新的data block对象。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TwoLevelIterator::SkipEmptyDataBlocksForward</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (data_iter_.iter() == nullptr || !data_iter_.Valid()) &#123;<br>    <span class="hljs-comment">// Move to next block</span><br>    <span class="hljs-keyword">if</span> (!index_iter_.Valid()) &#123;<br>      SetDataIterator(nullptr);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    index_iter_.Next();<br>    InitDataBlock();<br>    <span class="hljs-keyword">if</span> (data_iter_.iter() != nullptr) data_iter_.SeekToFirst();<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li>SkipEmptyDataBlocksBackward，向后跳过空的datablock</li></ol><h3 id="Seek函数"><a href="#Seek函数" class="headerlink" title="Seek函数"></a>Seek函数</h3><ol><li>首先把<code>index_iter</code> 定位到指定位置。</li></ol><blockquote><p>index_iter和data_iter没有本质区别，都是一个个kv键值对，都使用了前缀压缩来节省空间。但不一样的是，index_iter对应的index block 不需要重启点的信息。</p></blockquote><ol start="2"><li>然后再把<code>data_iter_</code> 跳转到指定的data block，并指向指定的kv键值对。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">TwoLevelIterator::Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; target)</span> &#123;<br>  index_iter_.Seek(target);<br>  InitDataBlock();<br>  <span class="hljs-keyword">if</span> (data_iter_.iter() != nullptr) data_iter_.Seek(target);<br>  SkipEmptyDataBlocksForward();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SeekToFirst函数"><a href="#SeekToFirst函数" class="headerlink" title="SeekToFirst函数"></a>SeekToFirst函数</h3><p>思路和实现也和上面差不多，就是移动<code>index_iter</code> 和<code>data_iter</code> 来实现的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void TwoLevelIterator::<span class="hljs-constructor">SeekToFirst()</span> <br>&#123;  <br>    index_iter_.<span class="hljs-constructor">SeekToFirst()</span>;  <br>    <span class="hljs-constructor">InitDataBlock()</span>;              <span class="hljs-comment">// 根据index iter设置data iter  </span><br>    <span class="hljs-keyword">if</span> (data_iter_.iter<span class="hljs-literal">()</span> != NULL)data_iter_.<span class="hljs-constructor">SeekToFirst()</span>;  <br>    <span class="hljs-constructor">SkipEmptyDataBlocksForward()</span>; <span class="hljs-comment">// 调整iter，跳过空的block  </span><br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析6-Block</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906-Block/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906-Block/</url>
    
    <content type="html"><![CDATA[<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>上一讲的BlockBuilder是在构建Block用到的结构体，它不提供访问元素的接口，只提供添加entry的一些接口。当我们在SST中构建好Block后，我们需要一些接口，或者是迭代器访问Block中的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iter</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* data_;<br><span class="hljs-type">size_t</span> size_;<br><span class="hljs-type">uint32_t</span> restart_offset_;  <span class="hljs-comment">// Offset in data_ of restart array</span><br><span class="hljs-type">bool</span> owned_;               <span class="hljs-comment">// Block owns data_[]</span><br></code></pre></td></tr></table></figure><p>其中<code>Iter</code> 是Block的迭代器，我们来看看<code>Iter</code> 是如何实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Block</span>:</span>:Iter : public Iterator &#123;<br> private:<br>  <span class="hljs-type">const</span> Comparator* <span class="hljs-type">const</span> comparator_;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> data_;       <span class="hljs-comment">// underlying block contents, block的内容</span><br>  <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> restarts_;      <span class="hljs-comment">// Offset of restart array (list of fixed32)</span><br>  <span class="hljs-type">uint32_t</span> <span class="hljs-type">const</span> num_restarts_;  <span class="hljs-comment">// Number of uint32_t entries in restart array</span><br><br>  <span class="hljs-type">uint32_t</span> current_;        <span class="hljs-comment">// current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid</span><br>  <span class="hljs-type">uint32_t</span> restart_index_;  <span class="hljs-comment">// Index of restart block in which current_ falls</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> key_;<br>  Slice value_;<br>  Status status_;<br>....<br>....<br></code></pre></td></tr></table></figure><h2 id="迭代器访问的接口"><a href="#迭代器访问的接口" class="headerlink" title="迭代器访问的接口"></a>迭代器访问的接口</h2><h3 id="Next方法"><a href="#Next方法" class="headerlink" title="Next方法"></a>Next方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Next</span><span class="hljs-params">()</span> override &#123;<br>    assert(Valid());<br>    ParseNextKey();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">ParseNextKey</span><span class="hljs-params">()</span> &#123;<br>    current_ = NextEntryOffset();<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = data_ + current_;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit = data_ + restarts_;  <span class="hljs-comment">// Restarts come right after data</span><br>    <span class="hljs-keyword">if</span> (p &gt;= limit) &#123;<br>      <span class="hljs-comment">// No more entries to return.  Mark as invalid.</span><br>      current_ = restarts_;<br>      restart_index_ = num_restarts_;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Decode next entry</span><br>    <span class="hljs-type">uint32_t</span> shared, non_shared, value_length;<br>    p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length);<br>    <span class="hljs-keyword">if</span> (p == nullptr || key_.size() &lt; shared) &#123;<br>      CorruptionError();<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      key_.resize(shared);<br>      key_.append(p, non_shared);<br>      value_ = Slice(p + non_shared, value_length);<br>      <span class="hljs-keyword">while</span> (restart_index_ + <span class="hljs-number">1</span> &lt; num_restarts_ &amp;&amp;<br>             GetRestartPoint(restart_index_ + <span class="hljs-number">1</span>) &lt; current_) &#123;<br>        ++restart_index_;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>首先来看<code>DecodeEntry</code>函数，根据上面的结构图，我们看到，首先解析出<code>shared</code> 、<code>non_shared</code> 、<code>value_length</code> 的长度，然后<code>p</code> 指针来到了<code>non_shared</code> 的 key 的部分。然后<code>key_.resize(shared);key_.append(p, non_shared);</code> 由于key是上一个key的值，<code>resize</code> 和<code>append</code> 后就变成了当前的key的值。</p><p>然后我们就可以移动重启点<code>restart_index_</code> 的位置了。</p><p>这一部分的代码在清楚了Block的结构之后还是很显而易见的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">DecodeEntry</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit,</span><br><span class="hljs-params">                                      <span class="hljs-type">uint32_t</span>* shared, <span class="hljs-type">uint32_t</span>* non_shared,</span><br><span class="hljs-params">                                      <span class="hljs-type">uint32_t</span>* value_length)</span> &#123;<br>  <span class="hljs-keyword">if</span> (limit - p &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> nullptr;<br>  *shared = reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(p)[<span class="hljs-number">0</span>];<br>  *non_shared = reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(p)[<span class="hljs-number">1</span>];<br>  *value_length = reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span>*&gt;(p)[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="hljs-number">128</span>) &#123;<br>    <span class="hljs-comment">// Fast path: all three values are encoded in one byte each</span><br>    p += <span class="hljs-number">3</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> ((p = GetVarint32Ptr(p, limit, shared)) == nullptr) <span class="hljs-keyword">return</span> nullptr;<br>    <span class="hljs-keyword">if</span> ((p = GetVarint32Ptr(p, limit, non_shared)) == nullptr) <span class="hljs-keyword">return</span> nullptr;<br>    <span class="hljs-keyword">if</span> ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) &#123;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Prev方法"><a href="#Prev方法" class="headerlink" title="Prev方法"></a>Prev方法</h3><p>如何进行向后遍历呢？Prev操作分为两步：</p><ol><li>首先回到current_之前的重启点(这个重启点的offset要严格小于当前<code>current </code> 的offset)</li><li><em>然后再向后直到current</em> ,(不断调用<code>ParseNextKey</code> 和 <code>NextEntryOffset</code> 函数)</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Prev</span><span class="hljs-params">()</span> override &#123;<br>    assert(Valid());<br>    <span class="hljs-comment">// Scan backwards to a restart point before current_</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> original = current_;<br>    <span class="hljs-keyword">while</span> (GetRestartPoint(restart_index_) &gt;= original) &#123;<br>      <span class="hljs-keyword">if</span> (restart_index_ == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// No more entries</span><br>        current_ = restarts_;<br>        restart_index_ = num_restarts_;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      restart_index_--;<br>    &#125;<br><br>    SeekToRestartPoint(restart_index_);<br>    <span class="hljs-keyword">do</span> &#123;<br>      <span class="hljs-comment">// Loop until end of current entry hits the start of original entry</span><br>    &#125; <span class="hljs-keyword">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; original);<br>  &#125;<br><br></code></pre></td></tr></table></figure><h3 id="SeekToFirst-Last函数"><a href="#SeekToFirst-Last函数" class="headerlink" title="SeekToFirst&#x2F;Last函数"></a>SeekToFirst&#x2F;Last函数</h3><p>这两个函数都很简单，借助于前面的SeekToResartPoint函数就可以完成。</p><h3 id="Seek函数"><a href="#Seek函数" class="headerlink" title="Seek函数"></a>Seek函数</h3><p>跳到指定的target(Slice)，这里主要是二分查找和线性查找的思路</p><ol><li>找到key &lt; target的最后一个重启点，典型的二分查找算法，代码就不再贴了。</li><li>找到后，跳转到重启点，其索引由left指定，这是前面二分查找到的结果。</li><li>自重启点线性向下，直到遇到key&gt;&#x3D; target的k&#x2F;v对。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; target)</span> override &#123;<br>    <span class="hljs-comment">// Binary search in restart array to find the last restart point</span><br>    <span class="hljs-comment">// with a key &lt; target</span><br>    <span class="hljs-type">uint32_t</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> right = num_restarts_ - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> current_key_compare = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (Valid()) &#123;<br>      <span class="hljs-comment">// If we&#x27;re already scanning, use the current position as a starting</span><br>      <span class="hljs-comment">// point. This is beneficial if the key we&#x27;re seeking to is ahead of the</span><br>      <span class="hljs-comment">// current position.</span><br>      current_key_compare = Compare(key_, target);<br>      <span class="hljs-keyword">if</span> (current_key_compare &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// key_ is smaller than target</span><br>        left = restart_index_;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current_key_compare &gt; <span class="hljs-number">0</span>) &#123;<br>        right = restart_index_;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// We&#x27;re seeking to the key we&#x27;re already at.</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>      <span class="hljs-type">uint32_t</span> mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>      <span class="hljs-type">uint32_t</span> region_offset = GetRestartPoint(mid);<br>      <span class="hljs-type">uint32_t</span> shared, non_shared, value_length;<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_ptr =<br>          DecodeEntry(data_ + region_offset, data_ + restarts_, &amp;shared,<br>                      &amp;non_shared, &amp;value_length);<br>      <span class="hljs-keyword">if</span> (key_ptr == nullptr || (shared != <span class="hljs-number">0</span>)) &#123;<br>        CorruptionError();<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      Slice <span class="hljs-title function_">mid_key</span><span class="hljs-params">(key_ptr, non_shared)</span>;<br>      <span class="hljs-keyword">if</span> (Compare(mid_key, target) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Key at &quot;mid&quot; is smaller than &quot;target&quot;.  Therefore all</span><br>        <span class="hljs-comment">// blocks before &quot;mid&quot; are uninteresting.</span><br>        left = mid;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Key at &quot;mid&quot; is &gt;= &quot;target&quot;.  Therefore all blocks at or</span><br>        <span class="hljs-comment">// after &quot;mid&quot; are uninteresting.</span><br>        right = mid - <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// We might be able to use our current position within the restart block.</span><br>    <span class="hljs-comment">// This is true if we determined the key we desire is in the current block</span><br>    <span class="hljs-comment">// and is after than the current key.</span><br>    assert(current_key_compare == <span class="hljs-number">0</span> || Valid());<br>    <span class="hljs-type">bool</span> skip_seek = left == restart_index_ &amp;&amp; current_key_compare &lt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!skip_seek) &#123;<br>      SeekToRestartPoint(left);<br>    &#125;<br>    <span class="hljs-comment">// Linear search (within restart block) for first key &gt;= target</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!ParseNextKey()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (Compare(key_, target) &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析4-Memtable(2)</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-Memtable(2)/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-Memtable(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="Memtable-2"><a href="#Memtable-2" class="headerlink" title="Memtable(2)"></a><strong>Memtable(2)</strong></h2><p>这篇文章我们开始剖析<code>Memtable</code> 的代码实现和核心数据结构<code>SkipList</code> </p><p>相较于传统的链表，跳表采取空间换时间的策略，建立多层索引，实现了查找和插入都只需要logn级别的优化。</p><p><code>SkipList</code> 的结构如下所示：</p><img src="/img/leveldb/skiplist-1.png" style="zoom: 50%;"><h2 id="SkipList的结构"><a href="#SkipList的结构" class="headerlink" title="SkipList的结构"></a><strong>SkipList的结构</strong></h2><p>LevelDB 跳表代码上，主要涉及 C++11 中 atomic 标准库中新支持的几种 memory order，规定了一些指令重排方面的限制，仅说明下用到的三种：</p><ol><li><code>std::memory_order_relaxed</code>：不对重排做限制，只保证相关共享内存访问的原子性。</li><li><code>std::memory_order_acquire</code>: 用在 load 时，保证同线程中该 load 之后的对相关内存读写语句不会被重排到 load 之前，并且其他线程中对同样内存用了 store release 都对其可见。</li><li><code>std::memory_order_release</code>：用在 store 时，保证同线程中该 store 之后的对相关内存的读写语句不会被重排到 store 之前，并且该线程的所有修改对用了 load acquire 的其他线程都可见。</li></ol><p><code>skiplist</code> 是由一个个的<code>Node</code> 结构体构成的，每一个<code>Node</code> 都有一个<code>Next_</code> 的数组，指向不同层级索引的下一个<code>Node</code> 的位置。、</p><blockquote><p>这里<code>std::atomic&lt;Node*&gt; next_[1]</code> 用到了柔性数组，就是利用malloc可以实现多层级的索引的效果。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename Key, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comparator</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SkipList</span>&lt;</span>Key, Comparator&gt;::Node &#123;<br>  explicit <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; k)</span> : <span class="hljs-title function_">key</span><span class="hljs-params">(k)</span> &#123;&#125;<br><br>  Key <span class="hljs-type">const</span> key;<br><br>  <span class="hljs-comment">// Accessors/mutators for links.  Wrapped in methods so we can</span><br>  <span class="hljs-comment">// add the appropriate barriers as necessary.</span><br>  Node* <span class="hljs-title function_">Next</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    assert(n &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// Use an &#x27;acquire load&#x27; so that we observe a fully initialized</span><br>    <span class="hljs-comment">// version of the returned Node.</span><br>    <span class="hljs-keyword">return</span> next_[n].load(<span class="hljs-built_in">std</span>::memory_order_acquire);<br>  &#125;<br>  <span class="hljs-type">void</span> <span class="hljs-title function_">SetNext</span><span class="hljs-params">(<span class="hljs-type">int</span> n, Node* x)</span> &#123;<br>    assert(n &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// Use a &#x27;release store&#x27; so that anybody who reads through this</span><br>    <span class="hljs-comment">// pointer observes a fully initialized version of the inserted node.</span><br>    next_[n].store(x, <span class="hljs-built_in">std</span>::memory_order_release);<br>  &#125;<br><br>  <span class="hljs-comment">// No-barrier variants that can be safely used in a few locations.</span><br>  Node* <span class="hljs-title function_">NoBarrier_Next</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    assert(n &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> next_[n].load(<span class="hljs-built_in">std</span>::memory_order_relaxed);<br>  &#125;<br>  <span class="hljs-type">void</span> <span class="hljs-title function_">NoBarrier_SetNext</span><span class="hljs-params">(<span class="hljs-type">int</span> n, Node* x)</span> &#123;<br>    assert(n &gt;= <span class="hljs-number">0</span>);<br>    next_[n].store(x, <span class="hljs-built_in">std</span>::memory_order_relaxed);<br>  &#125;<br><br> private:<br>  <span class="hljs-comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span><br>  <span class="hljs-built_in">std</span>::atomic&lt;Node*&gt; next_[<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h3><p>查找是插入的基础，每个节点要先找到合适位置，才能进行插入。因此 LevelDB 抽象出了一个公用函数： <code>FindGreaterOrEqual</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename Key, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comparator</span>&gt;</span><br><span class="hljs-type">bool</span> SkipList&lt;Key, Comparator&gt;::Contains(<span class="hljs-type">const</span> Key&amp; key) <span class="hljs-type">const</span> &#123;<br>  Node* x = FindGreaterOrEqual(key, nullptr);<br>  <span class="hljs-keyword">if</span> (x != nullptr &amp;&amp; Equal(key, x-&gt;key)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的含义为：在跳表中查找不小于给 Key 的第一个值，如果没有找到，则返回 nullptr。如果参数 <code>prev</code> 不为空，在查找过程中，记下待查找节点在各层中的前驱节点。显然，如果查找操作，则指定 <code>prev = nullptr</code> 即可；若要插入数据，则需传入一个合适尺寸的 <code>prev</code> 参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename Key, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comparator</span>&gt;</span><br>typename SkipList&lt;Key, Comparator&gt;::Node*<br>SkipList&lt;Key, Comparator&gt;::FindGreaterOrEqual(<span class="hljs-type">const</span> Key&amp; key, Node** prev) <span class="hljs-type">const</span> &#123;<br>  Node* x = head_;                <span class="hljs-comment">// 从头结点开始查找</span><br>  <span class="hljs-type">int</span> level = GetMaxHeight() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 从最高层开始查找</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Node* next = x-&gt;Next(level);  <span class="hljs-comment">// 该层中下一个节点</span><br>    <span class="hljs-keyword">if</span> (KeyIsAfterNode(key, next)) &#123;<br>      x = next;                   <span class="hljs-comment">// 待查找 key 比 next 大，则在该层继续查找</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (prev != nullptr) prev[level] = x;<br><br>      <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>) &#123;           <span class="hljs-comment">// 待查找 key 不大于 next，则到底返回</span><br>        <span class="hljs-keyword">return</span> next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// 待查找 key 不大于 next，且没到底，则往下查找</span><br>        level--;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a><strong>插入</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">template &lt;typename Key, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comparator</span>&gt;</span><br><span class="hljs-type">void</span> SkipList&lt;Key, Comparator&gt;::Insert(<span class="hljs-type">const</span> Key&amp; key) &#123;<br>  <span class="hljs-comment">// 待做(opt): 由于插入要求外部加锁，因此可以使用 NoBarrier_Next 的 FindGreaterOrEqual 以提高性能</span><br>  Node* prev[kMaxHeight]; <span class="hljs-comment">// 长度设定简单粗暴，直接取最大值（kMaxHeight = 12）肯定没错。</span><br>  Node* x = FindGreaterOrEqual(key, prev);<br><br>  <span class="hljs-comment">// LevelDB 跳表要求不能插入重复数据</span><br>  assert(x == nullptr || !Equal(key, x-&gt;key));<br><br>  <span class="hljs-type">int</span> height = RandomHeight(); <span class="hljs-comment">// 随机获取一个 level 值</span><br>  <span class="hljs-keyword">if</span> (height &gt; GetMaxHeight()) &#123; <span class="hljs-comment">// GetMaxHeight() 为获取跳表当前</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = GetMaxHeight(); i &lt; height; i++) &#123;<br>      prev[i] = head_;<br>    &#125;<br>    <span class="hljs-comment">// 此处不用为并发读加锁。因为并发读在（在另外线程中通过 FindGreaterOrEqual 中的 GetMaxHeight）</span><br>    <span class="hljs-comment">// 读取到更新后跳表层数，但该节点尚未插入时也无妨。因为这意味着它会读到 nullptr，而在 LevelDB</span><br>    <span class="hljs-comment">// 的 Comparator 设定中，nullptr 比所有 key 都大。因此，FindGreaterOrEqual 会继续往下找，</span><br>    <span class="hljs-comment">// 符合预期。</span><br>    max_height_.store(height, <span class="hljs-built_in">std</span>::memory_order_relaxed);<br>  &#125;<br><br>  x = NewNode(key, height);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>    <span class="hljs-comment">// 此句 NoBarrier_SetNext() 版本就够用了，因为后续 prev[i]-&gt;SetNext(i, x) 语句会进行强制同步。</span><br>    <span class="hljs-comment">// 并且为了保证并发读的正确性，一定要先设置本节点指针，再设置原条表中节点（prev）指针</span><br>    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));<br>    prev[i]-&gt;SetNext(i, x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析5-BlockBuilder</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-BlockBuilder/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-BlockBuilder/</url>
    
    <content type="html"><![CDATA[<h2 id="BlockBuilder"><a href="#BlockBuilder" class="headerlink" title="BlockBuilder"></a>BlockBuilder</h2><p>在讲解sstable之前，我们先来看一下Block结构体的内容。</p><p>Block由一条条的data_entry(前缀压缩)，以及重启点数组，重启点数组的大小还有5字节的crc32与一个type组成。所以我们解析一个block是很容易的。首先由于最后5个字节是crc32和type，所以可以找到重启点数组大小从而定位到重启点数组的开始位置，进而每一个data_entry都可以解析出来了。</p><ul><li>BlockBuilder结构体成员：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> Options* options_;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> buffer_;              <span class="hljs-comment">// Destination buffer</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">uint32_t</span>&gt; restarts_;  <span class="hljs-comment">// Restart points</span><br><span class="hljs-type">int</span> counter_;                     <span class="hljs-comment">// Number of entries emitted since restart</span><br><span class="hljs-type">bool</span> finished_;                   <span class="hljs-comment">// Has Finish() been called?</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> last_key_;<br></code></pre></td></tr></table></figure><img src="/img/leveldb/block.png" style="zoom:33%;"><p><strong>BlockBuilder</strong>对key的存储是前缀压缩的，对于有序的字符串来讲，这能极大的减少存储空间。但是却增加了查找的时间复杂度，为了兼顾查找效率，每隔K个key，leveldb就不使用前缀压缩，而是存储整个key，这就是<strong>重启点</strong><br>在构建Block时，有参数Options::block_restart_interval定每隔几个key就直接存储一个重启点key。</p><p>对于一个k&#x2F;v对，其在block中的存储格式为：</p><ul><li>共享前缀长度 shared_bytes: varint32</li><li>前缀之后的字符串长度 unshared_bytes: varint32</li><li>值的长度 value_length: varint32</li><li>前缀之后的字符串 key_delta: char[unshared_bytes]</li><li>值 value: char[value_length]</li></ul><h3 id="Block的相关接口"><a href="#Block的相关接口" class="headerlink" title="Block的相关接口"></a>Block的相关接口</h3><ul><li>Add接口</li></ul><p>这个Add函数没有什么好解释的，就是如果<code>count_</code> 等于<code>block_restart_interval</code> ，就不需要计算前缀，否则需要计算前缀。然后就往<code>buffer_</code> 中写入即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BlockBuilder::Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> &#123;<br>  Slice <span class="hljs-title function_">last_key_piece</span><span class="hljs-params">(last_key_)</span>;<br>  assert(!finished_);<br>  assert(counter_ &lt;= options_-&gt;block_restart_interval);<br>  assert(buffer_.empty()  <span class="hljs-comment">// No values yet?</span><br>         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-type">size_t</span> shared = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;<br>    <span class="hljs-comment">// See how much sharing to do with previous string</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> min_length = <span class="hljs-built_in">std</span>::min(last_key_piece.size(), key.size());<br>    <span class="hljs-keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;<br>      shared++;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Restart compression</span><br>    restarts_.push_back(buffer_.size());<br>    counter_ = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> non_shared = key.size() - shared;<br><br>  <span class="hljs-comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_</span><br>  PutVarint32(&amp;buffer_, shared);<br>  PutVarint32(&amp;buffer_, non_shared);<br>  PutVarint32(&amp;buffer_, value.size());<br><br>  <span class="hljs-comment">// Add string delta to buffer_ followed by value</span><br>  buffer_.append(key.data() + shared, non_shared);<br>  buffer_.append(value.data(), value.size());<br><br>  <span class="hljs-comment">// Update state</span><br>  last_key_.resize(shared);<br>  last_key_.append(key.data() + shared, non_shared);<br>  assert(Slice(last_key_) == key);<br>  counter_++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Finish接口</li></ul><p>当data_entry条目已经写完了时，就需要往<code>buffer_</code> 里面写入重启点数组和重启点数组的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">Slice <span class="hljs-title function_">BlockBuilder::Finish</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// Append restart array</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; restarts_.size(); i++) &#123;<br>    PutFixed32(&amp;buffer_, restarts_[i]);<br>  &#125;<br>  PutFixed32(&amp;buffer_, restarts_.size());<br>  finished_ = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> Slice(buffer_);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析3-Memtable(1)</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-Memtable(1)/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903-Memtable(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="Memtable-1"><a href="#Memtable-1" class="headerlink" title="Memtable(1)"></a>Memtable(1)</h2><p>对应文件：<code>memtable.h</code>和<code>memtable.cc</code></p><p>每个 LevelDB 实例最多会维护两个 MemTable： mem_ 和 imm_。mem_ 可以读写，imm_ 只读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">MemTable* mem_;<br>MemTable* imm_ <span class="hljs-title function_">GUARDED_BY</span><span class="hljs-params">(mutex_)</span>;  <span class="hljs-comment">// Memtable being compacted</span><br></code></pre></td></tr></table></figure><p>LevelDB 的 MemTable 的主要功能是将内部编码、内存分配（Arena）和 SkipList 封装在一起。</p><p>leveldb::MemTable 主要支持的操作有：</p><p>插入单条记录：Add。<br>查询单条记录：Get。<br>遍历（范围查询）：MemTableIterator。</p><h3 id="Memtable中的KV"><a href="#Memtable中的KV" class="headerlink" title="Memtable中的KV"></a>Memtable中的KV</h3><p>Memtable提供了写入KV记录，删除以及读取KV记录的接口，但是事实上**Memtable并不执行真正的删除操作,**删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作在后面的 Compaction过程中。<br>Memtable中的核心数据结构是skiplist，KV对是根据Key排序的，leveldb在插入等操作时保证key的有序性。那么skiplist是如何组织KV数据条目的呢?</p><ol><li>InternalKey<br>InternalKey是一个复合概念，是有几个部分组合成的一个key，ParsedInternalKey就是对InternalKey分拆后的结果(本质是一个东西)<br>InternalKey是由User key + SequenceNumber + ValueType组合而成的<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">| <span class="hljs-keyword">User</span> <span class="hljs-title">key</span> (<span class="hljs-keyword">string</span>) | sequence <span class="hljs-keyword">number</span> (<span class="hljs-number">7</span> bytes) | value <span class="hljs-keyword">type</span> (<span class="hljs-number">1</span> byte) |<br></code></pre></td></tr></table></figure><img src="/img/leveldb/key_structure.png" style="zoom: 33%;"></li></ol><p><code>InternalKey</code> 按照 user key 从小到大，sequence number 从大到小进行排序。</p><ol start="2"><li>LookupKey<br>这是用户用来查询的key。</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">| Size (int32变长)| <span class="hljs-keyword">User</span> <span class="hljs-title">key</span> (<span class="hljs-keyword">string</span>) | sequence <span class="hljs-keyword">number</span> (<span class="hljs-number">7</span> bytes) | value <span class="hljs-keyword">type</span> (<span class="hljs-number">1</span> byte) |<br></code></pre></td></tr></table></figure><p>可以分别从LookupKey得到Internal Key，Memtable Key和User Key，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return a key suitable for lookup in a MemTable.</span><br>Slice <span class="hljs-title function_">memtable_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> Slice(start_, end_ - start_); &#125;<br><br><span class="hljs-comment">// Return an internal key (suitable for passing to an internal iterator)</span><br>Slice <span class="hljs-title function_">internal_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;<br><br><span class="hljs-comment">// Return the user key</span><br>Slice <span class="hljs-title function_">user_key</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <span class="hljs-keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="hljs-number">8</span>); &#125;<br></code></pre></td></tr></table></figure><p>这一部分可以看一下skiplist.h中的代码。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析2-编码</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E7%BC%96%E7%A0%81/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902-%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>Leveldb使用了很多VarInt型编码，典型的如后面将涉及到的各种key。其中的编码、解码函数分为VarInt和FixedInt两种。int32和int64操作都是类似的。</p><h3 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h3><ol><li><p>FixedInt编码：直接把32位整数存储在内存中。</p><blockquote><p>小端：低位放到低字节地址中，高位放在高字节地址中</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">EncodeFixed32</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">uint32_t</span> value)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (port::kLittleEndian) &#123;<br>    <span class="hljs-built_in">memcpy</span>(buf, &amp;value,<span class="hljs-keyword">sizeof</span>(value));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    buf[<span class="hljs-number">0</span>] = value &amp; <span class="hljs-number">0xff</span>;<br>    buf[<span class="hljs-number">1</span>] = (value &gt;&gt; <span class="hljs-number">8</span>)&amp; <span class="hljs-number">0xff</span>;<br>    buf[<span class="hljs-number">2</span>] = (value &gt;&gt; <span class="hljs-number">16</span>)&amp; <span class="hljs-number">0xff</span>;<br>    buf[<span class="hljs-number">3</span>] = (value &gt;&gt; <span class="hljs-number">24</span>)&amp; <span class="hljs-number">0xff</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>VarInt编码：<br>首先看代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">EncodeVarint32</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">uint32_t</span> v)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* ptr =reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(dst);<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;<br>  <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>)) &#123;<br>    *(ptr++) = v;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">14</span>))&#123;<br>    *(ptr++) = v | B;<br>    *(ptr++) = v&gt;&gt;<span class="hljs-number">7</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>))&#123;<br>    *(ptr++) = v | B;<br>    *(ptr++) = (v&gt;&gt;<span class="hljs-number">7</span>) | B;<br>    *(ptr++) = v&gt;&gt;<span class="hljs-number">14</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt; (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">28</span>))&#123;<br>    *(ptr++) = v | B;<br>    *(ptr++) = (v&gt;&gt;<span class="hljs-number">7</span>) | B;<br>    *(ptr++) = (v&gt;&gt;<span class="hljs-number">14</span>) | B;<br>    *(ptr++) = v&gt;&gt;<span class="hljs-number">21</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    *(ptr++) = v | B;<br>    *(ptr++) = (v&gt;&gt;<span class="hljs-number">7</span>) | B;<br>    *(ptr++) = (v&gt;&gt;<span class="hljs-number">14</span>) | B;<br>    *(ptr++) = (v&gt;&gt;<span class="hljs-number">21</span>) | B;<br>    *(ptr++) = v&gt;&gt;<span class="hljs-number">28</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> reinterpret_cast&lt;<span class="hljs-type">char</span>*&gt;(ptr);<br>&#125;<br><br><span class="hljs-comment">// 对于uint64，直接循环</span><br><span class="hljs-type">char</span>* <span class="hljs-title function_">EncodeVarint64</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">uint64_t</span> v)</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">128</span>;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* ptr =reinterpret_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(dst);<br>  <span class="hljs-keyword">while</span> (v &gt;= B) &#123;<br>    *(ptr++) = (v &amp; (B<span class="hljs-number">-1</span>)) |B;<br>    v &gt;&gt;= <span class="hljs-number">7</span>;<br>  &#125;<br>  *(ptr++) =static_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(v);<br>  returnreinterpret_cast&lt;<span class="hljs-type">char</span>*&gt;(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于32位整数，当用VarInt编码时，可能需要1、2、3、4、5个字节进行编码。<br>如当如果整数 v 小于 128（1&lt;&lt;7），则使用一个字节直接存储该整数。<br>如果整数 v 大于等于 128 且小于 16384（1&lt;&lt;14），则使用两个字节存储。第一个字节的最高位设置为1（| B），表示后面还有一个字节，然后将 v 的低7位存储在第一个字节的低7位中，将 v 的高7位存储在第二个字节中。<br>如果整数 v 大于等于 16384 且小于 2097152（1&lt;&lt;21），则使用三个字节存储。依次类推，直到五个字节。<br>64位的整数编码处理思路也是一样的。</p></li></ol><h3 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h3><ol><li>Fixed Int的Decode、<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">DecodeFixed32</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (port::kLittleEndian) &#123;<br>    <span class="hljs-type">uint32_t</span> result;<br>    <span class="hljs-comment">// gcc optimizes this to a plain load</span><br>    <span class="hljs-built_in">memcpy</span>(&amp;result, ptr,<span class="hljs-keyword">sizeof</span>(result));<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span>((static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(static_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(ptr[<span class="hljs-number">0</span>])))<br>        |(static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(static_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(ptr[<span class="hljs-number">1</span>])) &lt;&lt;<span class="hljs-number">8</span>)<br>        | (static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(static_cast&lt;unsignedchar&gt;(ptr[<span class="hljs-number">2</span>])) &lt;&lt; <span class="hljs-number">16</span>)<br>        |(static_cast&lt;<span class="hljs-type">uint32_t</span>&gt;(static_cast&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(ptr[<span class="hljs-number">3</span>])) &lt;&lt;<span class="hljs-number">24</span>));<br>  &#125;<br></code></pre></td></tr></table></figure></li></ol><p>再来看看VarInt的解码，很简单，依次读取1byte，直到最高位为0的byte结束，取低7bit，作(&lt;&lt;7)移位操作组合成Int。看代码.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">GetVarint32Ptr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p,</span><br><span class="hljs-params">                           <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit, </span><br><span class="hljs-params">                           <span class="hljs-type">uint32_t</span>* value)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (p &lt; limit) &#123;<br>    <span class="hljs-type">uint32_t</span> result =*(reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(p));<br>    <span class="hljs-keyword">if</span> ((result &amp; <span class="hljs-number">128</span>) == <span class="hljs-number">0</span>) &#123;<br>      *value = result;<br>      <span class="hljs-keyword">return</span> p + <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> GetVarint32PtrFallback(p,limit, value);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">GetVarint32PtrFallback</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* p,</span><br><span class="hljs-params">                                   <span class="hljs-type">const</span> <span class="hljs-type">char</span>* limit,</span><br><span class="hljs-params">                                   <span class="hljs-type">uint32_t</span>* value)</span><br>&#123;<br>  <span class="hljs-type">uint32_t</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> shift = <span class="hljs-number">0</span>; shift&lt;= <span class="hljs-number">28</span> &amp;&amp; p &lt; limit; shift += <span class="hljs-number">7</span>) &#123;<br>    <span class="hljs-type">uint32_t</span> byte =*(reinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*&gt;(p));<br>    p++;<br>    <span class="hljs-keyword">if</span> (byte &amp; <span class="hljs-number">128</span>) &#123; <span class="hljs-comment">// More bytes are present</span><br>      result |= ((byte &amp; <span class="hljs-number">127</span>)&lt;&lt; shift);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result |= (byte &lt;&lt;shift);<br>      *value = result;<br>      returnreinterpret_cast&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(p);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个的编码解码部分并不是leveldb的重点，但可以看出，leveldb为了提升效率，节约空间还是下了很多功夫的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析18-Recover</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9018-Recover/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9018-Recover/</url>
    
    <content type="html"><![CDATA[<h2 id="Manifest文件"><a href="#Manifest文件" class="headerlink" title="Manifest文件"></a><strong>Manifest文件</strong></h2><p>在介绍Recover机制前，我们先要看一下leveldb中的<code>Manifest</code> 文件。</p><p>我们知道，每次进行Compaction生成或删除SSTable文件时，都会生成一个新的版本。LevelDB 采用了增量式的存储方式，用 VersionEdit 记录每一个 Version 对上一个 Version 的变化情况。</p><p>Manifest 文件专用于记录版本信息。一个 Manifest 文件中，包含了多条Session Record。一个 Session Record 记录了从上一个版本至该版本的变化情况。每一个 Session Record 对应一个 VersionEdit，不断调用<code>Apply</code> 函数最终可以得到最新的版本信息。</p><p>问题：那么这样是不是会出现Manifest文件过大的问题呢？</p><blockquote><p>其中第一条 Session Record 包含当时LevelDB的全量版本信息。这是压缩Manifest文件的方式。</p></blockquote><p><code>descriptor_log_</code> 就是Manifest文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">descriptor_log_ = new <span class="hljs-built_in">log</span>::Writer(descriptor_file_, manifest_size);<br></code></pre></td></tr></table></figure><p>在第一次执行<code>LogAndApply</code> 函数（这个函数接受一个 VersionEdit，产生一个新的 Version）的时候，如果没有<code>descriptor_log_</code> 这个文件，那么就需要把当前版本的全量版本信息写入Manifest文件(这是上面替代的压缩Mainifest的方式)</p><blockquote><p>有一个参数<code>save_manifest</code> 就是判断这一方面逻辑的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// LogAndApply 函数</span><br><span class="hljs-keyword">if</span> (descriptor_log_ == nullptr) &#123;<br>    <span class="hljs-comment">// No reason to unlock *mu here since we only hit this path in the</span><br>    <span class="hljs-comment">// first call to LogAndApply (when opening the database).</span><br>    assert(descriptor_file_ == nullptr);<br>    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);<br>    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);<br>    <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>      descriptor_log_ = new <span class="hljs-built_in">log</span>::Writer(descriptor_file_);<br>      s = WriteSnapshot(descriptor_log_);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>其中<code>WriteSnapshot</code> 函数就是把当前版本<code>version_</code> 以 log 形式写入Manifest文件。</p><p>那么既然需要Manifest文件才可以恢复数据库，那么刚<code>DB::Open</code> 的时候，如何知道Manifest文件的路径呢？</p><blockquote><p>有一个文件叫做CURRENT，里面存放了Manifest文件的路径。</p></blockquote><h2 id="Recover机制"><a href="#Recover机制" class="headerlink" title="Recover机制"></a><strong>Recover机制</strong></h2><p>当我们打开一个数据库的时候，我们需要考虑一些什么，怎么样才能恢复到数据库原来的状态呢？</p><ol><li>首先需要恢复到原来的<code>version</code> 版本  (Manifest文件)</li><li>然后需要恢复没写入磁盘的内存中的<code>memtable</code> (WAL的log文件)</li></ol><p>理清了Recover的逻辑，我们先看如何恢复到最新的Version版本。</p><p><code>DBImpl::Recover -&gt; VersionSet::Recover</code>  ，主要逻辑在<code>VersionSet::Recover</code> 中，主要逻辑就是不断获取Manifest中的<code>VersionEdit</code> ，然后不断<code>Apply</code> 到<code>builder</code> 中得到最新的version。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">log</span>::Reader <span class="hljs-title function_">reader</span><span class="hljs-params">(file, &amp;reporter, <span class="hljs-literal">true</span> <span class="hljs-comment">/*checksum*/</span>,</span><br><span class="hljs-params">                       <span class="hljs-number">0</span> <span class="hljs-comment">/*initial_offset*/</span>)</span>;<br>    Slice record;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> scratch;<br>    <span class="hljs-keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;<br>      ++read_records;<br>      VersionEdit edit;<br>      s = edit.DecodeFrom(record);<br>      <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>        <span class="hljs-keyword">if</span> (edit.has_comparator_ &amp;&amp;<br>            edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;<br>          s = Status::InvalidArgument(<br>              edit.comparator_ + <span class="hljs-string">&quot; does not match existing comparator &quot;</span>,<br>              icmp_.user_comparator()-&gt;Name());<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>        builder.Apply(&amp;edit);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (edit.has_log_number_) &#123;<br>        log_number = edit.log_number_;<br>        have_log_number = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (edit.has_prev_log_number_) &#123;<br>        prev_log_number = edit.prev_log_number_;<br>        have_prev_log_number = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (edit.has_next_file_number_) &#123;<br>        next_file = edit.next_file_number_;<br>        have_next_file = <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (edit.has_last_sequence_) &#123;<br>        last_sequence = edit.last_sequence_;<br>        have_last_sequence = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后就开始恢复<code>memtable</code> ，要恢复哪一些日志文件呢？</p><ol><li>首先获取该版本的所有文件，筛选出所有的Log文件(number &gt;&#x3D; min_log)</li><li>把所有Log文件进行排序，再对所有文件进行<code>RecoverLogFile</code> 恢复日志</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; filenames.size(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;<br>      expected.erase(number);<br>      <span class="hljs-keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))<br>        logs.push_back(number);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!expected.empty()) &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">50</span>];<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;%d missing files; e.g.&quot;</span>,<br>                  static_cast&lt;<span class="hljs-type">int</span>&gt;(expected.size()));<br>    <span class="hljs-keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));<br>  &#125;<br><br>  <span class="hljs-comment">// Recover in the order in which the logs were generated</span><br>  <span class="hljs-built_in">std</span>::sort(logs.begin(), logs.end());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; logs.size(); i++) &#123;<br>    s = RecoverLogFile(logs[i], (i == logs.size() - <span class="hljs-number">1</span>), save_manifest, edit,<br>                       &amp;max_sequence);<br>    <span class="hljs-keyword">if</span> (!s.ok()) &#123;<br>      <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    versions_-&gt;MarkFileNumberUsed(logs[i]);<br>  &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析17-WAL机制</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9017-WAL%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9017-WAL%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="预写日志-WAL-背景"><a href="#预写日志-WAL-背景" class="headerlink" title="预写日志(WAL)背景"></a><strong>预写日志(WAL)背景</strong></h2><p>LevelDB每次写key-value不会直接写到文件中，而是先暂存在Memtable中，Memtable写满后再写到文件中。如果发生故障(比如宕机)，保存在Memtable中的key-value就会全部丢失（内存是易失性存储）。所以为了保证数据的原子性和持久性，每次写key-value要预写日志，日志落盘后才会把key-value插入Memtable。日志文件和Memtable是一一对应的，Memtable落盘后，日志文件也会被删除。</p><p>LevelDB实现了一个Writer类来执行预写日志，这个Writer可以理解为一个日志文件对象，名称和DBImpl::Writer重复了，但是这两个没关系。本文提到的Writer的定义在db&#x2F;log_writer.h中。</p><p>在<code>DBImpl::Write</code> 函数把内容写入到memtable之前，首先会把这些内容写入日志</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));<br></code></pre></td></tr></table></figure><h2 id="日志的格式"><a href="#日志的格式" class="headerlink" title="日志的格式"></a><strong>日志的格式</strong></h2><p>LevelDB的Log是由Record和一些为了对齐而填充的gap组成的文件。</p><p>LevelDB在读取Log文件时，为了减少I&#x2F;O次数，每次读取都会读入一个32KB大小的块。因此，在写入Log文件时，LevelDB也将数据按照32KB对齐。</p><p>由于，LevelDB中记录的长度是不确定的，如果想要与32KB块对齐，为了尽可能地利用空间，那么较长的记录可能会被拆分为多个段，以能够将其放入块的剩余空间中。LevelDB定义只有1个段的记录为<code>FullType</code>，由多个段组成的记录的首位段分别为<code>FirstType</code>与<code>LastType</code>，中间段为<code>MiddleType</code>。</p><img src="/img/leveldb/log-1.jpg" style="zoom:67%;"><p>关于WAL机制重点在下面一讲，数据库的恢复中进行讲解，这里只简单介绍一下日志的结构。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析16-Put&amp;&amp;Delete&amp;&amp;Get</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9016-Put%E5%92%8CDelete%E5%92%8CGet/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9016-Put%E5%92%8CDelete%E5%92%8CGet/</url>
    
    <content type="html"><![CDATA[<h2 id="Put-Delete-Get"><a href="#Put-Delete-Get" class="headerlink" title="Put &amp;&amp; Delete &amp;&amp; Get"></a><strong>Put &amp;&amp; Delete &amp;&amp; Get</strong></h2><p>这篇文章主要介绍一下leveldb中<code>Put</code> 和<code>Delete</code> 的接口。而<code>Write</code>接口用来批量执行<code>Put</code>或<code>Delete</code>操作，在同一批（即同一个<code>WriteBatch</code>）中的操作，其插入的entry的SequenceNumber相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DB::Put</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; opt, <span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">const</span> Slice&amp; value)</span> &#123;<br>  WriteBatch batch;<br>  batch.Put(key, value);<br>  <span class="hljs-keyword">return</span> Write(opt, &amp;batch);<br>&#125;<br><br>Status <span class="hljs-title function_">DB::Delete</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; opt, <span class="hljs-type">const</span> Slice&amp; key)</span> &#123;<br>  WriteBatch batch;<br>  batch.Delete(key);<br>  <span class="hljs-keyword">return</span> Write(opt, &amp;batch);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WriteBatch"><a href="#WriteBatch" class="headerlink" title="WriteBatch"></a><strong>WriteBatch</strong></h2><p><code>WriteBatch</code>是用来记录需要批处理的若干个<code>Put</code>或<code>Delete</code>操作的结构体。LevelDB会为同一个<code>WriteBatch</code>中所有操作分配相同的SequenceNumber。<code>WriteBatch</code>的结构如下图所示：</p><img src="/img/leveldb/writebatch.png" style="zoom: 50%;"><p>每个<code>WriteBatch</code>在内存中是一个连续的字节数组，其头12个字节是WriteBatch的Header，其中前8字节是该WriteBatch的SequenceNumber，后4字节是该WriteBatch中Entry的数量。Header后面连续存放着WriteBatch中的Entry。每个Entry的头一个字节标识了该Entry的操作类型。对于Put操作的Entry，在类型标识后以LengthPrefixedSlice编码存放着key和value；对于Delete操作的Entry，在类型标识后以LengthPrefixedSlice编码存放着待删除忽的key。</p><p><code>WriteBatch</code> 的用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">leveldb::WriteBatch batch;<br>batch.Put(key1, value1);<br>batch.Delete(key1);<br>batch.Put(key2, value);<br>s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);<br></code></pre></td></tr></table></figure><p>为了优化写性能，LevelDB中提供了写合并能力，队首线程可以将队列中多个连续的写任务合并为一个写任务。</p><ul><li>若队首写任务的WriteOption中sync属性为false且待合并的任务sync属性为true，则不能被合并。如下图中假设W1、W2、W3、W4、W5的sync属性为false，W6的sync属性为true，则W1~5将被合并为一个写任务，随后开始写日志文件（AddRecord）和写内存数据库（InsertIntoMemtable)。</li><li>写日志和内存数据库时会释放写锁，允许其他线程向写队列中添加写任务，当写任务完成时将再次加锁，并更新当前版本的操作序列号（更新前的序列号加上本次写任务的写操作数量）。</li><li>当前写任务完成时，写队列中可能被其他线程插入了新的任务（W9～11），已完成的写任务将陆续出队列，最后唤醒当前队首线程（W6）进行新一轮的写任务。</li></ul><p><img src="/img/leveldb/writebatch-1.jpg"></p><p>我们来看相关的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DBImpl::Write</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> &#123;<br>  <span class="hljs-comment">//创建写任务</span><br>  Writer <span class="hljs-title function_">w</span><span class="hljs-params">(&amp;mutex_)</span>;<br>  w.batch = updates;<br>  w.sync = options.sync;<br>  w.done = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">//写任务如队列</span><br>  MutexLock <span class="hljs-title function_">l</span><span class="hljs-params">(&amp;mutex_)</span>;<br>  writers_.push_back(&amp;w);<br>  <span class="hljs-comment">//队首线程拿到写锁，其他线程阻塞</span><br>  <span class="hljs-keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;<br>    w.cv.Wait();<br>  &#125;<br><br>  <span class="hljs-comment">//排队的写任务可能在写合并时与队首任务一起完成了，无需再进行后续的写操作</span><br>  <span class="hljs-keyword">if</span> (w.done) &#123;<br>    <span class="hljs-keyword">return</span> w.status;<br>  &#125;<br>    <br>  <span class="hljs-comment">//写前检查，内部会短暂解锁 以便其他写任务加入队列中</span><br>  Status status = MakeRoomForWrite(updates == nullptr);<br>  <span class="hljs-comment">//获取操作序列号</span><br>  <span class="hljs-type">uint64_t</span> last_sequence = versions_-&gt;LastSequence();<br>  Writer* last_writer = &amp;w;<br>  <span class="hljs-keyword">if</span> (status.ok() &amp;&amp; updates != nullptr) &#123; <br>      <span class="hljs-comment">//写合并</span><br>    WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer); <br>    WriteBatchInternal::SetSequence(write_batch, last_sequence + <span class="hljs-number">1</span>); <br>      <span class="hljs-comment">//每个KV操作都有自己的操作序列号，序列号增加合并的KV数</span><br>    last_sequence += WriteBatchInternal::Count(write_batch);<br><br>    &#123;<br>      <span class="hljs-comment">//写日志和内存数据时写队列解锁，允许新的写任务入队列</span><br>      mutex_.Unlock();<br>      <span class="hljs-comment">//写日志</span><br>      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));<br>      <span class="hljs-type">bool</span> sync_error = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123;<br>          <span class="hljs-comment">//日志文件缓冲区中内容写入磁盘</span><br>        status = logfile_-&gt;Sync(); <br>        <span class="hljs-keyword">if</span> (!status.ok()) &#123;<br>          sync_error = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">//写内存数据库</span><br>      <span class="hljs-keyword">if</span> (status.ok()) &#123;<br>        status = WriteBatchInternal::InsertInto(write_batch, mem_);<br>      &#125;<br>      mutex_.Lock();<br>    &#125;<br>    <span class="hljs-comment">//更新操作序列号</span><br>    versions_-&gt;SetLastSequence(last_sequence);<br>  &#125;<br><br>  <span class="hljs-comment">//将已完成的写任务移出队列</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Writer* ready = writers_.front();<br>    writers_.pop_front();<br>    <span class="hljs-keyword">if</span> (ready != &amp;w) &#123;<br>      ready-&gt;status = status;<br>      ready-&gt;done = <span class="hljs-literal">true</span>;<br>      ready-&gt;cv.Signal(); <br>    &#125;<br>    <span class="hljs-keyword">if</span> (ready == last_writer) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//last为最后一个被合并写入的写任务</span><br>  &#125;<br><br>  <span class="hljs-comment">//唤醒当前队头写任务</span><br>  <span class="hljs-keyword">if</span> (!writers_.empty()) &#123;<br>    writers_.front()-&gt;cv.Signal();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> status;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Get操作"><a href="#Get操作" class="headerlink" title="Get操作"></a><strong>Get操作</strong></h2><p>首先这里为<code>mutex_</code> 进行加锁，为什么需要<code>MutexLock</code> 类？</p><blockquote><p>这里利用了析构函数对mutex_进行解锁的，退出这个函数的作用域就会调用MutexLock析构函数，不会出现忘记解锁导致的问题。这种机制也叫作RALL(Resource Acquisition Is Initialization)。</p></blockquote><p>然后从<code>options</code> 里面获取快照信息。</p><p>然后获取<code>mem_</code> 、<code>imm_</code> 和<code>current_</code> ，将依次在这里面进行查询。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Status s;<br>MutexLock <span class="hljs-title function_">l</span><span class="hljs-params">(&amp;mutex_)</span>;<br>SequenceNumber snapshot;<br><span class="hljs-keyword">if</span> (options.snapshot != nullptr) &#123;<br>    snapshot =<br>        static_cast&lt;<span class="hljs-type">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    snapshot = versions_-&gt;LastSequence();<br>&#125;<br><br>MemTable* mem = mem_;<br>MemTable* imm = imm_;<br>Version* current = versions_-&gt;current();<br>mem-&gt;Ref();<br><span class="hljs-keyword">if</span> (imm != nullptr) imm-&gt;Ref();<br>current-&gt;Ref();<br></code></pre></td></tr></table></figure><p>然后构造<code>LookupKey</code> ，在三个层次中进行查询就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> have_stat_update = <span class="hljs-literal">false</span>;<br>  Version::GetStats stats;<br><br>  <span class="hljs-comment">// Unlock while reading from files and memtables</span><br>  &#123;<br>    mutex_.Unlock();<br>    <span class="hljs-comment">// First look in the memtable, then in the immutable memtable (if any).</span><br>    LookupKey <span class="hljs-title function_">lkey</span><span class="hljs-params">(key, snapshot)</span>;<br>    <span class="hljs-keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;<br>      <span class="hljs-comment">// Done</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm != nullptr &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;<br>      <span class="hljs-comment">// Done</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      s = current-&gt;Get(options, lkey, value, &amp;stats);<br>      have_stat_update = <span class="hljs-literal">true</span>;<br>    &#125;<br>    mutex_.Lock();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;<br>    MaybeScheduleCompaction();<br>  &#125;<br>  mem-&gt;Unref();<br>  <span class="hljs-keyword">if</span> (imm != nullptr) imm-&gt;Unref();<br>  current-&gt;Unref();<br>  <span class="hljs-keyword">return</span> s;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析14-快照Snapshot</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9014-%E5%BF%AB%E7%85%A7Snapshot/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9014-%E5%BF%AB%E7%85%A7Snapshot/</url>
    
    <content type="html"><![CDATA[<h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a><strong>Snapshot</strong></h2><p>snapshot，即快照，赋予了使用者查找在过去某一个瞬间数据库状态的能力：在那一时刻，整个 leveldb 有哪些数据，什么版本。 leveldb 会冗余地存储很多旧版本的数据。我们有可能误删了数据， 或者想追踪数据的变化历史，这时快照功能就十分有用了。 实现快照功能有以下两个主要问题：</p><ol><li>前面说过，应该冗余存储旧版本数据。那么应该保留多老的数据呢？ 联想到 leveldb 中任何一个数据(键值对)都有一个整数版本号 sequence number，我们也可以用一个整数来告诉 leveldb 对每个 user_key 都应该<strong>至少保留一个小于这个整数的版本</strong>(如果这个 user_key 有小于此整数的版本的话，大于这个版本的也都需要进行存储)。这个整数即是 snapshot。 只要 user_key 在那个时刻(产生 snapshot 这个版本的时刻)有版本(即 user_key 存在小于等于 snapshot 的版本)， 则我们应该返回这个时刻当 时最新的版本，即 user_key 的所有版本中小于等于 snapshot 的最大版本。 snapshot 的值必然比当前 leveldb 最新版本号小：最新版本号时时刻刻都是整个 leveldb 中最大的版本号。</li><li>我们应该如何使用 snapshot 以对每个 user_key 保存一个小于等于它的版本呢？我们在每次新写入时不可能做到这点，最新版本号作为 snapshot 没有意义：违背了快照的初衷，快照是历史的某时刻状态，并非现在。除了新写入数据，后面唯一一个可以动数据的地方就是 compaction 了。 leveldb 通过在 compaction 时给出一个 snapshot，在执行 compaction 时，会为每个 user_key 保留一个小于等于 snapshot 的版本(如果有的话)。</li></ol><p>那么如何使用快照呢？ – 查询数据时，通过option传入snapshot参数，查找时会跳过版本号比 snapshot 大的键值对，定位到小于等于 snapshot 的最新版本， 从而读取那个时刻的历史数据。</p><h2 id="Compact-Snapshot"><a href="#Compact-Snapshot" class="headerlink" title="Compact &amp;&amp; Snapshot"></a><strong>Compact &amp;&amp; Snapshot</strong></h2><p>前面我们讲过Compaction部分的代码，选择出待 compaction 的文件：level 层和 level+1 层，将这两个层次的 sst 文件包装为一个 MergingIterator，按序遍历键值对，一个一个判断，是 drop 掉，还是加入到新的 sst 文件中。</p><p>这里也是对上面Compaction进行drop部分的一个小的补充。</p><ol><li>对于当前遍历到的 user_key，为它保留了一个小于等于指定 snapshot 的最新版本。</li><li>首次遍历到的 user_key，不论版本号与 snapshot 关系如何，都应该保留下来，即使当前版本是一个 deletion，也应保留。</li></ol><blockquote><p>a).这个 user_key 最新版本的值类型是 deleteType：则这个 user_key 在之后的遍历中都不应该再被查找到。但是如果删除了这个 deletion 版本，此 user_key 的旧版本会被遍历，而一旦这个旧版本是一个正常的 valueType，则它会被查找到返回给用户，这是逻辑错误。因此如果要删除这个 deletion 版本，则需要删除此 user_key 的所有版本：让这个 user_key 不可能被查到。基于这点，有以下两个分支判断： </p><p>a-1).这个 deletion 版本的版本号小于等于 snapshot ：删除所有的历史版本，相当于人为地扼杀了 user_key 本应该具有的快照功能。 </p><p>a-2).这个 deletion 版本的版本号大于 snapshot，有以下两个分支判断： </p><p>a-b-1)若后续的遍历中 user_key 存在小于等于 snapshot 的版本，则与上面 a-1) 一样，扼杀了快照功能。</p><p>a- b-2)若后续的遍历中 user_key 不存在小于等于 snapshot 的版本，并没有扼杀对于 snapshot 的快照功能。弊端不很明显，在于，compaction 指定的 是一个版本号数组，虽然没有扼杀最小的 snapshot 的快照功能，但是有可能扼杀较大的 snapshot 的快照功能。不扼杀的情况是：此 user_key 的最老 的版本号大于最大的 snapshot。但是对于其它的 user_key，可能仍然会扼杀快照功能。完全搞清楚：是否对于所有的 user_key 没有扼杀任何一个 snapshot 的快照功能，是一件非常繁杂的事情。因此简单而且稳妥起见，不要 drop 这个 deletion 版本即可。</p></blockquote><ol start="3"><li>非首次遍历到的 user_key 是一个 deletion 版本，则 drop 依赖于以下两个条件满足： <ul><li>当前 user_key 只出现在执行 compaction 的层次(设为 level) 和 level+1 层中 </li><li>当前遍历的版本号小于等于 snapshot</li></ul></li></ol><blockquote><p>1.当前是要将 level_ 层和 level_+1 层 compact，虽然在这两层将 user_key 的这个 deletion 版本删除了，但如果当前 user_key 还出现在比 level+1 层更高的层中，这些稍老的版本（层次越高数据越老越“冷”）会响应对 user_key 的查找，这将是逻辑错误。 2.若当前这个 deletion 版本号大于 snapshot 仍然将它 drop 掉，为了保持逻辑的正确性，还需要将此 user_key 后续版本全部 drop（第2点中讲过）。但 这样也有问题：会扼杀快照功能（上面详细阐述了这点）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析15-版本控制</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9015-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9015-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a><strong>本讲内容</strong></h2><p>这篇文章主要介绍leveldb中的MVCC机制，leveldb是如何进行读读并发，读写并发以及快照读的。</p><p>LevelDB的用户可以通过其提供的接口要求其保留一定时间之前的快照，在用户释放快照前，该快照创建时LevelDB中存在的数据就不会被释放。这里主要通过<code>Ref</code> 和<code>UnRef</code> 机制实现。引用计数为0的版本可以删除，同样引用计数为0的文件也可以删除，不同的版本之间可能会有重叠的文件。</p><p>想要实现MVCC，存储系统就要存储数据的多个版本。笔者将LevelDB的多版本存储设计分为了三个层次：</p><p><strong>从key&#x2F;value的角度：</strong> 每次变更操作的记录（Batch Writer可视为一次操作）都有不同且递增的SequenceNumber。对于一个UserKey，当存在SequenceNumber更高的的记录时，旧的记录不会被立即删除，至少要在该SequenceNumber之前的所有Snapshot都被释放后才能删除（具体删除时间与Compaction时间有关）。这是LevelDB实现Snapshot Read的基础。</p><p><strong>从MemTable的角度：</strong> LevelDB中的MemTable通过引用计数来控制释放时间。在需要读取MemTable时（无论是Get操作还是Minor Compaction时），读取前会增大其引用计数，读取后减小引用计数。这样，即使MemTable已被通过Minor Compaction操作写入到Level-0文件，MemTable在被读取，它就不会被释放。</p><p><strong>从数据库文件的角度：</strong> LevelDB的文件同样需要引用计数，当执行Major Compaction时，LevelDB不会立即删除已被合并的数据库文件，因为此时可能还有未完成的读取该文件的操作。</p><h2 id="Version-VersionEdit-VersionSet"><a href="#Version-VersionEdit-VersionSet" class="headerlink" title="Version &amp;&amp; VersionEdit &amp;&amp; VersionSet"></a><strong>Version &amp;&amp; VersionEdit &amp;&amp; VersionSet</strong></h2><p>首先介绍一下这几个类的关系和作用。</p><ol><li>每一个<code>Version</code> 表示一个版本，它包含这个版本所有的文件信息，还有一个<code>prev_</code> 和<code>next_</code> 指针以及引用计数</li><li><code>VersionSet</code> 是当前数据库的所有版本的集合，它有一个<code>current_</code> 版本表示最新的版本。<code>VersionSet</code> 组织成一个双向链表</li><li><code>VersionEdit</code> 表示版本做的变动，在创建新版本时，LevelDB首先构造<code>VersionEdit</code> ，然后通过<code>VersionSet::LogAndApply</code>方法，先将<code>VersionEdit</code> 应用到Current Version，然后将增量的VersionEdit写入Manifest文件中。</li></ol><img src="/img/leveldb/version-1.png" style="zoom:33%;"><p>为什么需要有多个<code>Version</code> ？</p><p>某个时刻，读请求会根据version set里的current_找到最新version，并在这个version里保存的sst文件集合中寻找目标数据。此后假设发生了合并并产生了新的version，新version将更新到version set的current_字段成为新的链表头。如果此时立即删除被合并的sst文件，那么正在进行中的读请求就会出错，所以删除sst文件的动作并不是立即发生的。同时，因为读请求依据的是旧版本的version（sst文件集合），所以新合并生成的sst并不会被该读请求扫描到。</p><p>在实现上来说，读请求引用了旧版本的version，而写请求需要设置新版本的version，那么旧版本的version何时释放内存呢？这里就采用了引用计数机制，最新的version默认是1个引用计数并保存在version set的链表头部（current_），当读请求到来后会对version set的current_增加1个引用计数。此后发生合并生成新version替换current_时，先释放旧version的1个引用计数（还剩余1个由读请求持有），然后替换current_为新的version对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">Version::~Version() &#123;<br>  assert(refs_ == <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Remove from linked list</span><br>  prev_-&gt;next_ = next_;<br>  next_-&gt;prev_ = prev_;<br><br>  <span class="hljs-comment">// Drop references to files</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">0</span>; level &lt; config::kNumLevels; level++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; files_[level].size(); i++) &#123;<br>      FileMetaData* f = files_[level][i];<br>      assert(f-&gt;refs &gt; <span class="hljs-number">0</span>);<br>      f-&gt;refs--;<br>      <span class="hljs-keyword">if</span> (f-&gt;refs &lt;= <span class="hljs-number">0</span>) &#123;<br>        delete f;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ol><li>最后，我们已经介绍完了版本控制和快照，它们的关系是什么，是如何配合使用的呢，我们现在再来理一下。</li></ol><p>在进行<code>Get</code> 进行查询时，我们总是获取当前最新版本的<code>version</code> ，在最新的<code>Version</code> 里面进行查询。如果我们要获取某个快照时K对应的V，我们需要在<code>opstions</code> 里面传入<code>snapshot</code> 参数(<code>uint64</code> )。然后根据Key和snapshot构造一个<code>LookupKey</code> ，也是在<code>current_</code> 版本里进行查询，<code>Current_</code> 版本需要引用计数加1。可能在查询的过程发生了Compaction，产生了一个新的版本<code>Version</code> ，所以历史的版本不能立马删除，只有在引用计数为0的时候才能销毁某一个<code>Version</code> 。 </p><ol start="2"><li>另外还有一个小的问题困惑了我很久，那就是假如一个Key，它的操作很多，每一个操作的sequence number都不一样，leveldb难道要记录所有的快照信息吗，这样难道会大大浪费存储空间吗？</li></ol><p>其实这个问题的答案显而易见就藏在<code>DoCompactionWork</code> 的代码中，在<code>DoCompactionWork</code> 代码中的<code>Compact</code> 结构体中，会设置<code>compact-&gt;smallest_snapshot</code> 这个值，(用户可以调用<code>void ReleaseSnapshot(const Snapshot* *snapshot*)</code> 函数手动删除某一个快照，我们之前说过，快照也是一个双向链表组织而成的)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (snapshots_.empty()) &#123;<br>    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>compact-&gt;smallest_snapshot</code> 这样设置有什么好处呢，这样可以在Compaction的时候删除不需要的过期的数据了。</p><blockquote><p>为什么遍历的时候要在第一次碰到某个key时把last_sequence_for_key调整成最大呢，这就是为了防止把该key的唯一的一条记录都给删除了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!has_current_user_key || user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// First occurrence of this user key</span><br>    current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());<br>    has_current_user_key = <span class="hljs-literal">true</span>;<br>    last_sequence_for_key = kMaxSequenceNumber;<br>&#125;<br><span class="hljs-keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;<br>    <span class="hljs-comment">// Hidden by an newer entry for same user key</span><br>    drop = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// (A)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果某一个操作<code>Put(K1,V1)</code> 的sequence number为1，接下来都没有对K1的更改，后面sequence number增加到5，然后人为地删除了snapshot为1的快照，接下来某一次Compaction，因为只有一条关于K1的记录，所以在合并的过程中并不会删除这条记录，仍旧把这条记录写进新的sstable，并且sequence number也没有发生更改，也是过期的snapshot。假如我现在读取K1，仍旧会读取到这条记录，因为参数snapshot就是找到一条小于等于此snapshot号的最大的记录。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析13-迭代器</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9013-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9013-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>我们已经介绍了leveldb中基本所有组件的结构，接下来我们应该设计迭代器用来访问这些基本的组件。</p><p>本文将对LevelDB中迭代器Iterator的体系进行介绍，旨在梳理LevelDB中各种迭代器的功能与使用场景，对迭代器的实现介绍较少。迭代器的实现细节其实相对并不难。</p><h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a><strong>Iterators</strong></h2><p>LevelDB中，既有直接在集合上的基本迭代器，也有对一个迭代器进行封装来解析更复杂数据的迭代器，还有多个迭代器组成的组合迭代器，关系较为复杂。下图给出了LevelDB中数据结构与相应的迭代器的总览。其中绿的方框为数据结构，与之相连的黄色的方框为该数据结构上的迭代器。迭代器括号中指出了其本质是什么迭代器。</p><img src="/img/leveldb/iterators-1.png" style="zoom:80%;"><h2 id="基本迭代器"><a href="#基本迭代器" class="headerlink" title="基本迭代器"></a><strong>基本迭代器</strong></h2><p>基本迭代器指直接在集合类上实现的迭代器。</p><table><thead><tr><th>容器</th><th>元素</th><th>迭代器</th></tr></thead><tbody><tr><td>SkipList</td><td>SkipList中的Node</td><td>SkipList::Iterator(const SkipList* list)</td></tr><tr><td>MemTable</td><td>MemTable中的key&#x2F;value</td><td>MemTable.Iterator* NewIterator();</td></tr><tr><td>Block</td><td>Block中的Entry</td><td>Block.Iterator* NewIterator(const Comparator* comparato</td></tr><tr><td>FileMetaData</td><td>每层SSTable的编号</td><td>Version::LevelFileNumIterator(…)</td></tr></tbody></table><p>这几种迭代器是用来遍历基本组件的，它们的实现比较简单，主要是需要了解清楚各种组件的结构。</p><h2 id="复杂的迭代器"><a href="#复杂的迭代器" class="headerlink" title="复杂的迭代器"></a><strong>复杂的迭代器</strong></h2><p>LevelDB通过“组合迭代器”，来讲多个迭代器组合在一起，来实现复杂的迭代器。LevelDB设计了两个组合迭代器<code>TwoLevelIterator</code>与<code>MergingIterator</code>。</p><h2 id="TwoLevelIterator"><a href="#TwoLevelIterator" class="headerlink" title="TwoLevelIterator"></a><strong>TwoLevelIterator</strong></h2><p>Two Level Iterator其实就是使用两个Iterator，第一个Iterator是第二个Iterator的索引。先在第一层的Iterator做迭代，每次拿出一个元素后，根据这个元素调用回调函数，生成第二层的一个Iterator，然后第二层的Iterator迭代完成后，再在第一层取下一个元素。</p><p>对使用Two Level Iterator有两个要求: <em>第一层的Iterator的元素是有序排序的；</em> 根据第一层的Iterator生成的第二层的Iterator也是全局有序的，也就是第一层第n个元素生成的第二层Iterator的最大元素小于第一层第n + 1个元素生成的第二层Iterator的最小元素，并且第二层的每个Iterator内部也是有序的。</p><p>leveldb中有两个地方需要使用<code>TwoLevelIterator</code> </p><ul><li>第一个称之为<code>Table::Iterator</code>，它是实现单个sst文件（table）内的迭代</li><li>第二个是<code>ConcatenatingIterator</code>，它主要是在对某一层（大于0）内所有sst文件的迭代中用到</li></ul><p><code>TowLevelIterator</code> 的<code>Seek</code> 操作流程是什么</p><ol><li>首先使用index iterator的<code>Seek</code> 函数，seek到相应的index处，得到index的内容（sstable就是data_block在文件中的偏移）</li><li>然后调用<code>block_function_</code> 函数，返回一个迭代器<code>data_iter</code> ，用这个迭代器真正地访问元素</li><li>最后就是调用<code>data_iter_</code> 的<code>Seek</code> 函数，迭代器停留在目标位置上。</li></ol><p>leveldb中有两个地方使用到了<code>TwoLevelIterrator</code> </p><ol><li><p>SSTable内部的index与data。Table Iterator作为<code>TwoLevelIterator</code>，其第一级iterator遍历SSTable中的index，第二级iterator遍历index相应的data block中的key&#x2F;value。</p></li><li><p>level&gt;0的SSTable，其每层SSTable可以按照key排序，每个SSTable内也按照key排序，且每层SSTable中的key没有overlap且全局有序。因此LevelDB中Version的Concaterating Iterator实际上就是一个<code>TwoLevelIterator</code>，其第一级iterator是<code>LevelFileNumIterator</code>，该iterator按照key的顺序遍历每层SSTable；其第二级iterator是Table Iterator，该iterator可以按照key的顺序遍历SSTable中的key&#x2F;value。Table Iterator本身也是一个<code>TwoLevelIterator</code></p></li></ol><h3 id="单个的SStable文件"><a href="#单个的SStable文件" class="headerlink" title="单个的SStable文件"></a><strong>单个的SStable文件</strong></h3><p>这里的<code>TwoLevelIterator</code> 比较好理解。单个sstable文件本来就有<code>index_block_</code> ，我们只需要另外传入一个<code>BlockReader</code> 函数，这个函数就是根据<code>index</code> 的内容（文件偏移）来读取特定的<code>data_block</code> ，返回一个data block的迭代器。<code>BlockReader</code> 函数比较简单，就是根据文件偏移读取一个data block。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">return</span> NewTwoLevelIterator(<br>      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),<br>      &amp;Table::BlockReader, const_cast&lt;Table*&gt;(this), options);<br></code></pre></td></tr></table></figure><h3 id="大于零层级的SStable文件集合"><a href="#大于零层级的SStable文件集合" class="headerlink" title="大于零层级的SStable文件集合"></a><strong>大于零层级的SStable文件集合</strong></h3><p>这里有多个sstable文件，这里的<code>index_iter</code> 需要我们新建一个<code>LevelFileNumIterator</code> 的类。然后第二层级的<code>data_iter_</code> 就是一个特定的sstable文件，这个sstable文件又是一个<code>TwoLevelIterator</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Iterator* <span class="hljs-title function_">Version::NewConcatenatingIterator</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options,</span><br><span class="hljs-params">                                            <span class="hljs-type">int</span> level)</span> <span class="hljs-type">const</span> &#123;<br>  <span class="hljs-keyword">return</span> NewTwoLevelIterator(<br>      new LevelFileNumIterator(vset_-&gt;icmp_, &amp;files_[level]), &amp;GetFileIterator,<br>      vset_-&gt;table_cache_, options);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LevelFileNumIterator</code> 把sstable文件组织成一个集合，<code>index_</code> 就是目标文件在<code>flist_</code> 中的索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FileMetaData*&gt;* <span class="hljs-type">const</span> flist_;<br></code></pre></td></tr></table></figure><p>当我们对ConcatenatingIterator调用<code>Seek</code> 函数的时候，首先调用的是LevelFileNumIterator的<code>Seek</code> 函数，找到所需要的sstable文件信息（LevelFileNumIterator的<code>value</code> 就是sstable文件number和文件size），然后调用<code>block_function_</code> (<code>GetFileIterator</code>) 函数，通过文件的number和size，得到一个data_iter（这里用到了缓存机制），这个data_iter 也是一个<code>TwoLevelIterator</code>，表示一个sstable文件 。</p><blockquote><p><code>GetFileIterator</code> 函数就是返回一个sstable的<code>TwoLevelIterator</code> </p></blockquote><h2 id="MergingIterator"><a href="#MergingIterator" class="headerlink" title="MergingIterator"></a><strong>MergingIterator</strong></h2><p>如果每个iterator中的key有序，但是所有iterator中的所有key全局无序，此时，需要一种能够“归并”多路有序iterator的结构。这一结构即为<code>MergingIterator</code>。</p><p>在创建<code>MergingIterator</code>时，需要传入待组合的<code>Iterator</code>数组，及用来比较每个<code>Iterator</code>中的key的<code>Comparator</code>。在通过<code>MerginIterator</code>遍历所有iterator的key时，<code>MergingIterator</code>会比较其中所有iterator的key，并按照顺序选取最小的遍历；在所有iterator的空间中seek时，<code>MergingIterator</code>会调用所有iterator的<code>Seek</code>方法，然后比较所有iterator的seek结果，按顺序选取最小的返回。</p><p>这部分的代码并不难。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MergingIterator::FindSmallest</span><span class="hljs-params">()</span> &#123;<br>  IteratorWrapper* smallest = nullptr;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_; i++) &#123;<br>    IteratorWrapper* child = &amp;children_[i];<br>    <span class="hljs-keyword">if</span> (child-&gt;Valid()) &#123;<br>      <span class="hljs-keyword">if</span> (smallest == nullptr) &#123;<br>        smallest = child;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (comparator_-&gt;Compare(child-&gt;key(), smallest-&gt;key()) &lt; <span class="hljs-number">0</span>) &#123;<br>        smallest = child;<br>      &#125;<br>    &#125;<br>  &#125;<br>  current_ = smallest;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Seek</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; target)</span> override &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_; i++) &#123;<br>      children_[i].Seek(target);<br>    &#125;<br>    FindSmallest();<br>    direction_ = kForward;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Next</span><span class="hljs-params">()</span> override &#123;<br>    assert(Valid());<br><br>    <span class="hljs-comment">// Ensure that all children are positioned after key().</span><br>    <span class="hljs-comment">// If we are moving in the forward direction, it is already</span><br>    <span class="hljs-comment">// true for all of the non-current_ children since current_ is</span><br>    <span class="hljs-comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span><br>    <span class="hljs-comment">// we explicitly position the non-current_ children.</span><br>    <span class="hljs-keyword">if</span> (direction_ != kForward) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_; i++) &#123;<br>        IteratorWrapper* child = &amp;children_[i];<br>        <span class="hljs-keyword">if</span> (child != current_) &#123;<br>          child-&gt;Seek(key());<br>          <span class="hljs-keyword">if</span> (child-&gt;Valid() &amp;&amp;<br>              comparator_-&gt;Compare(key(), child-&gt;key()) == <span class="hljs-number">0</span>) &#123;<br>            child-&gt;Next();<br>          &#125;<br>        &#125;<br>      &#125;<br>      direction_ = kForward;<br>    &#125;<br><br>    current_-&gt;Next();<br>    FindSmallest();<br>  &#125;<br></code></pre></td></tr></table></figure><p>LevelDB中主要有两处使用了<code>MergingIterator</code>：</p><p>其一是用来访问整个LevelDB中数据的迭代器<code>InternalIterator</code>。该迭代器组合了MemTable Iterator、Immutable MemTable Iterator、每个Level-0 SSTable的Iterator，和level&gt;1的所有SSTable的Concatenating Iterator。</p><p>其二是执行Major Compaction时访问需要Compact的所有SSTable的迭代器<code>InputIterator</code>。对于level-0的SSTable，其直接组装了所有SSTable的Table Iterator，因为level-0中每个SSTable的key空间不保证全局有序；而对于其它level的SSTable，其通过Concatenating Iterator（即组装了LevelFileNumIterator和Table Iterator的TwoLevelIterator），该Concatenating Iterator中组装了该层需要参与Major Compaction的SSTable。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析12-Compaction(2)</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9012-Compaction(2)/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9012-Compaction(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a><strong>Compaction</strong></h2><p>上一篇介绍了Compaction的一些基本概念和原理，这一篇，我们开始研究Compaction中的代码，力求清楚代码中的细节。</p><h2 id="Minor-Compaction"><a href="#Minor-Compaction" class="headerlink" title="Minor Compaction"></a><strong>Minor Compaction</strong></h2><p>Minor Compaction主要通过<code>DBImpl::CompactionMemTable</code>方法实现：</p><p><code>CompactionMemTable</code>方法首先调用<code>DBImpl::WriteLevel0Table</code>方法将Immutable MemTable转储为SSTable，由于该方法需要使用当前的Version信息，因此在调用前后增减了当前Version的引用计数以避免其被回收。接着，通过<code>VersionSet::LogAndApply</code>方法将增量的版本更新VersionEdit写入Manifest（其中prev log number已被弃用，不需要再关注）。如果上述操作都成功完成，则可以释放对Immutable MemTable的引用，并通过<code>RemoveObsoleteFiles</code>方法回收不再需要保留的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DBImpl::CompactMemTable</span><span class="hljs-params">()</span> &#123;<br>  mutex_.AssertHeld();<br>  assert(imm_ != nullptr);<br><br>  <span class="hljs-comment">// Save the contents of the memtable as a new Table</span><br>  VersionEdit edit;<br>  Version* base = versions_-&gt;current();<br>  base-&gt;Ref();<br>  Status s = WriteLevel0Table(imm_, &amp;edit, base);<br>  base-&gt;Unref();<br><br>  <span class="hljs-keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="hljs-built_in">std</span>::memory_order_acquire)) &#123;<br>    s = Status::IOError(<span class="hljs-string">&quot;Deleting DB during memtable compaction&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Replace immutable memtable with the generated Table</span><br>  <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>    edit.SetPrevLogNumber(<span class="hljs-number">0</span>);<br>    edit.SetLogNumber(logfile_number_);  <span class="hljs-comment">// Earlier logs no longer needed</span><br>    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>    <span class="hljs-comment">// Commit to the new state</span><br>    imm_-&gt;Unref();<br>    imm_ = nullptr;<br>    has_imm_.store(<span class="hljs-literal">false</span>, <span class="hljs-built_in">std</span>::memory_order_release);<br>    RemoveObsoleteFiles();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    RecordBackgroundError(s);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来看一下<code>WriteLevel0Table</code> 的代码。</p><p>实现也比较简单，获取了需要转储的MemTable的迭代器，并传给<code>BuildTable</code>方法。<code>BuildTable</code>方法会通过<code>TableBuilder</code>来构造SSTable文件然后写入。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">DBImpl::WriteLevel0Table</span><span class="hljs-params">(MemTable* mem, VersionEdit* edit,</span><br><span class="hljs-params">                                Version* base)</span> &#123;<br>  mutex_.AssertHeld();<br>  <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> start_micros = env_-&gt;NowMicros();<br>  FileMetaData meta;<br>  meta.number = versions_-&gt;NewFileNumber();<br>  pending_outputs_.insert(meta.number);<br>  Iterator* iter = mem-&gt;NewIterator();<br>  Log(options_.info_log, <span class="hljs-string">&quot;Level-0 table #%llu: started&quot;</span>,<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.number);<br><br>  Status s;<br>  &#123;<br>    mutex_.Unlock();<br>    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);<br>    mutex_.Lock();<br>  &#125;<br><br>  Log(options_.info_log, <span class="hljs-string">&quot;Level-0 table #%llu: %lld bytes %s&quot;</span>,<br>      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.number, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)meta.file_size,<br>      s.ToString().c_str());<br>  delete iter;<br>  pending_outputs_.erase(meta.number);<br><br>  <span class="hljs-comment">// Note that if file_size is zero, the file has been deleted and</span><br>  <span class="hljs-comment">// should not be added to the manifest.</span><br>  <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">const</span> Slice min_user_key = meta.smallest.user_key();<br>    <span class="hljs-type">const</span> Slice max_user_key = meta.largest.user_key();<br>    <span class="hljs-keyword">if</span> (base != nullptr) &#123;<br>      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);<br>    &#125;<br>    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,<br>                  meta.largest);<br>  &#125;<br><br>  CompactionStats stats;<br>  stats.micros = env_-&gt;NowMicros() - start_micros;<br>  stats.bytes_written = meta.file_size;<br>  stats_[level].Add(stats);<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在LST-Tree的基本概念中，Minor Compaction只需要将Immutable MemTable全量转储为SSTable，并将其推至level-0即可。而LevelDB对这一步骤进行了优化，在<code>DBImpl::WriteLevel0Table</code> 函数中，调用了<code>PickLevelForMemTableOutput</code> ,也就是Immutable MemTable全量转储为SSTable不一定处于level 0。</p><p>我们来看<code>PickLevelForMemTableOutput</code> 的代码：</p><ol><li>目标level不能超过配置<code>config::kMaxMemCompactLevel</code>中限制的最大高度（默认为2）</li><li>目标level的文件不能与该sst相重叠</li><li>该sst不能与level + 1中的sst重叠得过多，计算方式<code>GetOverlappingInputs</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Version::PickLevelForMemTableOutput</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; smallest_user_key,</span><br><span class="hljs-params">                                        <span class="hljs-type">const</span> Slice&amp; largest_user_key)</span> &#123;<br>  <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (!OverlapInLevel(<span class="hljs-number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;<br>    <span class="hljs-comment">// Push to next level if there is no overlap in next level,</span><br>    <span class="hljs-comment">// and the #bytes overlapping in the level after that are limited.</span><br>    InternalKey <span class="hljs-title function_">start</span><span class="hljs-params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span>;<br>    InternalKey <span class="hljs-title function_">limit</span><span class="hljs-params">(largest_user_key, <span class="hljs-number">0</span>, static_cast&lt;ValueType&gt;(<span class="hljs-number">0</span>))</span>;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FileMetaData*&gt; overlaps;<br>    <span class="hljs-keyword">while</span> (level &lt; config::kMaxMemCompactLevel) &#123;<br>      <span class="hljs-keyword">if</span> (OverlapInLevel(level + <span class="hljs-number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (level + <span class="hljs-number">2</span> &lt; config::kNumLevels) &#123;<br>        <span class="hljs-comment">// Check that file does not overlap too many grandparent bytes.</span><br>        GetOverlappingInputs(level + <span class="hljs-number">2</span>, &amp;start, &amp;limit, &amp;overlaps);<br>        <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> sum = TotalFileSize(overlaps);<br>        <span class="hljs-keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>      level++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Size-Compaction"><a href="#Size-Compaction" class="headerlink" title="Size Compaction"></a><strong>Size Compaction</strong></h2><p>在<code>DBImpl::BackgroundCompaction()</code> 中，如果要执行Size Compaction(或者Seek Compaction)，首先要执行<code>versions_-&gt;PickCompaction()</code> 函数，找到level层需要被合并的sst文件(1个)。</p><blockquote><p>注意，在Size Compaction中，对于level 0层级的合并(level 0 sst之间可能会有重叠)，输入文件可能不止1个sst文件，要添加所有与c-&gt;inputs_[0]重叠的sst作为输入文件。</p></blockquote><p>这里的文件是如何选取的呢？(什么依据，什么是<code>compact_pointer_</code> )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><blockquote><p><code>compact_pointer_</code> 后的第一个文件作为 Compaction 对象，即本层上一次 Compaction 区间之后的文件.</p></blockquote><p><code>PickCompaction</code> 函数最后调用了<code>SetupOtherInputs</code> 函数，这个函数主要是找到level + 1 层级中与input的sst文件相重叠的所有sst文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c">Compaction* <span class="hljs-title function_">VersionSet::PickCompaction</span><span class="hljs-params">()</span> &#123;<br>  Compaction* c;<br>  <span class="hljs-type">int</span> level;<br><br>  <span class="hljs-comment">// We prefer compactions triggered by too much data in a level over</span><br>  <span class="hljs-comment">// the compactions triggered by seeks.</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="hljs-number">1</span>);<br>  <span class="hljs-type">const</span> <span class="hljs-type">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != nullptr);<br>  <span class="hljs-keyword">if</span> (size_compaction) &#123;<br>    level = current_-&gt;compaction_level_;<br>    assert(level &gt;= <span class="hljs-number">0</span>);<br>    assert(level + <span class="hljs-number">1</span> &lt; config::kNumLevels);<br>    c = new Compaction(options_, level);<br><br>    <span class="hljs-comment">// Pick the first file that comes after compact_pointer_[level]</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;<br>      FileMetaData* f = current_-&gt;files_[level][i];<br>      <span class="hljs-keyword">if</span> (compact_pointer_[level].empty() ||<br>          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="hljs-number">0</span>) &#123;<br>        c-&gt;inputs_[<span class="hljs-number">0</span>].push_back(f);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (c-&gt;inputs_[<span class="hljs-number">0</span>].empty()) &#123;<br>      <span class="hljs-comment">// Wrap-around to the beginning of the key space</span><br>      c-&gt;inputs_[<span class="hljs-number">0</span>].push_back(current_-&gt;files_[level][<span class="hljs-number">0</span>]);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (seek_compaction) &#123;<br>    level = current_-&gt;file_to_compact_level_;<br>    c = new Compaction(options_, level);<br>    c-&gt;inputs_[<span class="hljs-number">0</span>].push_back(current_-&gt;file_to_compact_);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> nullptr;<br>  &#125;<br><br>  c-&gt;input_version_ = current_;<br>  c-&gt;input_version_-&gt;Ref();<br><br>  <span class="hljs-comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span><br>  <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>) &#123;<br>    InternalKey smallest, largest;<br>    GetRange(c-&gt;inputs_[<span class="hljs-number">0</span>], &amp;smallest, &amp;largest);<br>    <span class="hljs-comment">// Note that the next call will discard the file we placed in</span><br>    <span class="hljs-comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span><br>    <span class="hljs-comment">// which will include the picked file.</span><br>    current_-&gt;GetOverlappingInputs(<span class="hljs-number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="hljs-number">0</span>]);<br>    assert(!c-&gt;inputs_[<span class="hljs-number">0</span>].empty());<br>  &#125;<br><br>  SetupOtherInputs(c);<br><br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成了<code>PickCompaction</code> 后，首先判断<code>inputs_[1]</code> 文件列表是否为空，如果为空就直接把文件移动到下一层，不需要进行多路归并的合并操作。(这段代码体现在<code>BackgroundCompaction()  c-&gt;c-&gt;IsTrivialMove()</code> 中）</p><p>随后调用<code>DoCompactionWork</code> 函数。</p><p>首先来看调用的是:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">Iterator* <span class="hljs-title function_">VersionSet::MakeInputIterator</span><span class="hljs-params">(Compaction* c)</span> &#123;<br>  ReadOptions options;<br>  options.verify_checksums = options_-&gt;paranoid_checks;<br>  options.fill_cache = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-comment">// Level-0 files have to be merged together.  For other levels,</span><br>  <span class="hljs-comment">// we will make a concatenating iterator per level.</span><br>  <span class="hljs-comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> space = (c-&gt;level() == <span class="hljs-number">0</span> ? c-&gt;inputs_[<span class="hljs-number">0</span>].size() + <span class="hljs-number">1</span> : <span class="hljs-number">2</span>);<br>  Iterator** <span class="hljs-built_in">list</span> = new Iterator*[space];<br>  <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> which = <span class="hljs-number">0</span>; which &lt; <span class="hljs-number">2</span>; which++) &#123;<br>    <span class="hljs-keyword">if</span> (!c-&gt;inputs_[which].empty()) &#123;<br>      <span class="hljs-keyword">if</span> (c-&gt;level() + which == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; files.size(); i++) &#123;<br>          <span class="hljs-built_in">list</span>[num++] = table_cache_-&gt;NewIterator(options, files[i]-&gt;number,<br>                                                  files[i]-&gt;file_size);<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Create concatenating iterator for the files from this level</span><br>        <span class="hljs-built_in">list</span>[num++] = NewTwoLevelIterator(<br>            new Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),<br>            &amp;GetFileIterator, table_cache_, options);<br>      &#125;<br>    &#125;<br>  &#125;<br>  assert(num &lt;= space);<br>  Iterator* result = NewMergingIterator(&amp;icmp_, <span class="hljs-built_in">list</span>, num);<br>  delete[] <span class="hljs-built_in">list</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MakeInputIterator</code> 返回的是MergeIterator，包含了对<code>c-&gt;inputs_</code>两层文件的迭代器。<br>它的实现也相当值的研究，首先，如果是level 0层级的sstable，由于不同sst之间可能存在着重叠，所以每一个sst都需要一个迭代器；而对于level &gt; 0层级的sst，由于整体文件是有序的，所以只需要一个迭代器。关于迭代器的结构下面会进行讲解。</p><p>最后返回一个<code>MergingIterator</code> ,到此，level n和 level n+1的sst文件就已经可以使用一个<strong>统一的、有序的</strong> 迭代器进行访问了。</p><p>再回到<code>DoCompactionWork</code> 的代码：</p><ol><li>判断当前是否有需要Minor Compaction的Immutable MemTable，如果有则让出任务，先进行Minor Compaction（该过程需要加锁）。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="hljs-built_in">std</span>::memory_order_acquire)) &#123;<br>    <span class="hljs-comment">// Prioritize immutable compaction work</span><br>    <span class="hljs-keyword">if</span> (has_imm_.load(<span class="hljs-built_in">std</span>::memory_order_relaxed)) &#123;<br>      <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> imm_start = env_-&gt;NowMicros();<br>      mutex_.Lock();<br>      <span class="hljs-keyword">if</span> (imm_ != nullptr) &#123;<br>        CompactMemTable();<br>        <span class="hljs-comment">// Wake up MakeRoomForWrite() if necessary.</span><br>        background_work_finished_signal_.SignalAll();<br>      &#125;<br>      mutex_.Unlock();<br>      imm_micros += (env_-&gt;NowMicros() - imm_start);<br>    &#125;<br>    .................<br></code></pre></td></tr></table></figure><ol start="2"><li>通过<code>ShouldStopBefore</code>方法估算当前SSTable大小，并判断其是否超过了<code>max_file_size</code>的限制，如果超过了则通过<code>FinishCompactionOutputFile</code>完整对当前SSTable的写入。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//接上</span><br> Slice key = input-&gt;key();<br> <span class="hljs-keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp; compact-&gt;builder != nullptr) &#123;<br>     status = FinishCompactionOutputFile(compact, input);<br>     <span class="hljs-keyword">if</span> (!status.ok()) &#123;<br>        <span class="hljs-keyword">break</span>;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><p>接下来我们就开始遍历所有需要进行合并的所有<code>InternalKey</code> ，并判断是否丢弃这个<code>InternalKey</code> ，什么情况下需要丢弃这个<code>InternalKey</code> 呢?</p><p>3.1 对于多次出现的user key，我们只关心最后写入的值 or &gt;snapshot的值</p><blockquote><p>我们需要保留一个小于等于 snapshot 的版本(如果有的话)。也就是对于重复的key，我们只需要保存最新的(遍历到的第1个)。大于compact-&gt;smallest_snapshot的版本都需要保存。这里也就是把snapshot过低的版本(snapshot number &lt; compact-&gt;smallest_snapshot的版本)全部给删除掉。</p></blockquote><p>3.2 如果是删除key &amp;&amp; &lt;&#x3D; snapshot 并且 更高层没有该key，那么也可以忽略</p><blockquote><p>对于<code>kTypeDeletion</code>类型，虽然可以丢弃在smallest_snapshot前的key，但是还需要保证在更高的level中没有该UserKey，否则在查询时，在当前level失配后会在下层中找到该UserKey的更旧的版本。</p></blockquote></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> drop = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;<br>      <span class="hljs-comment">// Do not hide error keys</span><br>      current_user_key.clear();<br>      has_current_user_key = <span class="hljs-literal">false</span>;<br>      last_sequence_for_key = kMaxSequenceNumber;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (!has_current_user_key ||<br>          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=<br>              <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// First occurrence of this user key</span><br>        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());<br>        has_current_user_key = <span class="hljs-literal">true</span>;<br>        last_sequence_for_key = kMaxSequenceNumber;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;<br>        drop = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// (A)</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;<br>                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;<br>                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;<br>        drop = <span class="hljs-literal">true</span>;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析1-总体介绍</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901-%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a><strong>总体介绍</strong></h2><h3 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a><strong>LSM-Tree</strong></h3><p>Log Structured Merge Tree，简称 LSM-Tree。LSM-Tree 通过将磁盘的随机写转化为顺序写来提高写性能 ，而付出的代价就是牺牲部分读性能、写放大。</p><h3 id="如何优化写性能？"><a href="#如何优化写性能？" class="headerlink" title="如何优化写性能？"></a><strong>如何优化写性能？</strong></h3><p>Append only：所有写操作都是将数据添加到文件末尾。<br>缺点是不支持有序遍历、需要垃圾回收</p><h3 id="如何优化读性能"><a href="#如何优化读性能" class="headerlink" title="** 如何优化读性能**"></a>** 如何优化读性能**</h3><p>有序和哈希</p><h3 id="读写性能的权衡"><a href="#读写性能的权衡" class="headerlink" title="读写性能的权衡"></a><strong>读写性能的权衡</strong></h3><p>如何获得接近 append only 的写性能，而又能拥有不错的读性能呢？以 LevelDB为代表的 LSM-Tree 存储引擎给出了一个参考答案。LevelDB 的写操作（Put&#x2F;Delete&#x2F;Write）主要由两步组成：</p><ol><li>写日志（WAL，顺序写）。</li><li>写 <code>MemTable</code>（内存中的 <code>SkipList</code>）。</li></ol><p>所以，正常情况下，LevelDB 的写速度非常快。<br>内存中的 <code>MemTable</code> 写满后，会转换为 Immutable MemTable，然后被后台线程 compact 成按 key 有序存储的 <code>SSTable</code>（顺序写）。 SSTable 按照数据从新到旧被组织成多个层次（上层新下层旧），点查询（Get）的时候从上往下一层层查找（先查找内存中的memtable，如果没找到再往下按层查找sstable），上层的数据比下层的数据要新，所以查找到的数据也是最新的。 LevelDB 的读操作可能会有多次磁盘 IO（LevelDB 通过 table cache、block cache 和 bloom filter 等优化措施来减少读操作的 I&#x2F;O 次数）。 后台线程的定期 compaction 负责回收过期数据和维护每一层数据的有序性。在数据局部有序的基础上，LevelDB 实现了数据的（全局）有序遍历。</p><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a><strong>简单介绍</strong></h3><ol><li>MemTable：内存数据结构，具体实现是 <code>SkipList</code>。 接受用户的读写请求，新的数据会先在这里写入。</li><li>Immutable MemTable：当 MemTable 的大小达到设定的阈值后，会被转换成 Immutable MemTable，只接受读操作，不再接受写操作，然后由后台线程 flush 到磁盘上 —— 这个过程称为 minor compaction。</li><li>Log：数据写入 MemTable 之前会先写日志，用于防止宕机导致 MemTable 的数据丢失。一个日志文件对应到一个 MemTable。</li><li>SSTable：Sorted String Table。分为 level-0 到 level-n 多层，每一层包含多个 SSTable，文件内数据有序。除了 level-0 之外，每一层内部的 SSTable 的 key 范围都不相交。</li><li>Manifest：Manifest 文件中记录 SSTable 在不同 level 的信息，包括每一层由哪些 SSTable，每个 SSTable 的文件大小、最大 key、最小 key 等信息。</li><li>Current：重启时，LevelDB 会重新生成 Manifest，所以 Manifest 文件可能同时存在多个，Current 记录的是当前使用的 Manifest 文件名。</li><li>TableCache：TableCache 用于缓存 SSTable 的文件描述符、索引和 filter。</li><li>BlockCache：SSTable 的数据是被组织成一个个 block。BlockCache 用于缓存这些 block（解压后）的数据。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析10-Cache</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9010-Cache/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9010-Cache/</url>
    
    <content type="html"><![CDATA[<h2 id="Leveldb中的缓存机制"><a href="#Leveldb中的缓存机制" class="headerlink" title="** Leveldb中的缓存机制**"></a>** Leveldb中的缓存机制**</h2><p>这篇文章将讲解LevelDB缓存模块的相关内容，本文内容比较简单，读者只需按照顺序阅读即可。</p><p>leveldb中的缓存分为两种:</p><ol><li>sstable的<code>table_cache_</code> (类<code>DBImpl</code> 中)</li><li>Block的<code>block_cache_</code> (可选，在<code>options</code> 中)</li></ol><p>sstable的Cache就是缓存(Key:<code>file_number</code>    Value:<code>TableAndFile</code> )，其中<code>TableAndFile</code> 是关于sstable的元数据，记录的是sst在内存中的<code>table</code> 结构体信息和<code>RandomAccessFile</code> 的文件描述符的信息。所以<code>table_cache_</code> 缓存的不是sst文件的内容，而是sst文件的信息。</p><p>Block的Cache缓存(Key:table的cache_id和Block的offset拼接而成   Value：Block结构体)，所以<code>block_cache</code> 缓存的是真正的内容。</p><p>我们在LevelDB的源代码中分别看一下这两种Cache.</p><h2 id="Table-Cache"><a href="#Table-Cache" class="headerlink" title="Table Cache"></a><strong>Table Cache</strong></h2><p>首先我们从<code>Version::Get</code>方法出发，这里调用了一个<code>table_cache_</code> 的Get方法，这个Get方法会调用<code>FindTable</code> 的函数。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">state</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">s</span> = state-&gt;</span><span class="hljs-function"><span class="hljs-title">vset</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">table_cache_</span>-&gt;</span>G<span class="hljs-function"><span class="hljs-title">et</span>(*state-&gt;</span><span class="hljs-function"><span class="hljs-title">options</span>, f-&gt;</span>number,<br>                                                <span class="hljs-function"><span class="hljs-title">f</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">file_size</span>, state-&gt;</span>ikey,<br>                                                &amp;<span class="hljs-function"><span class="hljs-title">state</span>-&gt;</span>saver, SaveValue);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">TableCache::Get</span><span class="hljs-params">(<span class="hljs-type">const</span> ReadOptions&amp; options, <span class="hljs-type">uint64_t</span> file_number,</span><br><span class="hljs-params">                       <span class="hljs-type">uint64_t</span> file_size, <span class="hljs-type">const</span> Slice&amp; k, <span class="hljs-type">void</span>* arg,</span><br><span class="hljs-params">                       <span class="hljs-type">void</span> (*handle_result)(<span class="hljs-type">void</span>*, <span class="hljs-type">const</span> Slice&amp;,</span><br><span class="hljs-params">                                             <span class="hljs-type">const</span> Slice&amp;))</span> &#123;<br>  Cache::Handle* handle = nullptr;<br>  Status s = FindTable(file_number, file_size, &amp;handle);<br>  <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>    Table* t = reinterpret_cast&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;<br>    s = t-&gt;InternalGet(options, k, arg, handle_result);<br>    cache_-&gt;Release(handle);<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来看一下这个<code>FindTable</code> 函数里面是什么：</p><p>这里面，首先会在<code>cache_</code> 里面寻找是否存在这个<code>file_number</code> 的缓存信息。如果不存在，那么就要新建一个<code>TableAndFile</code> ，把(<code>file_number</code> ，<code>TableAndFile</code>)插入进<code>table_cache_</code> 的缓存中。这样下次命中的时候，就可以利用缓存知道sst的元数据信息，不需要重新解析sstable文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">TableCache::FindTable</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> file_number, <span class="hljs-type">uint64_t</span> file_size,</span><br><span class="hljs-params">                             Cache::Handle** handle)</span> &#123;<br>  Status s;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-keyword">sizeof</span>(file_number)];<br>  EncodeFixed64(buf, file_number);<br>  Slice <span class="hljs-title function_">key</span><span class="hljs-params">(buf, <span class="hljs-keyword">sizeof</span>(buf))</span>;<br>  *handle = cache_-&gt;Lookup(key);<br>  <span class="hljs-keyword">if</span> (*handle == nullptr) &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fname = TableFileName(dbname_, file_number);<br>    RandomAccessFile* file = nullptr;<br>    Table* table = nullptr;<br>    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);<br>    <span class="hljs-keyword">if</span> (!s.ok()) &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> old_fname = SSTTableFileName(dbname_, file_number);<br>      <span class="hljs-keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;file).ok()) &#123;<br>        s = Status::OK();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>      s = Table::Open(options_, file, file_size, &amp;table);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!s.ok()) &#123;<br>      assert(table == nullptr);<br>      delete file;<br>      <span class="hljs-comment">// We do not cache error results so that if the error is transient,</span><br>      <span class="hljs-comment">// or somebody repairs the file, we recover automatically.</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      TableAndFile* tf = new TableAndFile;<br>      tf-&gt;file = file;<br>      tf-&gt;table = table;<br>      *handle = cache_-&gt;Insert(key, tf, <span class="hljs-number">1</span>, &amp;DeleteEntry);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Block-Cache"><a href="#Block-Cache" class="headerlink" title="Block Cache"></a><strong>Block Cache</strong></h2><p>同样是<code>TableCache::Get</code> 函数，里面有这样一个函数<code>s = t-&gt;InternalGet(options, k, arg, handle_result);</code> <code>InternalGet</code> 中又调用了<code>BlockReader</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">BlockContents contents;<br><span class="hljs-keyword">if</span> (block_cache != nullptr) &#123;<br>  <span class="hljs-type">char</span> cache_key_buffer[<span class="hljs-number">16</span>];<br>  EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);<br>  EncodeFixed64(cache_key_buffer + <span class="hljs-number">8</span>, handle.offset());<br>  Slice <span class="hljs-title function_">key</span><span class="hljs-params">(cache_key_buffer, <span class="hljs-keyword">sizeof</span>(cache_key_buffer))</span>;<br>  cache_handle = block_cache-&gt;Lookup(key);<br>  <span class="hljs-keyword">if</span> (cache_handle != nullptr) &#123;<br>    block = reinterpret_cast&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);<br>    <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>      block = new Block(contents);<br>      <span class="hljs-keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;<br>        cache_handle = block_cache-&gt;Insert(key, block, block-&gt;size(),<br>                                           &amp;DeleteCachedBlock);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);<br>  <span class="hljs-keyword">if</span> (s.ok()) &#123;<br>    block = new Block(contents);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>BlockReader</code> 函数会判断<code>options</code> 里面是否开起来block层级的缓存，如果开起来，它就会把sst的cache_id(构建sst的时候单独递增的一个成员)和block的offset作为Key，把Block作为Value插入到缓存中。</p><h2 id="LRU缓存的实现"><a href="#LRU缓存的实现" class="headerlink" title="LRU缓存的实现"></a><strong>LRU缓存的实现</strong></h2><p>LRU（Least recently used）是一种资源淘汰策略，中文解释为最近最少使用，通俗理解就是<strong>当缓存容量达到阈值时，淘汰掉缓存中最长时间没有被访问的资源</strong>。</p><img src="/img/leveldb/lru.jpg" style="zoom: 25%;"><p>下图展示了LevelDB中缓存模块的结构，最外层ShardedLRUCache由多个LRUCache组成，LRUCache是一个LRU缓存单元，它由一个哈希表HandleTable和两个双向环形链表LRUHandle List组成。</p><img src="/img/leveldb/lrushared.png" style="zoom:50%;"><p>下面我们从内至外剖析上述缓存模块的各个单元。</p><h3 id="LRUHandle"><a href="#LRUHandle" class="headerlink" title="LRUHandle"></a><strong>LRUHandle</strong></h3><p>LRUHandle是LRU缓存中的基本数据单元，存储了数据的基本信息。LRUHandle中的键存储(<code>key_dada</code> )的是文件序号，与SSTable文件对象一一对应，引用计数refs表示节点被引用数，初使时为1，表示被缓存引用，用户访问节点时refs加1，释放时refs减1，当节点被缓存淘汰且无用户引用时将被销毁。其余属性含义请看下列注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LRUHandle</span> &#123;</span><br>  <span class="hljs-type">void</span>* value; <span class="hljs-comment">//缓存数据</span><br>  <span class="hljs-type">void</span> (*deleter)(<span class="hljs-type">const</span> Slice&amp;, <span class="hljs-type">void</span>* value); <span class="hljs-comment">//缓存数据析构器</span><br>  LRUHandle* next_hash; <span class="hljs-comment">//后继节点指针，哈希表中使用</span><br>  LRUHandle* next; <span class="hljs-comment">//后继节点，双向环形链表中使用</span><br>  LRUHandle* prev; <span class="hljs-comment">//前序节点，双向环形链表中使用</span><br>  <span class="hljs-type">size_t</span> charge;  <span class="hljs-comment">//占用的存储容量，一般设置为1</span><br>  <span class="hljs-type">size_t</span> key_length; <span class="hljs-comment">//键长</span><br>  <span class="hljs-type">bool</span> in_cache;     <span class="hljs-comment">// 标识节点是否被缓存引用</span><br>  <span class="hljs-type">uint32_t</span> refs;     <span class="hljs-comment">// 引用计数</span><br>  <span class="hljs-type">uint32_t</span> hash;     <span class="hljs-comment">// 键的哈希值，哈希表中计算哈希桶</span><br>  <span class="hljs-type">char</span> key_data[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 键值，动态内存分配</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>LRUHandle List就是以LRUHandle为节点的双向环形链表。</p><h3 id="HandleTable"><a href="#HandleTable" class="headerlink" title="HandleTable"></a><strong>HandleTable</strong></h3><p>HandleTable是链表存储式的哈希表，其存储节点为LRUHandle。每次节点查询时先根据目标键的哈希值找到对应的哈希桶，再沿着哈希桶中的链表查找目标哈希值的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">LRUHandle** <span class="hljs-title function_">FindPointer</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">uint32_t</span> hash)</span> &#123;<br>    <span class="hljs-comment">//找到哈希桶</span><br>    LRUHandle** ptr = &amp;list_[hash &amp; (length_ - <span class="hljs-number">1</span>)];<br>    <span class="hljs-comment">//链表遍历</span><br>    <span class="hljs-keyword">while</span> (*ptr != nullptr &amp;&amp; ((*ptr)-&gt;hash != hash || key != (*ptr)-&gt;key())) &#123;<br>      ptr = &amp;(*ptr)-&gt;next_hash;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br></code></pre></td></tr></table></figure><p>HandleTable的<strong>装填因子为1</strong>，当存储的数据量大于哈表表长度时就会进行扩容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Resize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">uint32_t</span> new_length = <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//2倍扩容</span><br>    <span class="hljs-keyword">while</span> (new_length &lt; elems_) &#123;<br>      new_length *= <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//构造新容量的哈希表</span><br>    LRUHandle** new_list = new LRUHandle*[new_length];<br>    <span class="hljs-built_in">memset</span>(new_list, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(new_list[<span class="hljs-number">0</span>]) * new_length);<br>    <span class="hljs-type">uint32_t</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//将原哈希表中数据分配到新的哈希桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; length_; i++) &#123;<br>      LRUHandle* h = list_[i];<br>      <span class="hljs-keyword">while</span> (h != nullptr) &#123;<br>        LRUHandle* next = h-&gt;next_hash;<br>        <span class="hljs-type">uint32_t</span> hash = h-&gt;hash;<br>        LRUHandle** ptr = &amp;new_list[hash &amp; (new_length - <span class="hljs-number">1</span>)]; <span class="hljs-comment">//重新分配哈希桶</span><br>        h-&gt;next_hash = *ptr; <span class="hljs-comment">//头插</span><br>        *ptr = h;<br>        h = next;<br>        count++;<br>      &#125;<br>    &#125;<br>        <br>    delete[] list_;<br>    list_ = new_list;<br>    length_ = new_length;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a><strong>LRUCache</strong></h3><p>LRUCache由一个哈希表和两个双向环形链表组成，是对LRU资源淘汰机制的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br>  <span class="hljs-comment">// 总容量</span><br>  <span class="hljs-type">size_t</span> capacity_;<br>  <span class="hljs-comment">// 互斥锁</span><br>  mutable port::Mutex mutex_;<br>  <span class="hljs-comment">// 已使用容量</span><br>  <span class="hljs-type">size_t</span> usage_ <span class="hljs-title function_">GUARDED_BY</span><span class="hljs-params">(mutex_)</span>;<br>  <span class="hljs-comment">//未使用节点环形链表，</span><br>  LRUHandle lru_ <span class="hljs-title function_">GUARDED_BY</span><span class="hljs-params">(mutex_)</span>;<br>  <span class="hljs-comment">//正在被引用的节点环形链表</span><br>  LRUHandle in_use_ <span class="hljs-title function_">GUARDED_BY</span><span class="hljs-params">(mutex_)</span>;<br>  <span class="hljs-comment">//哈希表，存储所有缓存节点</span><br>  HandleTable table_ <span class="hljs-title function_">GUARDED_BY</span><span class="hljs-params">(mutex_)</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>LRUCache中哈希表table_用于存储了所有缓存数据，这些缓存数据被两个双向环形链表分为正在被访问的缓存数据（in_use_）和未被访问的缓存数据（lru_），当缓存容量满后lru_中数据可能会被淘汰。lru_和in_use_都有一个<strong>空的头节点</strong>，越靠近头节点的元素越早被添加进链表中，所以当需要淘汰lru_中的数据时，靠近头节点的元素将优先被淘汰掉。</p><ul><li><strong>（1）缓存数据的插入</strong></li></ul><p>数据查询时，若缓存数据未命中，从原始数据中获取的数据将被插入缓存中，此时这个数据是被用户引用的，所以初始化数据节点LRUHandle时引用计数为1，随后将节点插入哈希表table_和使用链表in_use_中。若新数据插入后缓存空间已满，将从in_use_中<strong>移除溢出的数据</strong>，因为越靠近头节点的元素越早添加进链表中，<strong>对于in_use_链表而言就是越靠近头节点的数据越长时间没有被使用到</strong>，因此将从头节点开始遍历后继节点将<strong>溢出部分</strong>的数据节点移除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//哈希表 + 两个双向环形链表</span><br>Cache::Handle* <span class="hljs-title function_">LRUCache::Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">uint32_t</span> hash, <span class="hljs-type">void</span>* value,</span><br><span class="hljs-params">                                <span class="hljs-type">size_t</span> charge,</span><br><span class="hljs-params">                                <span class="hljs-type">void</span> (*deleter)(<span class="hljs-type">const</span> Slice&amp; key,</span><br><span class="hljs-params">                                                <span class="hljs-type">void</span>* value))</span> &#123;<br>  MutexLock <span class="hljs-title function_">l</span><span class="hljs-params">(&amp;mutex_)</span>;<br><span class="hljs-comment">//初始化LRUHandle节点</span><br>  LRUHandle* e =<br>      reinterpret_cast&lt;LRUHandle*&gt;(<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUHandle) - <span class="hljs-number">1</span> + key.size()));<br>  e-&gt;value = value;<br>  e-&gt;deleter = deleter;<br>  e-&gt;charge = charge;<br>  e-&gt;key_length = key.size();<br>  e-&gt;hash = hash;<br>  e-&gt;in_cache = <span class="hljs-literal">false</span>;<br>  e-&gt;refs = <span class="hljs-number">1</span>; <span class="hljs-comment">//通过insert接口插入的缓存节点肯定是当前正在被使用的，初始化引用计数为1</span><br>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">memcpy</span>(e-&gt;key_data, key.data(), key.size()); <span class="hljs-comment">//internal key</span><br><br>  <span class="hljs-keyword">if</span> (capacity_ &gt; <span class="hljs-number">0</span>) &#123;<br>    e-&gt;refs++;  <span class="hljs-comment">// 被缓存引用，当refs为0时表示被缓存淘汰了</span><br>    e-&gt;in_cache = <span class="hljs-literal">true</span>; <br>    LRU_Append(&amp;in_use_, e); <span class="hljs-comment">//插入in_use_链表中</span><br>    usage_ += charge;<br>    FinishErase(table_.Insert(e));<br>  &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-comment">// capacity_ &lt; 0说明不需要缓存</span><br>    e-&gt;next = nullptr;<br>  &#125;<br>   <span class="hljs-comment">// 当缓存数据量超出容量时，根据 LRU 策略将未被引用的数据中溢出部分淘汰</span><br>  <span class="hljs-keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) &#123;<br>    LRUHandle* old = lru_.next;<br>    assert(old-&gt;refs == <span class="hljs-number">1</span>);<br>    <span class="hljs-type">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash)); <span class="hljs-comment">//资源淘汰</span><br>    <span class="hljs-keyword">if</span> (!erased) &#123;  <span class="hljs-comment">// to avoid unused variable when compiled NDEBUG</span><br>      assert(erased);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> reinterpret_cast&lt;Cache::Handle*&gt;(e);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>（2）缓存数据淘汰</strong></li></ul><p>缓存数据淘汰时依次从哈希表和链表中将数据移除，缓存中不再持有该数据，数据节点引用计数减1，此时节点可能存在两种状态：</p><ul><li>该节点未被用户引用，引用计数为0，节点将被销毁</li><li>该节点正在被用户引用，引用计数不为0，节点等待用户释放后再进行销毁</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//哈希表中移除节点</span><br><span class="hljs-type">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">LRUCache::FinishErase</span><span class="hljs-params">(LRUHandle* e)</span> &#123;<br>  <span class="hljs-keyword">if</span> (e != nullptr) &#123;<br>    LRU_Remove(e); <span class="hljs-comment">//链表中移除节点</span><br>    e-&gt;in_cache = <span class="hljs-literal">false</span>;<br>    usage_ -= e-&gt;charge;<br>    Unref(e); <span class="hljs-comment">//引用计数减1，但此时资源不一定被销毁</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> e != nullptr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>(3）缓存数据节点引用与释放</strong></li></ul><p>当用户从缓存中查询数据时，将从哈希表中查询出对应数据节点，若命中则该节点可能存在以下两种状态：</p><ul><li>该节点未被其他用户引用，此时节点引用计数为1，节点添加至使用链表in_use_中，引用计数加1</li><li>该节点正在被其他用户引用，此时节点引用计数大于1，说明节点已经在使用链表in_use_中了，只需要将引用计数加1即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">Cache::Handle* <span class="hljs-title function_">LRUCache::Lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">uint32_t</span> hash)</span> &#123;<br>  MutexLock <span class="hljs-title function_">l</span><span class="hljs-params">(&amp;mutex_)</span>;<br>  LRUHandle* e = table_.Lookup(key, hash);<br>  <span class="hljs-keyword">if</span> (e != nullptr) &#123;<br>    Ref(e);<br>  &#125;<br>  <span class="hljs-keyword">return</span> reinterpret_cast&lt;Cache::Handle*&gt;(e);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">LRUCache::Ref</span><span class="hljs-params">(LRUHandle* e)</span> &#123;<br>  <span class="hljs-keyword">if</span> (e-&gt;refs == <span class="hljs-number">1</span> &amp;&amp; e-&gt;in_cache) &#123;  <br>    LRU_Remove(e);<br>    LRU_Append(&amp;in_use_, e);<br>  &#125;<br>  e-&gt;refs++;<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户进行节点释放后，引用计数减1，此时节点可能存在以下几种状态：</p><ul><li>该节点已经被缓存淘汰，用户释放后节点引用计数为0，在淘汰时节点已经从哈希表和相应链表中移除了，此时只需要进行节点销毁</li><li>该节点已经被缓存淘汰，但是正在被其他用户引用，引用计数仍然大于0，不做任何处理，当所有用户都释放后将命中上一条状态</li><li>该节点未被淘汰，且没有被其他用户引用，此时引用计数为1（缓存引用），节点将从使用链表in_use_中移除并添加至未使用链表lru_中</li><li>该节点未被淘汰，但是正在被其他用户引用，此时引用计数大于1，不做任何处理</li></ul><h3 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a><strong>ShardedLRUCache</strong></h3><p>ShardedLRUCache中包含多个LRUCache，它的主要功能是将缓存数据通过哈希分片存储到不同的LRU缓存模块中。哈希分片经常用于集群系统的横向扩容场景，这里主要为了避免将缓存数据存储在一个缓存模块中以降低资源竞态，提高数据访问的并发度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//分片数 1 &lt;&lt; 4</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNumShardBits = <span class="hljs-number">4</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNumShards = <span class="hljs-number">1</span> &lt;&lt; kNumShardBits;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShardedLRUCache</span> :</span> public Cache &#123;<br>private:<br>LRUCache shard_[kNumShards];<br>    <span class="hljs-comment">//取出哈希值的前4位进行分片</span><br><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title function_">Shard</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hash)</span> &#123; <span class="hljs-keyword">return</span> hash &gt;&gt; (<span class="hljs-number">32</span> - kNumShardBits); &#125;<br>public:<br>    Handle* <span class="hljs-title function_">Insert</span><span class="hljs-params">(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">void</span>* value, <span class="hljs-type">size_t</span> charge,</span><br><span class="hljs-params">                     <span class="hljs-type">void</span> (*deleter)(<span class="hljs-type">const</span> Slice&amp; key, <span class="hljs-type">void</span>* value))</span> override &#123;<br>        <span class="hljs-comment">//计算哈希值</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> hash = HashSlice(key);<br>        <span class="hljs-comment">//根据分片找到对应的LRUCache</span><br>        <span class="hljs-keyword">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LevelDB源码分析11-Compaction(1)</title>
    <link href="/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9011-Compaction(1)/"/>
    <url>/2024/02/26/%E6%95%B0%E6%8D%AE%E5%BA%93/leveldb%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9011-Compaction(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="Compaction-的作用"><a href="#Compaction-的作用" class="headerlink" title="Compaction 的作用"></a><strong>Compaction 的作用</strong></h2><p>因为 LevelDB 的增删改都是通过追加写来实现的，所以需要通过后台线程的 compaction 来：</p><ol><li>清理过期（旧版本或者已删除）的数据。</li><li>维护数据的有序性。</li></ol><h2 id="Compaction-的触发"><a href="#Compaction-的触发" class="headerlink" title="Compaction 的触发"></a><strong>Compaction 的触发</strong></h2><p>除了从外部调用 CompactRange，LevelDB 有几种情况会自动触发 compaction：</p><ol><li><p>当 MemTable 的大小达到阈值时，进行 MemTable 切换，然后需要将 Immutable MemTable 刷到外存上 —— 一般称之为 Minor Compaction。</p></li><li><p>当 level-n 的 SSTable 超过限制，level-n 和 level-n+1 的 SSTable 会进行 compaction —— 一般称之为 Major Compaction。</p></li><li><ol><li>level-0 是通过 SSTable 的数量来判断是否需要 compaction。</li><li>level-n(n &gt; 0) 是通过 SSTable 的大小来判断是否需要 compaction。</li></ol></li></ol><ul><li><p>level0中的sst文件之间可能会存在key的重叠，但level大于0的sst文件之间的key是不存在重叠的。</p></li><li><p>每次版本更新后，都会调用<code>Finalize()</code> 函数计算各level的分数，分数大于1的会发生compaction。</p></li></ul><p>算分的<code>Finalize()</code> 函数非常简单，但对于level0的算分就有一点特殊，它是以文件的个数作为标准，而其他level的算分都是以文件的总字节数除以阈值作为参考。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">VersionSet::Finalize</span><span class="hljs-params">(Version* v)</span> &#123;<br>  <span class="hljs-comment">// Precomputed best level for next compaction</span><br>  <span class="hljs-type">int</span> best_level = <span class="hljs-number">-1</span>;<br>  <span class="hljs-type">double</span> best_score = <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> level = <span class="hljs-number">0</span>; level &lt; config::kNumLevels - <span class="hljs-number">1</span>; level++) &#123;<br>    <span class="hljs-type">double</span> score;<br>    <span class="hljs-keyword">if</span> (level == <span class="hljs-number">0</span>) &#123;<br>      score = v-&gt;files_[level].size() /<br>              static_cast&lt;<span class="hljs-type">double</span>&gt;(config::kL0_CompactionTrigger);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Compute the ratio of current size to size limit.</span><br>      <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);<br>      score =<br>          static_cast&lt;<span class="hljs-type">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (score &gt; best_score) &#123;<br>      best_level = level;<br>      best_score = score;<br>    &#125;<br>  &#125;<br><br>  v-&gt;compaction_level_ = best_level;<br>  v-&gt;compaction_score_ = best_score;<br>&#125;   <br></code></pre></td></tr></table></figure><h2 id="Minor-Compaction"><a href="#Minor-Compaction" class="headerlink" title="Minor Compaction"></a><strong>Minor Compaction</strong></h2><p>Minor Compaction在MemTable大小超过限制时（默认为4MB）触发，LevelDB在写入变更前，首先会通过<code>DBImpl::MakeRoomForWrite</code>方法来在MemTable过大时将其转为Immutable MemTable，在该方法中，我们也能够找到尝试触发Compcation调度的调用。这里我们完整地看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// REQUIRES: mutex_ is held</span><br><span class="hljs-comment">// REQUIRES: this thread is currently at the front of the writer queue</span><br>Status <span class="hljs-title function_">DBImpl::MakeRoomForWrite</span><span class="hljs-params">(<span class="hljs-type">bool</span> force)</span> &#123;<br>  mutex_.AssertHeld();<br>  assert(!writers_.empty());<br>  <span class="hljs-type">bool</span> allow_delay = !force;<br>  Status s;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!bg_error_.ok()) &#123;<br>      <span class="hljs-comment">// Yield previous error</span><br>      s = bg_error_;<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="hljs-number">0</span>) &gt;=<br>                                  config::kL0_SlowdownWritesTrigger) &#123;<br>      mutex_.Unlock();<br>      env_-&gt;SleepForMicroseconds(<span class="hljs-number">1000</span>);<br>      allow_delay = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Do not delay a single write more than once</span><br>      mutex_.Lock();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!force &amp;&amp;<br>               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;<br>      <span class="hljs-comment">// There is room in current memtable</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imm_ != nullptr) &#123;<br>      <span class="hljs-comment">// We have filled up the current memtable, but the previous</span><br>      <span class="hljs-comment">// one is still being compacted, so we wait.</span><br>      Log(options_.info_log, <span class="hljs-string">&quot;Current memtable full; waiting...\n&quot;</span>);<br>      background_work_finished_signal_.Wait();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="hljs-number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;<br>      <span class="hljs-comment">// There are too many level-0 files.</span><br>      Log(options_.info_log, <span class="hljs-string">&quot;Too many L0 files; waiting...\n&quot;</span>);<br>      background_work_finished_signal_.Wait();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Attempt to switch to a new memtable and trigger compaction of old</span><br>      assert(versions_-&gt;PrevLogNumber() == <span class="hljs-number">0</span>);<br>      <span class="hljs-type">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber();<br>      WritableFile* lfile = nullptr;<br>      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);<br>      <span class="hljs-keyword">if</span> (!s.ok()) &#123;<br>        <span class="hljs-comment">// Avoid chewing through file number space in a tight loop.</span><br>        versions_-&gt;ReuseFileNumber(new_log_number);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      delete log_;<br>      delete logfile_;<br>      logfile_ = lfile;<br>      logfile_number_ = new_log_number;<br>      log_ = new <span class="hljs-built_in">log</span>::Writer(lfile);<br>      imm_ = mem_;<br>      has_imm_.store(<span class="hljs-literal">true</span>, <span class="hljs-built_in">std</span>::memory_order_release);<br>      mem_ = new MemTable(internal_comparator_);<br>      mem_-&gt;Ref();<br>      force = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Do not force another compaction if have room</span><br>      MaybeScheduleCompaction();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li>如果当前level-0中的SSTable数即将超过最大限制（默认为8，而当level-0的SSTable数达到4时即可触发Minor Compaction），这可能是写入过快导致的。此时会开启流控，将每条写入都推迟1ms，以给Minor Compaction留出时间。如果调用该方法时参数<code>force</code>为true，则不会触发流控。</li><li>如果<code>force</code>为false且MemTable估算的大小没有超过限制（默认为4MB），则直接退出，不需要进行Minor Compaction。</li><li>如果此时有未完成Minor Compaction的Immutable MemTable，此时循环等待Minor Compaction执行完成再执行。</li><li>如果当前level-0层的SSTable数过多（默认为8），此时循环等待level-0层SSTable数低于该上限，以避免level-0层SSTable过多</li></ol><p><code>DBImpl::MakeRoomForWrite</code>方法在判断是否需要进行Minor Compaction时，LevelDB通过流控与等待的方式，避免level-0层SSTable数过多。这是因为level-0层的key之间是有重叠的，因此当查询level-0层SSTable时，需要查找level-0层的所有SSTable。如果level-0层SSTable太多，会严重拖慢查询效率。</p><h2 id="Size-Compaction"><a href="#Size-Compaction" class="headerlink" title="Size Compaction"></a><strong>Size Compaction</strong></h2><p>对于Size Compaction，level-i层的SSTable输入根据该level的Compaction Pointer（记录在Version中），选取上次Compaction后的第一个SSTable（如果该层还没发生过Compaction）。这是为了尽可能公平地为Size Compaction选取SSTable，避免某些SSTable永远不会被Compact。</p><p>Size Compaction在非level-0层是根据该层的总SSTable大小触发的，而在level-0层是根据该层SSTable数触发的。也就是说，只有发生了Compaction，才有可能触发Size Compaction。因为Compaction的执行会导致Version的更新，因此LevelDB在<code>VersionSet::LogAndApply</code>方法更新Version后，让其调用<code>VersionSet::Finalize</code>方法来计算每层SSTable是否需要Size Compaction，并选出最需要进行Size Compaction的层作为下次Size Compaction的目标。</p><h2 id="Seek-Compaction"><a href="#Seek-Compaction" class="headerlink" title="Seek Compaction"></a><strong>Seek Compaction</strong></h2><p>在介绍Seek Compaction触发条件前，我们先来看为什么需要Seek Compaction。</p><p>在LSM-Tree中，除了level-0外，虽然每个level的SSTable间相互没有overlap，但是level与level间的SSTable是可以有overlap的，如下图中的实例所示。</p><img src="/img/leveldb/seek-1.png" style="zoom:40%;"><p>在本例中，如果查找键<code>18</code>时在level-k前都没有命中，则查询会下推到level-k。在level-k层中，因为SSTable(k, i + 1)的key范围覆盖了<code>18</code>，LevelDB会在该SSTable中查找是否存在要查找的key <code>18</code>（实际上查找的是该SSTable在TableCache中的filter），该操作被称为“seek”。当LevelDB在level-k中没有找到要查找的key时，才会继续在level-(k+1)中查找。</p><img src="/img/leveldb/seek-2.png" style="zoom:40%;"><p>在上图的示例中，每当LevelDB要查找key <code>18</code>时，因为SSTable(k, i)的key范围覆盖了<code>18</code>，所以其每次都必须在该SSTable中seek，这一不必要的seek操作会导致性能下降。因此，在FileMetaData结构体中引入了<code>allowed_seeks</code>字段，该字段初始为文件大小与16KB的比值，不足100则取100；每次无效seek发生时LevelDB都会将该字段值减1。当某SSTable的<code>allowed_seeks</code>减为0时，会触发seek compaction，该SSTable会与下层部分SSTable合并。合并后的SSTable如下图所示。</p><img src="/img/leveldb/seek-3.png" style="zoom:40%;">]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>LevelDB源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>LevelDB源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation(1)/"/>
    <url>/2024/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Transformation(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="Transformation变换-1"><a href="#Transformation变换-1" class="headerlink" title="Transformation变换(1)"></a>Transformation变换(1)</h1><h2 id="1-基础变换"><a href="#1-基础变换" class="headerlink" title="1.基础变换"></a>1.基础变换</h2><p>引入齐次坐标，对于二维平面：<br>点 (x, y) ，其齐次坐标为：(x, y ,1)<br>向量(x, y)，其齐次坐标为：(x, y, 0)<br>可以保证加减性质不变：</p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005003842.png?x-oss-process=image/resize,p_50" alt="img"></p><p>想一想：点 + 点表示的是上面：</p><blockquote><p>表示的是两个点连线的中点、</p></blockquote><h3 id="1-1-缩放"><a href="#1-1-缩放" class="headerlink" title="1.1 缩放"></a>1.1 缩放</h3><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005000454.png?x-oss-process=image/resize,p_30" alt="img"></p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005004405.png?x-oss-process=image/resize,p_50" alt="img"></p><h3 id="1-2旋转"><a href="#1-2旋转" class="headerlink" title="1.2旋转"></a>1.2旋转</h3><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005000555.png?x-oss-process=image/resize,p_30" alt="img"></p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005004420.png?x-oss-process=image/resize,p_50" alt="img"></p><h3 id="1-3平移"><a href="#1-3平移" class="headerlink" title="1.3平移"></a>1.3平移</h3><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005004453.png?x-oss-process=image/resize,p_30" alt="img"></p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005004437.png?x-oss-process=image/resize,p_50" alt="img"></p><h3 id="1-4仿射变换"><a href="#1-4仿射变换" class="headerlink" title="1.4仿射变换"></a>1.4仿射变换</h3><p>仿射变换 &#x3D; 线性变换 + 平移变换</p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005005155.png" alt="img"></p><h3 id="1-5复合变换"><a href="#1-5复合变换" class="headerlink" title="1.5复合变换"></a>1.5复合变换</h3><p>多个简单的变换矩阵可以组合成一个矩阵（相乘即可，注意顺序）<br>比如要将某个点绕着一个非原点的点（a, b）旋转a度，可以进行如下操作：<br>思路：</p><ol><li><p>我们先把点(a,b)看成原点，这就需要先做平移变换，将点平移(-a,-b)</p></li><li><p>然后绕着原点旋转a度</p></li><li><p>然后把点平移(a,b)</p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005010101.png?x-oss-process=image/resize,p_50" alt="img"></p></li></ol><h3 id="1-6逆变换"><a href="#1-6逆变换" class="headerlink" title="1.6逆变换"></a>1.6逆变换</h3><p>观察旋转矩阵,逆时针旋转 a 角度<br>$$<br>A &#x3D;<br>\begin{bmatrix}<br>\cos(\alpha) &amp; -\sin(\alpha) \<br>\sin(\alpha) &amp; \cos(\alpha)  \<br>\end{bmatrix}<br>$$<br>若要旋转 -a 角度，则其变换矩阵为：<br>$$<br>B &#x3D;<br>\begin{bmatrix}<br>\cos(\alpha) &amp; \sin(\alpha) \<br>-\sin(\alpha) &amp; \cos(\alpha)  \<br>\end{bmatrix}<br>$$<br>显然可以看出:<br>$$<br>A * B &#x3D; E<br>$$<br>转置矩阵与逆矩阵相等的矩阵称为<strong>正交矩阵</strong>。 且所有的<strong>旋转矩阵都是正交矩阵</strong></p><h2 id="2-3D变换"><a href="#2-3D变换" class="headerlink" title="2.3D变换"></a>2.3D变换</h2><p>3维空间同样适用二维的齐次坐标规则<br>3维的仿射变换：</p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005010406.png?x-oss-process=image/resize,p_50" alt="img"></p><h3 id="2-1缩放"><a href="#2-1缩放" class="headerlink" title="2.1缩放"></a>2.1缩放</h3><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005161153.png?x-oss-process=image/resize,p_50" alt="img"></p><h3 id="2-2平移"><a href="#2-2平移" class="headerlink" title="2.2平移"></a>2.2平移</h3><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005161223.png?x-oss-process=image/resize,p_50" alt="img"></p><h3 id="2-3旋转"><a href="#2-3旋转" class="headerlink" title="2.3旋转"></a>2.3旋转</h3><h4 id="2-3-1绕某一个轴旋转"><a href="#2-3-1绕某一个轴旋转" class="headerlink" title="2.3.1绕某一个轴旋转"></a>2.3.1绕某一个轴旋转</h4><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005161402.png?x-oss-process=image/resize,p_70" alt="img"></p><ul><li>注意：这里的绕y轴旋转公式与x和z轴有所不同。</li><li>xyz坐标系, x叉乘y得z, y叉乘z得x，y等于z叉乘x。xyz轴的关系：z-xy, x-yz, y-zx</li></ul><h3 id="2-3-2任意旋转"><a href="#2-3-2任意旋转" class="headerlink" title="2.3.2任意旋转"></a>2.3.2任意旋转</h3><p>任意角度的旋转都可以转换成绕x、y、z轴的旋转的组合<br>Rodrigues 旋转公式：</p><p><img src="https://irimskyblog.oss-cn-beijing.aliyuncs.com/content/20211005164937.png" alt="img"><br>其是3阶单位矩阵，矩阵 其实就是向量的叉积矩阵（被该矩阵作用得到的结果 等同于 与n向量叉积的结果）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>同步：信号量</title>
    <link href="/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <url>/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：另一种共享内存系统中常用的同步方法：信号量"><a href="#本讲内容：另一种共享内存系统中常用的同步方法：信号量" class="headerlink" title="本讲内容：另一种共享内存系统中常用的同步方法：信号量"></a>本讲内容：另一种共享内存系统中常用的同步方法：信号量</h2><ul><li>什么是信号量</li><li>信号量适合解决什么问题</li><li>哲 ♂ 学家吃饭问题</li></ul><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>在操作系统中，信号量就是一个变量（可以是整数或复杂的记录型变量），用来表示系统中某种资源的数量。</p><h3 id="Linux中的信号量"><a href="#Linux中的信号量" class="headerlink" title="Linux中的信号量"></a>Linux中的信号量</h3><ul><li>P操作：尝试在盒子中拿一个球，若盒子中没有球，则睡眠；否则就可以进入临界区。</li><li>V操作：尝试在盒子中放入一个球，若盒子已满，则睡眠；放入成功后，可唤醒在这个信号量上阻塞的线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> P sem_wait</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V sem_post</span><br></code></pre></td></tr></table></figure><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>对于任何计算图</p><ol><li>为每个节点分配一个线程</li><li>对每条入边执行 P (wait) 操作</li><li>完成计算任务</li><li>对每条出边执行 V (post&#x2F;signal) 操作<br>每条边恰好 P 一次、V 一次</li></ol><h3 id="优雅实现生产者-消费者问题"><a href="#优雅实现生产者-消费者问题" class="headerlink" title="优雅实现生产者-消费者问题"></a>优雅实现生产者-消费者问题</h3><p>回到上次课的打印合法括号问题（括号序列要合法，且嵌套深度不要超过n）<br>如何用信号量来解决这个问题呢？<br>我们想象有两个盒子，<strong>①号盒子表示当前左括号可以打印的个数</strong>，<strong>②号盒子表示当前右括号可以打印的个数</strong>。、</p><ul><li>初始的时候，①号盒子中放有n个球，②号盒子0个球</li><li>打印 ( 的时候，要先从①号盒子中拿出一个球（没有球就阻塞），再往②号盒子中放入一个球（满了也阻塞）。<br>转化成代码，也就是如下操作：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">P(①号盒子)    <span class="hljs-comment">// 左括号盒子中取出一个球</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>)  <span class="hljs-comment">// 打印</span><br>v(②号盒子)    <span class="hljs-comment">// 右括号盒子中放入一个球</span><br></code></pre></td></tr></table></figure></li><li>打印 ) 的时候，同理：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">P(②号盒子)    <span class="hljs-comment">// 右括号盒子中取出一个球</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>)  <span class="hljs-comment">// 打印</span><br>v(①号盒子)    <span class="hljs-comment">// 左括号盒子中放入一个球</span><br></code></pre></td></tr></table></figure></li></ul><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-type">sem_t</span> fill, empty;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    P(&amp;empty);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);<br>    V(&amp;fill);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    P(&amp;fill);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);<br>    V(&amp;empty);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  assert(argc == <span class="hljs-number">2</span>);<br>  SEM_INIT(&amp;fill, <span class="hljs-number">0</span>);<br>  SEM_INIT(&amp;empty, atoi(argv[<span class="hljs-number">1</span>]));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>    create(Tproduce);<br>    create(Tconsume);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>死锁会在 5 个哲学家 “同时吃饭” 时发生，如五个哲学家都拿了一只筷子。</p><blockquote><p>破坏这个条件即可,约定<strong>任何时候至多只有 4 个人可以吃饭</strong><br>四个人吃饭的时候至少一人就可以拿到两只筷子！</p></blockquote><p>也就是五个哲学家先从桌子上退出,有四张卡,凭卡入座。<br><strong>这里的卡就是信号量</strong>,初始化为 4。<br>五支筷子也需要五个信号量，初始化为 1.</p><blockquote><p>初始化为 1 的信号量与睡眠锁的作用是相同的，也就是说，睡眠锁可以看成是特殊的信号量。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 5</span><br><br><span class="hljs-type">sem_t</span> table, avail[N];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-type">int</span> lhs = (id + N - <span class="hljs-number">1</span>) % N;<br>  <span class="hljs-type">int</span> rhs = id % N;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// Come to table</span><br>    P(&amp;table);<br><br>    P(&amp;avail[lhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %d by T%d\n&quot;</span>, lhs, id);<br>    P(&amp;avail[rhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %d by T%d\n&quot;</span>, rhs, id);<br><br>    <span class="hljs-comment">// Eat</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %d by T%d\n&quot;</span>, lhs, id);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %d by T%d\n&quot;</span>, rhs, id);<br>    V(&amp;avail[lhs]);<br>    V(&amp;avail[rhs]);<br><br>    <span class="hljs-comment">// Leave table</span><br>    V(&amp;table);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  SEM_INIT(&amp;table, N - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    SEM_INIT(&amp;avail[i], <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    create(Tphilosopher);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步：生产者-消费者与条件变量</title>
    <link href="/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/"/>
    <url>/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%90%8C%E6%AD%A5%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>两个或两个以上随时间变化的量在变化过程中保持一定的相对关系。</p><p>再次把线程想象成自己</p><ul><li>NPY：等我洗个头就出门&#x2F;等我打完这局游戏就来</li><li>舍友：等我修好这个 bug 就吃饭</li><li>导师：等我出差回来就讨论这个课题<br>“先到先等”，<strong>在条件达成的瞬间再次恢复并行</strong><br>同时开始出去玩&#x2F;吃饭&#x2F;讨论</li></ul><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>99% 的实际并发问题都可以用生产者-消费者解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); &#125;<br></code></pre></td></tr></table></figure><p>在 <code>printf</code> 前后增加代码，使得打印的括号序列满足</p><ul><li>一定是某个合法括号序列的前缀</li><li>括号嵌套的深度不超过 n<ul><li>n&#x3D;3, <code>((())())(((</code> 合法</li><li>n&#x3D;3, <code>(((())))</code>, <code>(()))</code> 不合法</li></ul></li><li>生产者-消费者问题中的同步<ul><li><code>Tproduce</code>: 等到有空位时才能打印左括号</li><li><code>Tconsume</code>: 等到有多余的左括号时才能打印右括号</li></ul></li></ul><p>实现代码如下：<br>代码中的<code>mutex_lock</code>其实就是调用了<code>pthread_mutex_lock</code>,而<code>mutex_unlock</code>是调用了<code>pthread_mutex_unlock</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-type">int</span> n, count = <span class="hljs-number">0</span>;<br><span class="hljs-type">mutex_t</span> lk = MUTEX_INIT();<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_PRODUCE (count &lt; n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_CONSUME (count &gt; 0)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (!CAN_PRODUCE) &#123;<br>      mutex_unlock(&amp;lk);<br>      <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>);  <span class="hljs-comment">// Push an element into buffer</span><br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>retry:<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (!CAN_CONSUME) &#123;<br>      mutex_unlock(&amp;lk);<br>      <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br>    count--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>);  <span class="hljs-comment">// Pop an element from buffer</span><br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  assert(argc == <span class="hljs-number">2</span>);<br>  n = atoi(argv[<span class="hljs-number">1</span>]);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;<br>    create(Tproduce);<br>    create(Tconsume);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="什么是条件变量"><a href="#什么是条件变量" class="headerlink" title="什么是条件变量"></a>什么是条件变量</h3><p>条件变量是多线程程序中用来实现等待和唤醒逻辑常用的方法。通常有<code>wait</code>和<code>notify</code>两个动作，<code>wait</code>用于阻塞挂起线程A，直到另一个线程B通过通过<code>notify</code>唤醒线程A，唤醒后线程A会继续运行。</p><p>线程同步由<strong>条件不成立等待</strong>和<strong>同步条件达成继续</strong>构成。<br>那么在我们的生产者消费者模型中如何去使用条件变量呢。<br>生产者&#x2F;消费者问题</p><ul><li>Tproduce 同步条件：CAN_PRODUCE (count &lt; n)</li><li>Tproduce 达成同步：Tconsume count–</li><li>Tconsume 同步条件：CAN_CONSUME (count &gt; 0)</li><li>Tconsume 达成同步：Tproduce count++</li></ul><h3 id="条件变量错误的使用方式"><a href="#条件变量错误的使用方式" class="headerlink" title="条件变量错误的使用方式"></a>条件变量错误的使用方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-type">int</span> n, count = <span class="hljs-number">0</span>;<br><span class="hljs-type">mutex_t</span> lk = MUTEX_INIT();<br><span class="hljs-type">cond_t</span> cv = COND_INIT();<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_PRODUCE (count &lt; n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_CONSUME (count &gt; 0)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (!CAN_PRODUCE) &#123;<br>      cond_wait(&amp;cv, &amp;lk);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++;<br>    cond_signal(&amp;cv);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">if</span> (!CAN_CONSUME) &#123;<br>      cond_wait(&amp;cv, &amp;lk);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--;<br>    cond_signal(&amp;cv);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  assert(argc == <span class="hljs-number">3</span>);<br>  n = atoi(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-type">int</span> T = atoi(argv[<span class="hljs-number">2</span>]);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;<br>    create(Tproduce);<br>    create(Tconsume);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这里的 T 大于 1，也就是有多个consumer和多个producer，会发生什么呢？<br><code>signal</code>会随机唤醒一个线程，也就是存在这样一种可能一个consumer线程唤醒另一个consumer线程,而因为是<code>if</code>，所以这个consumer线程直接跳过了<code>!CAN_CONSUME</code>的判断，这样就导致了错误。</p><h3 id="条件变量正确的打开方式"><a href="#条件变量正确的打开方式" class="headerlink" title="条件变量正确的打开方式"></a>条件变量正确的打开方式</h3><p>看看上面的错误实现</p><ol><li><p>首先需要更改的就是<code>if</code>语句，这里应该改为一个判断的<code>while</code>循环(被唤醒时应该再次检查)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (!CAN_CONSUME) &#123;<br>  cond_wait(&amp;cv, &amp;lk);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由于<code>signal</code>只是随机唤醒一个阻塞在这个条件变量上的线程，再加上有了这个<code>while</code>循环，我们应该用<code>broadcast</code>唤醒所有阻塞在这个条件变量上的线程。（只能用<code>broadcast</code>)</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-type">int</span> n, count = <span class="hljs-number">0</span>;<br><span class="hljs-type">mutex_t</span> lk = MUTEX_INIT();<br><span class="hljs-type">cond_t</span> cv = COND_INIT();<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_PRODUCE (count &lt; n)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAN_CONSUME (count &gt; 0)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tproduce</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">while</span> (!CAN_PRODUCE) &#123;<br>      cond_wait(&amp;cv, &amp;lk);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(&quot;</span>); count++;<br>    cond_broadcast(&amp;cv);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tconsume</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    mutex_lock(&amp;lk);<br>    <span class="hljs-keyword">while</span> (!CAN_CONSUME) &#123;<br>      cond_wait(&amp;cv, &amp;lk);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;)&quot;</span>); count--;<br>    cond_broadcast(&amp;cv);<br>    mutex_unlock(&amp;lk);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  assert(argc == <span class="hljs-number">3</span>);<br>  n = atoi(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-type">int</span> T = atoi(argv[<span class="hljs-number">2</span>]);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;<br>    create(Tproduce);<br>    create(Tconsume);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="古怪的习题：打印小鱼"><a href="#古怪的习题：打印小鱼" class="headerlink" title="古怪的习题：打印小鱼"></a>古怪的习题：打印小鱼</h2><h2 id="有三种线程-Ta-若干-死循环打印-Tc-若干-死循环打印"><a href="#有三种线程-Ta-若干-死循环打印-Tc-若干-死循环打印" class="headerlink" title="有三种线程- Ta 若干: 死循环打印 &lt;- Tb 若干: 死循环打印 &gt;- Tc 若干: 死循环打印 _"></a>有三种线程<br>- Ta 若干: 死循环打印 &lt;<br>- Tb 若干: 死循环打印 &gt;<br>- Tc 若干: 死循环打印 _</h2><p>任务：</p><ul><li>对这些线程进行同步，使得屏幕打印出 &lt;&gt;&lt;_ 和 &gt;&lt;&gt;_ 的组合，_表示分隔符</li></ul><ul><li>状态机的视角：<br>初始状态为A，打印一个&lt;到状态B，或者打印一个&gt;到状态E。<blockquote><p>每个状态都有可以打印的字符，维护一个全局变量表示当前状态。<br>此外，由于不可以两个线程同时打印，所以还需一个quota变量保证只有一个线程可以进入临界区。</p></blockquote></li></ul><p>我们把状态转换图以代码形式表示出来。</p><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread-sync.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> A = <span class="hljs-number">1</span>, B, C, D, E, F, &#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rule</span> &#123;</span><br>  <span class="hljs-type">int</span> from, ch, to;<br>&#125; rules[] = &#123;<br>  &#123; A, <span class="hljs-string">&#x27;&lt;&#x27;</span>, B &#125;,<br>  &#123; B, <span class="hljs-string">&#x27;&gt;&#x27;</span>, C &#125;,<br>  &#123; C, <span class="hljs-string">&#x27;&lt;&#x27;</span>, D &#125;,<br>  &#123; A, <span class="hljs-string">&#x27;&gt;&#x27;</span>, E &#125;,<br>  &#123; E, <span class="hljs-string">&#x27;&lt;&#x27;</span>, F &#125;,<br>  &#123; F, <span class="hljs-string">&#x27;&gt;&#x27;</span>, D &#125;,<br>  &#123; D, <span class="hljs-string">&#x27;_&#x27;</span>, A &#125;,<br>&#125;;<br><span class="hljs-type">int</span> current = A, quota = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">mutex_t</span> lk = MUTEX_INIT();<br><span class="hljs-type">cond_t</span> cv = COND_INIT();<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(rules); i++) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rule</span> *<span class="hljs-title">rule</span> =</span> &amp;rules[i];<br>    <span class="hljs-keyword">if</span> (rule-&gt;from == current &amp;&amp; rule-&gt;ch == ch) &#123;<br>      <span class="hljs-keyword">return</span> rule-&gt;to;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">can_print</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>    <span class="hljs-keyword">return</span> next(ch) != <span class="hljs-number">0</span> &amp;&amp; quota &gt; <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fish_before</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>  mutex_lock(&amp;lk);<br>  <span class="hljs-keyword">while</span> (!can_print(ch)) &#123;<br>    <span class="hljs-comment">// can proceed only if (next(ch) &amp;&amp; quota)</span><br>    cond_wait(&amp;cv, &amp;lk);<br>  &#125;<br>  quota--;<br>  mutex_unlock(&amp;lk);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fish_after</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>  mutex_lock(&amp;lk);<br>  quota++;<br>  current = next(ch);<br>  assert(current);<br>  cond_broadcast(&amp;cv);<br>  mutex_unlock(&amp;lk);<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> roles[] = <span class="hljs-string">&quot;.&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;___&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">fish_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-type">char</span> role = roles[id];<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    fish_before(role);<br>    <span class="hljs-built_in">putchar</span>(role);  <span class="hljs-comment">// Not lock-protected</span><br>    fish_after(role);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(roles); i++)<br>    create(fish_thread);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发控制基础</title>
    <link href="/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><p>在介绍Peterson算法之前，我们首先对我们作出以下基本假设：内存的读&#x2F;写可以保证顺序、原子地完成。</p><h3 id="Peterson算法："><a href="#Peterson算法：" class="headerlink" title="Peterson算法："></a>Peterson算法：</h3><p>A 和 B 争用厕所的包厢</p><ul><li>想进入包厢之前，A&#x2F;B 都首先举起自己的旗子<ul><li>A 往厕所门上贴上 “B 正在使用” 的标签</li><li>B 往厕所门上贴上 “A 正在使用” 的标签</li></ul></li><li>然后，<strong>如果对方举着旗，且门上的名字是对方</strong>，等待<ul><li>否则可以进入包厢</li></ul></li><li>出包厢后，放下自己的旗子 (完全不管门上的标签)</li></ul><h3 id="如何验证该算法的正确性？"><a href="#如何验证该算法的正确性？" class="headerlink" title="如何验证该算法的正确性？"></a>如何验证该算法的正确性？</h3><p>jyy老师给出了一个用Python实现的model checker。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">T1</span>():<br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    heap.x = <span class="hljs-string">&#x27;🏴&#x27;</span><br>    sys_sched()<br>    heap.turn = <span class="hljs-string">&#x27;❷&#x27;</span><br>    sys_sched()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>      t = heap.turn<br>      sys_sched()<br>      y = heap.y != <span class="hljs-string">&#x27;&#x27;</span><br>      sys_sched()<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> y <span class="hljs-keyword">or</span> t == <span class="hljs-string">&#x27;❶&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    sys_sched()<br>    heap.cs += <span class="hljs-string">&#x27;❶&#x27;</span><br>    sys_sched()<br>    heap.cs = heap.cs.replace(<span class="hljs-string">&#x27;❶&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    sys_sched()<br>    heap.x = <span class="hljs-string">&#x27;&#x27;</span><br>    sys_sched()<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">T2</span>():<br>  <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    heap.y = <span class="hljs-string">&#x27;🏁&#x27;</span><br>    sys_sched()<br>    heap.turn = <span class="hljs-string">&#x27;❶&#x27;</span><br>    sys_sched()<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>      t = heap.turn<br>      sys_sched()<br>      x = heap.x<br>      sys_sched()<br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> x <span class="hljs-keyword">or</span> t == <span class="hljs-string">&#x27;❷&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>      sys_sched()<br>    sys_sched()<br>    heap.cs += <span class="hljs-string">&#x27;❷&#x27;</span><br>    sys_sched()<br>    heap.cs = heap.cs.replace(<span class="hljs-string">&#x27;❷&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>    sys_sched()<br>    heap.y = <span class="hljs-string">&#x27;&#x27;</span><br>    sys_sched()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>  heap.x = <span class="hljs-string">&#x27;&#x27;</span><br>  heap.y = <span class="hljs-string">&#x27;&#x27;</span><br>  heap.turn = <span class="hljs-string">&#x27;&#x27;</span><br>  heap.cs = <span class="hljs-string">&#x27;&#x27;</span><br>  sys_spawn(T1)<br>  sys_spawn(T2)<br></code></pre></td></tr></table></figure><p>其中<code>sys_spawn</code>和<code>sys_sched</code>函数的实现在前面的课中提到过，我没看到，在model checker中，为了保证我们的基本假设，我们看到在每一次读写变量的时候都调用了<code>sys_sched</code>函数。</p><h2 id="Compiler-barrier-volatile"><a href="#Compiler-barrier-volatile" class="headerlink" title="Compiler barrier&#x2F;volatile"></a>Compiler barrier&#x2F;volatile</h2><p>从模型回到现实，我们希望处理器和编译器能够配合，实现原子指令。实际上按照上面模型直接写的Peterson算法其实是错的。</p><p>Compiler barrier（编译器屏障）是一种编译器指令，用于告诉编译器在此处不要对代码进行优化重排。</p><blockquote><p>编译器提供 __sync_synchronize() 函数,它的作用是确保在执行该函数之前的所有写操作都完成，并且在执行该函数之后的所有读操作都开始。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BARRIER __sync_synchronize()</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TA</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    x = <span class="hljs-number">1</span>;                   BARRIER;<br>    turn = B;                BARRIER; <span class="hljs-comment">// &lt;- this is critcal for x86</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!y) <span class="hljs-keyword">break</span>;         BARRIER;<br>      <span class="hljs-keyword">if</span> (turn != B) <span class="hljs-keyword">break</span>;  BARRIER;<br>    &#125;<br>    critical_section();<br>    x = <span class="hljs-number">0</span>;                   BARRIER;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TB</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    y = <span class="hljs-number">1</span>;                   BARRIER;<br>    turn = A;                BARRIER;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">if</span> (!x) <span class="hljs-keyword">break</span>;         BARRIER;<br>      <span class="hljs-keyword">if</span> (turn != A) <span class="hljs-keyword">break</span>;  BARRIER;<br>    &#125;<br>    critical_section();<br>    y = <span class="hljs-number">0</span>;                   BARRIER;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就正确实现了Peterson算法。<br>通过使用内存屏障，可以强制编译器在特定位置插入同步指令，以确保对共享变量的读写操作按照预期顺序进行，并且对其他线程可见。这样，当一个线程在调用 <code>_sync_synchronize()</code>之前的写操作完成后，其他线程在调用 <code>_sync_synchronize()</code>之后的读操作才能看到这些写操作的结果，从而保证了线程间的正确同步和协作。</p><h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_inc</span><span class="hljs-params">(<span class="hljs-type">long</span> *ptr)</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;lock incq %0&quot;</span>  <span class="hljs-comment">// Atomic + memory fence</span></span><br><span class="hljs-params">    : <span class="hljs-string">&quot;+m&quot;</span>(*ptr)</span><br><span class="hljs-params">    :</span><br><span class="hljs-params">    : <span class="hljs-string">&quot;memory&quot;</span></span><br><span class="hljs-params">  )</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的这个<code>lock</code>就是总线<code>lock</code>,保证了多处理器中，只有一个处理器能够读写内存</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发Bug的应对</title>
    <link href="/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91Bug%E7%9A%84%E5%BA%94%E5%AF%B9/"/>
    <url>/2023/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B9%B6%E5%8F%91Bug%E7%9A%84%E5%BA%94%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：一节真正的-“编程-”课：如何正确地-并发-编程："><a href="#本讲内容：一节真正的-“编程-”课：如何正确地-并发-编程：" class="headerlink" title="本讲内容：一节真正的 “编程 ”课：如何正确地 (并发) 编程："></a>本讲内容：一节真正的 “编程 ”课：如何正确地 (并发) 编程：</h2><ul><li>Lock ordering</li><li>防御性编程</li><li>运行时检查</li></ul><h2 id="Lock-ordering"><a href="#Lock-ordering" class="headerlink" title="Lock ordering"></a>Lock ordering</h2><ul><li>任意时刻系统中的锁都是有限的</li><li>严格按照固定的顺序获得所有锁 (Lock Ordering)，就可以消灭循环等待</li><li>“在任意时刻获得 “最靠后” 锁的线程总是可以继续执行”<br>也就是为所有的锁固定一个顺序，某个线程想要获取某种资源就要按顺序去获得这些锁，这样就消除了<strong>循环等待</strong>。</li></ul><ul><li>哲学家就餐问题的解决<blockquote><p>先获取序号小的那把锁，再获取序号大的那把锁。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sem_t</span> avail[N];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tphilosopher</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>  <span class="hljs-type">int</span> lhs = (id + N - <span class="hljs-number">1</span>) % N;<br>  <span class="hljs-type">int</span> rhs = id % N;<br><br>  <span class="hljs-comment">// Enforce lock ordering</span><br>  <span class="hljs-keyword">if</span> (lhs &gt; rhs) &#123;<br>    <span class="hljs-type">int</span> tmp = lhs;<br>    lhs = rhs;<br>    rhs = tmp;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    P(&amp;avail[lhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %d by T%d\n&quot;</span>, lhs, id);<br>    P(&amp;avail[rhs]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %d by T%d\n&quot;</span>, rhs, id);<br><br>    <span class="hljs-comment">// Eat</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %d by T%d\n&quot;</span>, lhs, id);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %d by T%d\n&quot;</span>, rhs, id);<br>    V(&amp;avail[lhs]);<br>    V(&amp;avail[rhs]);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    SEM_INIT(&amp;avail[i], <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    create(Tphilosopher);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Bug-的本质和防御性编程"><a href="#Bug-的本质和防御性编程" class="headerlink" title="Bug 的本质和防御性编程"></a>Bug 的本质和防御性编程</h2><p>始终假设自己的代码是错的。<br>及早检查、及早报告、及早修复。<br>例如，多用断言<code>assert</code>函数<br>在xv6代码中也有防御性编程的智慧。</p><ol><li>避免连续两次<code>acquire</code>同一把锁的检查。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// acquire函数</span><br><span class="hljs-keyword">if</span>(holding(lk))<br>   panic(<span class="hljs-string">&quot;acquire&quot;</span>);<br></code></pre></td></tr></table></figure></li><li>避免连续两次<code>release</code>同一把锁的检查。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//release函数</span><br><span class="hljs-keyword">if</span>(!holding(lk))<br>   panic(<span class="hljs-string">&quot;release&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h2 id="自动运行时检查"><a href="#自动运行时检查" class="headerlink" title="自动运行时检查"></a>自动运行时检查</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-lab1</title>
    <link href="/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab1/"/>
    <url>/2023/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab1/</url>
    
    <content type="html"><![CDATA[<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>背景介绍<br>在这个实验中和下一个实验中，我们需要实现TCP receiver。它接收数据报，把它们转成可靠的字节流，以供socket读取。<br>TCP sender把字节流分成不同的segments，每个segment都封装成数据报。但是网络传送可能会丢失，重复或失序，这就需要TCP receiver重新组合，还原最初的字节流。</li><li>实验目的<br>完成一个数据结构<code>StreamReassembler</code>。它接收一些子串（字节流），以及每个子串第一个字节所在字节流的索引。<br><code>StreamReassembler</code>有一个成员<code>ByteStream</code>，只要<code>StreamReassembler</code>知道了字节流的下一个字节，就会把数据写入<code>ByteStream</code>中。</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><img src="https://s1.ax1x.com/2022/10/19/xsG8nP.png" alt="capacity.png" style="zoom:67%;" />如上图所示，`capacity`是整个缓存的大小，也就是`ByteStream`的大小，蓝色部分表示已经写入并被`ByteStream`读出来的部分；绿色部分表示已经写入`ByteStream`还没有被读的部分；红色部分是需要我们在一个buffer中缓存起来的部分，就是接收到的字节流，但这一部分字节流只是已经被缓存，但还没有重组，等到连续时一并写入`ByteSream`中。我们还记得，也就是`ByteStream`中有下面几个成员：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> capacity_;<br><span class="hljs-type">size_t</span> read_size_;     <span class="hljs-comment">//总共读取的字节数</span><br><span class="hljs-type">size_t</span> write_size_;    <span class="hljs-comment">//总共写入的字节数</span><br><span class="hljs-type">bool</span> end_input_;       <span class="hljs-comment">//能否再写</span><br></code></pre></td></tr></table></figure><p>所以就是说：</p><ul><li>上图中的first unread是<code>read_size_</code></li><li>上图的first unassembled是<code>write_size_</code>，表示第一个可以写到<code>ByteStream</code>中的字节</li><li>上图的first unacceptable是<code>read_size_ + capacity_</code></li></ul><p>所以有以下几种可能性：</p><ol><li>如果子字节流的<code>index</code>落在first unacceptable之后，那么这个substring应该被丢弃。</li><li>如果子字节流全部落在[0, first unassembled - 1]中，那么这个substring已经写入了<code>ByteStream</code>中，也应该丢弃</li><li>除此之外，应该截断子字节流，使之完全落在[first unassembled - 1, first unacceptable - 1]中</li></ol><p>完成了上述操作后，应该处理字节流区间重复的问题，必须要保证<code>set&lt;Segment&gt; _buffer</code>中每个<code>Segment</code>都必须彼此不重复，具体思路见代码。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先定义<code>Segment</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// stream_reassembler.hh</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segment</span>&#123;</span><br>  public:<br>    <span class="hljs-type">size_t</span> idx_;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data_;<br>  <br>    Segment():idx_(<span class="hljs-number">0</span>),data_(<span class="hljs-string">&quot;&quot;</span>)&#123;&#125;<br>    Segment(<span class="hljs-type">size_t</span> idx, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> data):idx_(idx), data_(data)&#123;&#125;<br><br>    <span class="hljs-type">bool</span> operator&lt;(<span class="hljs-type">const</span> Segment&amp; seg) <span class="hljs-type">const</span> &#123;<br>      <span class="hljs-keyword">return</span> this-&gt;idx_ &lt; seg.idx_;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>为<code>StreamReassembler</code>添加成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt; _buffer;<br><span class="hljs-type">bool</span> _eof;<br><span class="hljs-type">size_t</span> _eof_idx;<br><span class="hljs-type">size_t</span> _unassembled_bytes; <br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">handle_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> index)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">handle_overlap</span><span class="hljs-params">(Segment&amp; seg)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">adjustment</span><span class="hljs-params">(Segment&amp; seg, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator &amp;it)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">buffer_erase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator &amp;it)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">buffer_insert</span><span class="hljs-params">(Segment&amp; seg)</span>;<br></code></pre></td></tr></table></figure><blockquote><p> 上面的 <code>_buffer</code> 只存储位于上图中红色的区间<code>Segment</code>，红色区间的大小就为<code>_unassembled_bytes</code>。</p><p> <code>_eof_idx</code>就是当最后一个结束符号的索引，当 <code>_output</code>写的字节数(<code>bytes_written()</code>)等于 <code>_eof_idx</code> 时，应该结束输入，调用 <code>_output.end_input()</code>函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stream_reassembler.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a stream reassembler.</span><br><br><span class="hljs-comment">// For Lab 1, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab1`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `stream_reassembler.hh`</span><br><br>template &lt;typename... Targs&gt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> &#123;&#125;<br>using namespace <span class="hljs-built_in">std</span>;<br><br>StreamReassembler::StreamReassembler(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity) : <br>    _output(capacity), <br>    _capacity(capacity), <br>    _buffer(),<br>    _eof(<span class="hljs-literal">false</span>),<br>    _eof_idx(<span class="hljs-number">0</span>),<br>    _unassembled_bytes(<span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//! \details This function accepts a substring (aka a segment) of bytes,</span><br><span class="hljs-comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span><br><span class="hljs-comment">//! contiguous substrings and writes them into the output stream in order.</span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::handle_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index)</span>&#123;<br>    <br>    <span class="hljs-keyword">auto</span> seg = Segment&#123;index, data&#125;;<br><br>    <span class="hljs-comment">// 范围是[read_size_ , read_size_ + _capacity - 1],第一个不可以被写入的索引是 read_size_ + _capacity</span><br>    <span class="hljs-comment">//      [index, index + data.length() - 1]</span><br><br>    <span class="hljs-comment">// seg落在可写区域的外面 ok</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ &gt;= _output.bytes_read() + _capacity)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// seg.data_右端如果超出了右边界</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ &lt; _output.bytes_read() + _capacity &amp;&amp;<br>       seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span> &gt;= _output.bytes_read() + _capacity)&#123;<br>        <span class="hljs-comment">// [seg.idx_, read_size_ + _capacity - 1]</span><br>        seg.data_ = seg.data_.substr(<span class="hljs-number">0</span>, _output.bytes_read() + _capacity - seg.idx_);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果seg.data_都已经写入了ByteSream中 ok</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span> &lt; _output.bytes_written())&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果seg.data_有一部分已被写入，另一部分没有被写入</span><br>    <span class="hljs-keyword">if</span>(seg.idx_ &lt; _output.bytes_written() &amp;&amp; <br>       seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span> &gt;= _output.bytes_written())&#123;<br>        seg.data_ = seg.data_.substr(_output.bytes_written() - seg.idx_);<br>        seg.idx_ = _output.bytes_written();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(_buffer.empty())&#123;<br>        buffer_insert(seg);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    handle_overlap(seg);<br>&#125;<br><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::adjustment</span><span class="hljs-params">(Segment&amp; seg, <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator&amp; it)</span>&#123;<br>    <span class="hljs-comment">// [it_l , it_r]</span><br>    <span class="hljs-type">size_t</span> it_l = it-&gt;idx_;<br>    <span class="hljs-type">size_t</span> it_r = it-&gt;idx_ + it-&gt;data_.length() - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// [seg_l, seg_r]</span><br>    <span class="hljs-type">size_t</span> seg_l = seg.idx_;<br>    <span class="hljs-type">size_t</span> seg_r = seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 1. 如果 seg 全包含 it 的范围     </span><br>    <span class="hljs-comment">// _buffer去除 it</span><br>    <span class="hljs-keyword">if</span>(seg_l &lt;= it_l &amp;&amp; seg_r &gt;= it_r)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 如果it全包含 seg 的范围</span><br>    <span class="hljs-comment">// seg 变为 it, _buffer删除 it </span><br>    <span class="hljs-keyword">if</span>(it_l &lt;= seg_l &amp;&amp; it_r &gt;= seg_r)&#123;<br>        seg.idx_ = it_l;<br>        seg.data_ = it-&gt;data_;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 如图下：</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        seg:           _________</span><br><span class="hljs-comment">        it:        _______</span><br><span class="hljs-comment">    */</span><br>   <br>    <span class="hljs-keyword">if</span>(seg_l &gt;= it_l &amp;&amp; seg_r &gt; it_r)&#123;<br>        seg.data_ = it-&gt;data_ + seg.data_.substr(it-&gt;idx_ + it-&gt;data_.length() - seg.idx_);<br>        seg.idx_ = it-&gt;idx_;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br><br><br>    <span class="hljs-comment">// 4. 如下图：</span><br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">        seg:      _________</span><br><span class="hljs-comment">        it:            ________</span><br><span class="hljs-comment">    */</span><br>    <br>    <span class="hljs-keyword">if</span>(it_l &gt; seg_l &amp;&amp; it_r &gt;= seg_r)&#123;<br>        seg.data_ = seg.data_.substr(<span class="hljs-number">0</span>, it-&gt;idx_ - seg.idx_) + it-&gt;data_;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::handle_overlap</span><span class="hljs-params">(Segment&amp; seg)</span>&#123;<br>    <span class="hljs-comment">// 保证插入的和原本存在的没有重叠部分</span><br>    <span class="hljs-keyword">auto</span> it = _buffer.begin();<br>    <span class="hljs-keyword">for</span>(; it != _buffer.end();)&#123;<br>        <span class="hljs-type">size_t</span> it_l = it-&gt;idx_;<br>        <span class="hljs-type">size_t</span> it_r = it-&gt;idx_ + it-&gt;data_.length() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">size_t</span> seg_l = seg.idx_;<br>        <span class="hljs-type">size_t</span> seg_r = seg.idx_ + seg.data_.length() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 两条线段有重叠</span><br>        <span class="hljs-keyword">if</span>((it_l &gt;= seg_l &amp;&amp; it_l &lt;= seg_r) || (seg_l &gt;= it_l &amp;&amp; seg_l &lt;= it_r))&#123;<br>            adjustment(seg, it);<br>            buffer_erase(it++);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            it++;<br>        &#125;<br>    &#125;<br><br>    buffer_insert(seg);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::buffer_erase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;Segment&gt;::iterator&amp; it)</span>&#123;<br>    <span class="hljs-comment">// 如果删除了，那么 _unassembled_bytes 就要减</span><br>    _unassembled_bytes -= it-&gt;data_.length();<br>    _buffer.erase(it);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::buffer_insert</span><span class="hljs-params">(Segment&amp; seg)</span>&#123;<br>    _unassembled_bytes += seg.data_.length();<br>    _buffer.insert(seg);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">StreamReassembler::push_substring</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;data, <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> index, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> eof)</span> &#123;<br><br>    <span class="hljs-keyword">if</span>(!data.empty())&#123;<br>        handle_substring(data, index);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查 _buffer 中是否有连续的可写入 ByteStream 的部分</span><br>    <span class="hljs-comment">// 第一个可以写入的字节是 written_size_</span><br>    <span class="hljs-keyword">while</span>(!_buffer.empty() &amp;&amp; _buffer.begin()-&gt;idx_ == _output.bytes_written())&#123;<br>        <span class="hljs-keyword">auto</span> it = _buffer.begin();<br>        _output.write(it-&gt;data_);<br>        buffer_erase(it);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(eof)&#123;<br>        _eof = <span class="hljs-literal">true</span>;<br>        _eof_idx = index + data.length();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(_eof &amp;&amp; _output.bytes_written() == _eof_idx)&#123;<br>        _output.end_input();<br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">StreamReassembler::unassembled_bytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> _unassembled_bytes;<br>&#125;<br><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">StreamReassembler::empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> _buffer.empty();<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-lab0</title>
    <link href="/2023/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab0/"/>
    <url>/2023/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CS144/lab0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>获取实验指导书：<a href="https://vixbob.github.io/cs144-web-page/assignments/lab0.pdf">Lab Checkpoint 0: networking warmup</a><br>个人CS144实验地址：<a href="https://github.com/BlackGhostLzc/CS144.git">github</a></p><h2 id="2-telnet手动访问网页"><a href="#2-telnet手动访问网页" class="headerlink" title="2.telnet手动访问网页"></a>2.telnet手动访问网页</h2><p>Telnet协议是TCP&#x2F;IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用<code>telnet</code>程序，用它连接到服务器。终端使用者可以在<code>telnet</code>程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。</p><p>使用 <code>telnet cs144.keithw.org http</code>命令以连接远程网页服务器，之后在终端键入以下内容:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/hello</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>cs144.keithw.org<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br></code></pre></td></tr></table></figure><p>之后看到远程服务器会返回网页的内容并展示再终端上。</p><h2 id="3-实现webget-cc"><a href="#3-实现webget-cc" class="headerlink" title="3. 实现webget.cc"></a>3. 实现webget.cc</h2><p>实验指导书上也有提示，需要借助<code>libsponge</code>库中的<code>TCPSocket</code>和<code>Address</code>两个类来实现。</p><p>注意：</p><ol><li>HTTP头部每一行都以<code>\r\n</code>结尾，而不是<code>\n</code></li><li>需要包含<code>Connection: close</code></li><li>借助<code>eof</code>函数接收服务器的发送数据</li></ol><p>其余部分按照上面的<code>telnet</code>命令仿写即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">get_URL</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;host, <span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;path)</span> &#123;<br>    <span class="hljs-comment">// Your code here.</span><br>    <br>    Address <span class="hljs-title function_">addr</span><span class="hljs-params">(host, <span class="hljs-string">&quot;http&quot;</span>)</span>;<br>    TCPSocket http_socket;<br>    <br>    http_socket.connect(addr);<br>    http_socket.write(<span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\n&quot;</span>);<br>    http_socket.write(<span class="hljs-string">&quot;Host: &quot;</span> + host + <span class="hljs-string">&quot;\r\n&quot;</span>);<br>    http_socket.write(<span class="hljs-string">&quot;Connection: close\r\n&quot;</span>);<br>    http_socket.write(<span class="hljs-string">&quot;\r\n&quot;</span>);<br><br>    <span class="hljs-keyword">while</span>(!http_socket.eof())&#123;<br>        <span class="hljs-built_in">cout</span>&lt;&lt;http_socket.read();<br>    &#125;<br><br>    http_socket.close();<br>    <span class="hljs-comment">// You will need to connect to the &quot;http&quot; service on</span><br>    <span class="hljs-comment">// the computer whose name is in the &quot;host&quot; string,</span><br>    <span class="hljs-comment">// then request the URL path given in the &quot;path&quot; string.</span><br><br>    <span class="hljs-comment">// Then you&#x27;ll need to print out everything the server sends back,</span><br>    <span class="hljs-comment">// (not just one call to read() -- everything) until you reach</span><br>    <span class="hljs-comment">// the &quot;eof&quot; (end of file).</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现ByteStream"><a href="#实现ByteStream" class="headerlink" title="实现ByteStream"></a>实现ByteStream</h2><p>要求实现一个在内存中的有序可靠字节流。</p><p>注意：</p><ul><li>字节流可以从写入端写入，并以相同的顺序，从读取端读取</li><li>字节流是有限的，写入者可以终止写入</li><li>缓冲区是有大小限制的，缓冲区满的时候，写入者不允许再写入</li><li>ByteStream流的字节可能比缓冲区要大的多</li><li>单线程环境，不考虑竞态条件</li></ul><p>我们考虑用<code>deque</code>数据结构来实现这个字节流。<br>需要为ByteStream添加数据成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// byte_stream.hh文件</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;<span class="hljs-type">char</span>&gt; dq_;<br><span class="hljs-type">size_t</span> capacity_;<br><span class="hljs-type">size_t</span> read_size_;     <span class="hljs-comment">//总共读取的字节数</span><br><span class="hljs-type">size_t</span> write_size_;    <span class="hljs-comment">//总共写入的字节数</span><br><span class="hljs-type">bool</span> end_input_;       <span class="hljs-comment">//能否再写</span><br></code></pre></td></tr></table></figure><p>具体函数也不难实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// byte_stream.cc文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-comment">// Dummy implementation of a flow-controlled in-memory byte stream.</span><br><br><span class="hljs-comment">// For Lab 0, please replace with a real implementation that passes the</span><br><span class="hljs-comment">// automated checks run by `make check_lab0`.</span><br><br><span class="hljs-comment">// You will need to add private members to the class declaration in `byte_stream.hh`</span><br><br>template &lt;typename... Targs&gt;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DUMMY_CODE</span><span class="hljs-params">(Targs &amp;&amp;... <span class="hljs-comment">/* unused */</span>)</span> &#123;&#125;<br><br>using namespace <span class="hljs-built_in">std</span>;<br><br>ByteStream::ByteStream(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> capacity):dq_(), capacity_(capacity), read_size_(<span class="hljs-number">0</span>), write_size_(<span class="hljs-number">0</span>),end_input_(<span class="hljs-number">0</span>) &#123; <br>    <br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">string</span> &amp;data)</span> &#123;<br>    <span class="hljs-keyword">if</span>(end_input_)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 把 data 写进 dq_中</span><br>    <span class="hljs-type">size_t</span> write_sz = <span class="hljs-built_in">std</span>::min(data.size(), capacity_ - dq_.size());<br>    write_size_ += write_sz;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; write_sz; i++)&#123;<br>        dq_.push_back(data[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> write_sz;<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be copied from the output side of the buffer</span><br><span class="hljs-built_in">string</span> <span class="hljs-title function_">ByteStream::peek_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">// dq_中的内容不会被清除</span><br>    <span class="hljs-type">size_t</span> pop_size = min(len, dq_.size());<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">string</span>(dq_.begin(), dq_.begin() + pop_size);<br>&#125;<br><br><span class="hljs-comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ByteStream::pop_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> &#123; <br>    <span class="hljs-comment">//dq_中的内容会被清除</span><br>    <span class="hljs-type">size_t</span> pop_size = min(len, dq_.size());<br>    read_size_ += pop_size;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; pop_size; i++)&#123;<br>        dq_.pop_front();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span><br><span class="hljs-comment">//! \param[in] len bytes will be popped and returned</span><br><span class="hljs-comment">//! \returns a string</span><br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title function_">ByteStream::read</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">size_t</span> len)</span> &#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> ret = peek_output(len);<br>    pop_output(len);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ByteStream::end_input</span><span class="hljs-params">()</span> &#123;<br>    end_input_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ByteStream::input_ended</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> end_input_;    <br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::buffer_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> dq_.size();<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ByteStream::buffer_empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> dq_.size() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ByteStream::eof</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> dq_.size() == <span class="hljs-number">0</span> &amp;&amp; input_ended();    <br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::bytes_written</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> write_size_;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::bytes_read</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> read_size_;<br>&#125;<br><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">ByteStream::remaining_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> &#123; <br>    <span class="hljs-keyword">return</span> capacity_ - dq_.size();    <br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>CS144</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>CS144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tinyhttpd</title>
    <link href="/2023/09/08/%E9%A1%B9%E7%9B%AE/Tinyhttpd/Tinyhttpd/"/>
    <url>/2023/09/08/%E9%A1%B9%E7%9B%AE/Tinyhttpd/Tinyhttpd/</url>
    
    <content type="html"><![CDATA[<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>这是一个简单的轻量HTTP服务器，能够让我们理解服务器工作的流程与本质。<br><a href="https://github.com/BlackGhostLzc/Tinyhttpd.git">我的GitHub地址</a>。<br>对代码我做了一点更改，例如再服务器进程中打印一些报文的内容以及做了比较详细的注释，还有更改了<code>simpleclient.c</code>文件使得这个程序也可以与<code>http</code>进行非<code>GET</code>非<code>POST</code>的通信。</p><h2 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h2><p>编译好项目后，首先运行<code>http</code>程序，<code>http.c</code>文件中位服务器指定了一个端口，然后可以打开浏览器，输入<code>localhost:端口号</code>或者<code>127.0.0.1:端口号</code>就可以连接到服务器。<br>在输入框中输入一个颜色，点击提交，得到下面的效果图。<br><img src="https://pic4.zhimg.com/80/v2-c0f3f89359dc034bf5597b83caa42243_1440w.webp" alt="img" style="zoom:50%;" /></p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>当我们在浏览器（客户端）输入一个网址，浏览器就会向服务器发出一个HTTP报文。<br>这里并不讲HTTP报文的格式，只介绍<code>Tinyhttpd</code>用到的的请求方法：</p><ol><li><code>GET</code>: 请求指定的页面信息，并返回实体主体。</li><li><code>POST</code>:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code> 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</li></ol><h3 id="CGI脚本"><a href="#CGI脚本" class="headerlink" title="CGI脚本"></a>CGI脚本</h3><p>CGI不是一门编程语言。它是网页的表单和你写的程序之间通信的一种协议。<br>典型的CGI脚本做了如下的事情：</p><ol><li>读取用户提交表单的信息。</li><li>处理这些信息（也就是实现业务）。</li><li>输出，返回html响应（返回处理完的数据）<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#!/usr/bin/perl -Tw</span><br><br><span class="hljs-keyword">use</span> strict;<br><span class="hljs-keyword">use</span> CGI;<br><br><span class="hljs-keyword">my</span>($cgi) = new CGI;<br><br><span class="hljs-keyword">print</span> $cgi-&gt;header;<br><span class="hljs-keyword">my</span>($color) = <span class="hljs-string">&quot;blue&quot;</span>;<br>$color = $cgi-&gt;param(<span class="hljs-string">&#x27;color&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-keyword">defined</span> $cgi-&gt;param(<span class="hljs-string">&#x27;color&#x27;</span>);<br><br><span class="hljs-keyword">print</span> $cgi-&gt;start_html(<span class="hljs-string">-title =&gt;</span> <span class="hljs-keyword">uc</span>($color),<br>                       <span class="hljs-string">-BGCOLOR =&gt;</span> $color);<br><span class="hljs-keyword">print</span> $cgi-&gt;h1(<span class="hljs-string">&quot;This is $color&quot;</span>);<br><span class="hljs-keyword">print</span> $cgi-&gt;end_html;<br></code></pre></td></tr></table></figure>上面这个CGI脚本就生成了一个html格式的文件，服务器进程创建的子进程会运行这个脚本，通过管道，服务器进程向子进程传入执行这个脚本需要的一些参数，也就是客户端提交的表单，而子进程也通过管道把脚本执行内容传给服务器进程，再由服务器发送给客户端，这样实现了动态解析。</li></ol><h2 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h2><p><code>Tinyhttpd</code>有下面这几个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">accept_request</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//处理从套接字上监听到的一个 HTTP 请求</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bad_request</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//返回给客户端这是个错误请求，400响应码</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cat</span><span class="hljs-params">(<span class="hljs-type">int</span>, FILE *)</span>;<span class="hljs-comment">//读取服务器上某个文件写到 socket 套接字</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cannot_execute</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//处理发生在执行 cgi 程序时出现的错误</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">error_die</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//把错误信息写到 perror </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">execute_cgi</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//运行cgi脚本，这个非常重要，涉及动态解析</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_line</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span> *, <span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//读取一行HTTP报文</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">headers</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//返回HTTP响应头</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">not_found</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//返回找不到请求文件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">serve_file</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span>;<span class="hljs-comment">//调用 cat 把服务器文件内容返回给浏览器。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">startup</span><span class="hljs-params">(u_short *)</span>;<span class="hljs-comment">//开启http服务，包括绑定端口，监听，开启线程处理链接</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">unimplemented</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<span class="hljs-comment">//返回给浏览器表明收到的 HTTP 请求所用的 method 不被支持。</span><br></code></pre></td></tr></table></figure><h3 id="accept-request函数"><a href="#accept-request函数" class="headerlink" title="accept_request函数"></a>accept_request函数</h3><p>相关代码逻辑在注释中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">accept_request</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">int</span> client = (<span class="hljs-type">intptr_t</span>)arg;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">size_t</span> numchars;<br>    <span class="hljs-type">char</span> method[<span class="hljs-number">255</span>];<br>    <span class="hljs-type">char</span> url[<span class="hljs-number">255</span>];<br>    <span class="hljs-type">char</span> path[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">size_t</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-type">int</span> cgi = <span class="hljs-number">0</span>;      <span class="hljs-comment">/* becomes true if server decides this is a CGI</span><br><span class="hljs-comment">                       * program */</span><br>    <span class="hljs-type">char</span> *query_string = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 获取请求报文的第一行</span><br>    numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    i = <span class="hljs-number">0</span>; j = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;First line: %s&quot;</span>, buf);<br><br>    <span class="hljs-comment">// 获取请求报文的方法，是GET还是POST方法</span><br>    <span class="hljs-keyword">while</span> (!ISspace(buf[i]) &amp;&amp; (i &lt; <span class="hljs-keyword">sizeof</span>(method) - <span class="hljs-number">1</span>))<br>    &#123;<br>        method[i] = buf[i];<br>        i++;<br>    &#125;<br>    j=i;<br>    method[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果不是这两种方法，那就只能是simpleclient程序</span><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) &amp;&amp; strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>))<br>    &#123;<br>        buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-comment">// 向simpleclient发送一个字符</span><br>        write(client, buf, <span class="hljs-number">1</span>);<br>        unimplemented(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是POST方法，那么需要执行cgi脚本</span><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>) == <span class="hljs-number">0</span>)<br>        cgi = <span class="hljs-number">1</span>;<br><br><br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (ISspace(buf[j]) &amp;&amp; (j &lt; numchars))<br>        j++;<br>    <br>    <span class="hljs-comment">// 获取url</span><br>    <span class="hljs-keyword">while</span> (!ISspace(buf[j]) &amp;&amp; (i &lt; <span class="hljs-keyword">sizeof</span>(url) - <span class="hljs-number">1</span>) &amp;&amp; (j &lt; numchars))<br>    &#123;<br>        url[i] = buf[j];<br>        i++; j++;<br>    &#125;<br>    url[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果是GET方法，这里的url是  / </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;url: %s\n&quot;</span>, url);<br><br><span class="hljs-comment">// url还需要进行拼接操作，把htdocs目录下的index.html发送给客户端</span><br><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 如果有查询参数</span><br>        query_string = url;<br>        <span class="hljs-keyword">while</span> ((*query_string != <span class="hljs-string">&#x27;?&#x27;</span>) &amp;&amp; (*query_string != <span class="hljs-string">&#x27;\0&#x27;</span>))<br>            query_string++;<br>        <span class="hljs-keyword">if</span> (*query_string == <span class="hljs-string">&#x27;?&#x27;</span>)<br>        &#123;<br>            cgi = <span class="hljs-number">1</span>;<br>            *query_string = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            query_string++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">sprintf</span>(path, <span class="hljs-string">&quot;htdocs%s&quot;</span>, url);<br>    <span class="hljs-comment">// 如果是GET方法：  path:htdocs/</span><br>    <span class="hljs-comment">// 如果是POST方法： path:htdocs/color.cgi</span><br><br><br>    <span class="hljs-keyword">if</span> (path[<span class="hljs-built_in">strlen</span>(path) - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-built_in">strcat</span>(path, <span class="hljs-string">&quot;index.html&quot;</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;path: %s\n&quot;</span>, path);<br>    <span class="hljs-comment">// 如果是GET方法：    path: htdocs/index.html</span><br>    <span class="hljs-comment">// 如果是POST方法：   path: htdocs/color.cgi</span><br><br>    <span class="hljs-comment">// 把path文件与st关联起来</span><br>    <span class="hljs-keyword">if</span> (stat(path, &amp;st) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">while</span> ((numchars &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;\n&quot;</span>, buf))  <span class="hljs-comment">/* read &amp; discard headers */</span><br>            numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        not_found(client);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 如果路径是个目录，那就将主页进行显示</span><br>        <span class="hljs-keyword">if</span> ((st.st_mode &amp; S_IFMT) == S_IFDIR)<br>            <span class="hljs-built_in">strcat</span>(path, <span class="hljs-string">&quot;/index.html&quot;</span>);<br>        <span class="hljs-keyword">if</span> ((st.st_mode &amp; S_IXUSR) ||<br>                (st.st_mode &amp; S_IXGRP) ||<br>                (st.st_mode &amp; S_IXOTH)    )<br>            cgi = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!cgi)<br>            <span class="hljs-comment">// 为客户端发送静态网页</span><br>            serve_file(client, path);<br>        <span class="hljs-keyword">else</span><br>            execute_cgi(client, path, method, query_string);<br>    &#125;<br><br>    close(client);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="execute-cgi函数"><a href="#execute-cgi函数" class="headerlink" title="execute_cgi函数"></a>execute_cgi函数</h3><p>这个函数是进行动态解析的核心函数，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">execute_cgi</span><span class="hljs-params">(<span class="hljs-type">int</span> client, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path,</span><br><span class="hljs-params">        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *method, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *query_string)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get into execute_cgi\n&quot;</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> cgi_output[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> cgi_input[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">char</span> c;<br>    <span class="hljs-type">int</span> numchars = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> content_length = <span class="hljs-number">-1</span>;<br><br>    buf[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;A&#x27;</span>; buf[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-comment">// 如果是GET请求，就不断的读取并丢弃头信息</span><br>    <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> ((numchars &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;\n&quot;</span>, buf))  <span class="hljs-comment">/* read &amp; discard headers */</span><br>            numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">/*POST*/</span><br>    &#123;<br>        <span class="hljs-comment">// POST请求</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a POST method\n&quot;</span>); <br>        numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">        ....</span><br><span class="hljs-comment">        Content-Length: 9</span><br><span class="hljs-comment">        ....</span><br><span class="hljs-comment">        空一行 \n</span><br><span class="hljs-comment">        内容(color=red)</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-keyword">while</span> ((numchars &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;\n&quot;</span>, buf))<br>        &#123;<br>            buf[<span class="hljs-number">15</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            <span class="hljs-comment">// 得到消息体的长度是多少</span><br>            <span class="hljs-keyword">if</span> (strcasecmp(buf, <span class="hljs-string">&quot;Content-Length:&quot;</span>) == <span class="hljs-number">0</span>)<br>                content_length = atoi(&amp;(buf[<span class="hljs-number">16</span>]));<br>            numchars = get_line(client, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (content_length == <span class="hljs-number">-1</span>) &#123;<br>            bad_request(client);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">/*HEAD or other*/</span><br>    &#123;<br>    &#125;<br><br><span class="hljs-comment">// 初始化管道</span><br>    <span class="hljs-keyword">if</span> (pipe(cgi_output) &lt; <span class="hljs-number">0</span>) &#123;<br>        cannot_execute(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pipe(cgi_input) &lt; <span class="hljs-number">0</span>) &#123;<br>        cannot_execute(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( (pid = fork()) &lt; <span class="hljs-number">0</span> ) &#123;<br>        cannot_execute(client);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);<br>    send(client, buf, <span class="hljs-built_in">strlen</span>(buf), <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* child: CGI script */</span><br>    &#123;<br>        <span class="hljs-comment">// 子进程来执行 cgi 脚本</span><br>        <span class="hljs-type">char</span> meth_env[<span class="hljs-number">255</span>];<br>        <span class="hljs-type">char</span> query_env[<span class="hljs-number">255</span>];<br>        <span class="hljs-type">char</span> length_env[<span class="hljs-number">255</span>];<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子进程执行%s程序\n&quot;</span>, path);<br><br><span class="hljs-comment">// 操作文件描述符，使得执行cgi脚本的时候，print打印直接交给管道的写端</span><br>        dup2(cgi_output[<span class="hljs-number">1</span>], STDOUT);<br>        dup2(cgi_input[<span class="hljs-number">0</span>], STDIN);<br>        close(cgi_output[<span class="hljs-number">0</span>]);<br>        close(cgi_input[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-built_in">sprintf</span>(meth_env, <span class="hljs-string">&quot;REQUEST_METHOD=%s&quot;</span>, method);<br>        putenv(meth_env);<br>        <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">sprintf</span>(query_env, <span class="hljs-string">&quot;QUERY_STRING=%s&quot;</span>, query_string);<br>            putenv(query_env);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">/* POST */</span><br>            <span class="hljs-built_in">sprintf</span>(length_env, <span class="hljs-string">&quot;CONTENT_LENGTH=%d&quot;</span>, content_length);<br>            putenv(length_env);<br>        &#125;<br><br>        <span class="hljs-comment">// 执行 cgi 脚本，cgi脚本中的 print 都会通过管道重定向给父进程</span><br>        execl(path, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">/* parent */</span><br>        close(cgi_output[<span class="hljs-number">1</span>]);<br>        close(cgi_input[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span> (strcasecmp(method, <span class="hljs-string">&quot;POST&quot;</span>) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程接受到的消息内容是:\n&quot;</span>);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; content_length; i++) &#123;<br>                recv(client, &amp;c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-comment">// 父进程把收到的消息内容传递给子进程，也就是 “color=red” 这条信息，由cgi生成新的html文件</span><br>                <span class="hljs-comment">// 再由父进程（服务器）转交给客户端</span><br>                write(cgi_input[<span class="hljs-number">1</span>], &amp;c, <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,c);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;父进程通过管道接收到的：\n&quot;</span>);<br><br>        <span class="hljs-keyword">while</span> (read(cgi_output[<span class="hljs-number">0</span>], &amp;c, <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>)&#123;<br>            send(client, &amp;c, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, c);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        我把父进程接收到子进程的字符写进了new.html文件中，可以发现这就是一个网页</span><br><span class="hljs-comment">        */</span><br>        close(cgi_output[<span class="hljs-number">0</span>]);<br>        close(cgi_input[<span class="hljs-number">1</span>]);<br>        waitpid(pid, &amp;status, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，把服务器进程通过管道收到的CGI脚本输出内容再发送给客户端，html文件如下所示，这也正是点击提交后再浏览器上展示的网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span></span><br><span class="hljs-meta">    <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en-US&quot;</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en-US&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>RED<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=iso-8859-1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is red<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过这个项目，清楚了HTTP是如何响应和处理客户端请求的，明白了HTTP服务器的工作机制，也对CGI脚本有了一点了解。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始socket</title>
    <link href="/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%9D%E8%AF%86socket/"/>
    <url>/2023/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%88%9D%E8%AF%86socket/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1.什么是socket"></a>1.什么是socket</h2><p>socket 的原意是“插座”，是一种操作系统提供的进程间通信机制。</p><p>在UNIX&#x2F;Linux系统中，一切皆文件，网络连接也是一个文件，它也有文件描述符。<br>我们可以通过 <code>socket()</code> 函数来创建一个网络连接，或者说打开一个网络文件，<code>socket()</code> 的返回值就是文件描述符。有了文件描述符，我们就可以使用普通的文件操作函数来传输数据了，例如：</p><ul><li>用 <code>read()</code> 读取从远程计算机传来的数据；</li><li>用 <code>write()</code> 向远程计算机写入数据。</li></ul><p>还有一个比较重要的就是网络字节序。<br>网络字节序一般都是大端表示的，而主机字节序一般是小端表示的，所以需要包含一段这两者之间的转换函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 将一个短整形从主机字节序 -&gt; 网络字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<br><span class="hljs-comment">// 将一个整形从主机字节序 -&gt; 网络字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;<br><br><span class="hljs-comment">// 将一个短整形从网络字节序 -&gt; 主机字节序</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span><br><span class="hljs-comment">// 将一个整形从网络字节序 -&gt; 主机字节序</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;<br></code></pre></td></tr></table></figure><p>而对于IP地址，我们一般见到的表示形式都是点分十进制，把这种点分十进制转换为网络字节序需要函数<code>inet_pton()</code>,<code>inet_ntop</code>将大端的整形数, 转换为小端的点分十进制的IP地址。</p><h2 id="2-TCP通信流程"><a href="#2-TCP通信流程" class="headerlink" title="2.TCP通信流程"></a>2.TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议，这个协议是一个传输层协议。</p><h3 id="2-1服务器端通信流程"><a href="#2-1服务器端通信流程" class="headerlink" title="2.1服务器端通信流程"></a>2.1服务器端通信流程</h3><p>一般而言，服务器需要一个监听套接字和多个通信套接字，监听套接字负责与客户端建立连接，通信套接字则是与客户端进行数据传送。</p><ol><li>调用<code>socket()</code>函数创建用于监听的套接字，得到一个文件描述符。</li><li>将得到的监听文件描述符和本地的IP端口进行绑定，<code>bind()</code>函数。</li><li><code>listen()</code>函数设置监听。</li><li><code>accept()</code>函数等待客户端的连接请求，会返回一个用于与客户端通信的文件描述符，如果没有请求就会堵塞。</li><li><code>read()</code>或<code>recv()</code>接受数据，<code>write()</code>或<code>send()</code>发送数据。</li><li><code>close()</code>断开连接，关闭套接字。</li></ol><ul><li>注意：服务端需要绑定一个特定的端口，不能随意分配。这是因为客户端在请求与服务器端进行连接的时候，需要指定IP地址以及端口，所以服务器的端口对于客户端来说是已知的。<br>例如，当我们输入网址<code>https://www.bilibili.com</code>，其实https的默认端口就是443，所以相当于我们省略了端口，输入<code>https://www.bilibili.com:443</code>也是一样的。再讲一句题外话，我们按下F12，点击网络，也会得到远程服务器的IP地址和端口，发现端口也是443，前提是你要关闭vpn代理。</li></ul><h3 id="2-2-客户端的通信流程"><a href="#2-2-客户端的通信流程" class="headerlink" title="2.2 客户端的通信流程"></a>2.2 客户端的通信流程</h3><p>一般来说客户端通信的文件描述符只有一个，不需要坚挺的文件描述符。</p><ol><li><code>socket()</code>函数创建一个套接字，返回文件描述符。</li><li><code>connect()</code>函数连接服务器，需要知道服务器绑定的IP和端口。</li><li><code>read()</code>或<code>recv()</code>函数接受数据，<code>write()</code>或<code>send()</code>发送数据。</li><li><code>close()</code>断开连接。</li></ol><h2 id="3-基本API"><a href="#3-基本API" class="headerlink" title="3.基本API"></a>3.基本API</h2><ul><li><code>int socket(int domain, int type, int protocol)</code>：<br>参数：<br><code>domain</code>地址族，常见的有AF_INET（IPv4）和AF_INET6（IPv6）。<br><code>type</code> 套接字类型,常见的有SOCK_STREAM（用于TCP协议）和SOCK_DGRAM（用于UDP协议）。<br><code>protocal</code>协议，通常置为0，根据前两个参数自动选择合适的协议。</li></ul><p>返回值是一个文件描述符。</p><ul><li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>参数：<br><code>sockfd</code>需要绑定的套接字文件描述符。<br><code>addr</code>:存放了服务端用于通信的地址和端口。<br><code>addrlen</code>:结构体addr的大小。</li></ul><p><code>sockaddr_in</code>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">sa_family_t</span> sin_family;<span class="hljs-comment">/* 地址族协议: AF_INET */</span><br>    <span class="hljs-type">in_port_t</span> sin_port;         <span class="hljs-comment">/* 端口, 2字节-&gt; 大端  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>    <span class="hljs-comment">/* IP地址, 4字节 -&gt; 大端  */</span><br>    <span class="hljs-comment">/* 填充 8字节 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sin_zero[<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> sockaddr) - <span class="hljs-keyword">sizeof</span>(sin_family) -<br>               <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">in_port_t</span>) - <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> in_addr)];<br>&#125;;  <br></code></pre></td></tr></table></figure><ul><li><p><code>int listen(int sockfd, int backlog)</code><br>参数：<br><code>sockfd</code>: 文件描述符, 可以通过调用<code>socket()</code>得到，在监听之前必须要绑定 <code>bind()</code><br><code>backlog</code>: 同时能处理的最大连接要求，最大值为128</p></li><li><p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>参数：<br><code>sockfd</code>: 监听的文件描述符<br><code>addr</code>: <strong>传出参数</strong>, 里边存储了建立连接的客户端的地址信息,如客户端的端口和IP。<br><code>addrlen</code>: 传入传出参数，用于存储addr指向的内存大小</p></li></ul><p>这个函数是一个阻塞函数，当没有新的客户端连接请求的时候，该函数阻塞；当检测到有新的客户端连接请求时，阻塞解除，新连接就建立了，得到的返回值也是一个文件描述符，基于这个文件描述符就可以和客户端通信了。</p><ul><li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>参数：<br><code>sockfd</code>: 通信的文件描述符, 通过调用socket()函数就得到了<br><code>addr</code>: 存储了要连接的服务器端的地址信息: IP 和 端口，这个IP和端口也需要转换为大端然后再赋值<br><code>addrlen</code>: <code>addr</code>指针指向的内存的大小 <code>sizeof(struct sockaddr)</code></li></ul><p>至于发送接受数据的函数，这个是内核来维护的，内核决定多久发送出去就多久发送出去，多久从缓冲区获取数据就多久获取。同时，如果缓冲区满了，<code>write</code>或<code>send</code>函数就会被阻塞。</p><h2 id="4-示例代码"><a href="#4-示例代码" class="headerlink" title="4.示例代码"></a>4.示例代码</h2><p>在我们的示例代码中，服务器端我们要使用多线程，每当一个客户端发过来一个请求时，服务器端都需要创建一个线程去处理这个请求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sys_err</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str)</span>&#123;<br>    perror(str);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SERV_PORT 9527</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFSIZE 256</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">client_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> *socket_desc)</span> &#123;<br>    <span class="hljs-type">int</span> client_socket = *(<span class="hljs-type">int</span> *)socket_desc;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        ret = read(client_socket, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        write(STDOUT_FILENO, buf, ret);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)&#123;<br>            buf[i] = <span class="hljs-built_in">toupper</span>(buf[i]);<br>        &#125;<br><br>        write(client_socket, buf, ret);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span>&#123;<br><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-number">0</span>, cfd = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-type">char</span> buf[BUFSIZE];<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>, <span class="hljs-title">clit_addr</span>;</span><br>    <span class="hljs-type">pthread_t</span> thread_id;<br><br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_port = htons(SERV_PORT);<br>    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);<br><br><br>    lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>)&#123;<br>        sys_err(<span class="hljs-string">&quot;socket error&quot;</span>);<br>    &#125;<br><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr));<br><br>    listen(lfd, <span class="hljs-number">128</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">socklen_t</span> clit_addr_len = <span class="hljs-keyword">sizeof</span>(clit_addr);<br>        cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;clit_addr, &amp;clit_addr_len);<br><br>        <span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;Accept failed&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Client connected\n&quot;</span>);<br><br>        <span class="hljs-type">int</span> *new_sock = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>        *new_sock = cfd;<br><br>        <span class="hljs-keyword">if</span> (pthread_create(&amp;thread_id, <span class="hljs-literal">NULL</span>, client_handler, (<span class="hljs-type">void</span> *)new_sock) &lt; <span class="hljs-number">0</span>) &#123;<br>            perror(<span class="hljs-string">&quot;Could not create thread&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    close(lfd);<br>    close(cfd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</code><br>这行代码的意思是可以绑定本地的任何一个IP地址，服务器端自动地读网卡的实际IP，并与这个实际IP进行绑定。<br>现在我们还没有客户端的代码，但我们仍然可以对服务器代码进行测试。<br>首先编译并运行服务器端代码，然后另外开几个终端，输入<code>nc 127.0.0.1 9527</code>命令。</p><blockquote><p>Linux中的nc命令是一个功能强大的网络工具，也被称为netcat，可以实现TCP&#x2F;UDP端口的侦听，127.0.0.1代表本地主机，9527端口是服务器监听套接字绑定了的。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池的C语言实现</title>
    <link href="/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-任务队列"><a href="#1-任务队列" class="headerlink" title="1.任务队列"></a>1.任务队列</h2><p>线程池结构体就是存储任务队列的。很明显，任务中需要有执行函数的函数地址和传入的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Task</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">void</span> (*function)(<span class="hljs-type">void</span> *arg);<br>    <span class="hljs-type">void</span> *arg;<br>&#125; Task;<br></code></pre></td></tr></table></figure><p>在这里，我们的<code>function</code>函数只接受单个参数。</p><ul><li>如果需要多个参数呢？我在github上给出了一小段实现代码。<br><a href="https://github.com/BlackGhostLzc/ThreadPool.git">这是我的github仓库</a><br>其实就是需要一个参数结构体<code>MyParam</code>，<code>function</code>中传入的<code>arg</code>类型转换为<code>MyParam</code>就行了。</li></ul><hr><h2 id="2-线程池定义"><a href="#2-线程池定义" class="headerlink" title="2.线程池定义"></a>2.线程池定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ThreadPool</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-comment">// 任务队列</span><br>    Task *taskQ;<br>    <span class="hljs-type">int</span> queueCapacity;<br>    <span class="hljs-type">int</span> queueSize; <span class="hljs-comment">// 当前任务个数</span><br>    <span class="hljs-type">int</span> queueFront;<br>    <span class="hljs-type">int</span> queueRear;<br><br>    <span class="hljs-type">pthread_t</span> managerID;  <span class="hljs-comment">// 管理者线程ID</span><br>    <span class="hljs-type">pthread_t</span> *threadIDs; <span class="hljs-comment">// 工作的线程ID</span><br><br>    <span class="hljs-type">int</span> minNum;  <span class="hljs-comment">// 最小线程数</span><br>    <span class="hljs-type">int</span> maxNum;  <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-type">int</span> busyNum; <span class="hljs-comment">// 忙的线程数</span><br>    <span class="hljs-type">int</span> liveNum; <span class="hljs-comment">// 存活的线程数</span><br>    <span class="hljs-type">int</span> exitNum; <span class="hljs-comment">// 要杀死的线程个数</span><br><br>    <span class="hljs-type">pthread_mutex_t</span> mutexPool; <span class="hljs-comment">// 锁整个线程池</span><br>    <span class="hljs-type">pthread_mutex_t</span> mutexBusy; <span class="hljs-comment">// 锁busyNum变量</span><br><br>    <span class="hljs-type">pthread_cond_t</span> notFull; <span class="hljs-comment">// 任务队列是否是满的</span><br>    <span class="hljs-type">pthread_cond_t</span> notEmpty;<br><br>    <span class="hljs-type">int</span> shutdown; <span class="hljs-comment">// 是否销毁线程池</span><br>&#125; ThreadPool;<br></code></pre></td></tr></table></figure><hr><h2 id="3-函数申明"><a href="#3-函数申明" class="headerlink" title="3.函数申明"></a>3.函数申明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建线程池</span><br>ThreadPool *<span class="hljs-title function_">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span>;<br><span class="hljs-comment">// 销毁线程池</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolDestroy</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// 往等待队列中添加任务,threadPool中的TaskQ</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadPoolAdd</span><span class="hljs-params">(ThreadPool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 忙碌线程的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// 存活线程的个数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool *pool)</span>;<br><span class="hljs-comment">// manager线程处理函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 存活线程处理函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>;<br><span class="hljs-comment">// 线程退出</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">threadExit</span><span class="hljs-params">(ThreadPool *pool)</span>;<br></code></pre></td></tr></table></figure><hr><h2 id="4-函数代码实现"><a href="#4-函数代码实现" class="headerlink" title="4.函数代码实现"></a>4.函数代码实现</h2><h3 id="threadPoolCreate"><a href="#threadPoolCreate" class="headerlink" title="threadPoolCreate"></a>threadPoolCreate</h3><p>体会一下<code>do... while(0)</code>的妙用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c">ThreadPool *<span class="hljs-title function_">threadPoolCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> min, <span class="hljs-type">int</span> max, <span class="hljs-type">int</span> queueSize)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ThreadPool));<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadpool fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        pool-&gt;threadIDs = (<span class="hljs-type">pthread_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc threadIDs fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(pool-&gt;threadIDs, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * max);<br>        pool-&gt;minNum = min;<br>        pool-&gt;maxNum = max;<br>        pool-&gt;busyNum = <span class="hljs-number">0</span>;<br>        pool-&gt;liveNum = min; <span class="hljs-comment">// 和最小个数相等</span><br>        pool-&gt;exitNum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span> ||<br>            pthread_cond_init(&amp;pool-&gt;notFull, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mutex or condition init fail...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 任务队列</span><br>        pool-&gt;taskQ = (Task *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Task) * queueSize);<br>        pool-&gt;queueCapacity = queueSize;<br>        pool-&gt;queueSize = <span class="hljs-number">0</span>;<br>        pool-&gt;queueFront = <span class="hljs-number">0</span>;<br>        pool-&gt;queueRear = <span class="hljs-number">0</span>;<br><br>        pool-&gt;shutdown = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 创建线程</span><br>        pthread_create(&amp;pool-&gt;managerID, <span class="hljs-literal">NULL</span>, manager, pool);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; min; ++i)<br>        &#123;<br>            pthread_create(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>        &#125;<br>        <span class="hljs-keyword">return</span> pool;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 释放资源</span><br>    <span class="hljs-keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs)<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    <span class="hljs-keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ)<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    <span class="hljs-keyword">if</span> (pool)<br>        <span class="hljs-built_in">free</span>(pool);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadPoolDestroy"><a href="#threadPoolDestroy" class="headerlink" title="threadPoolDestroy"></a>threadPoolDestroy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolDestroy</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br><br>    <span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭线程池</span><br>    pool-&gt;shutdown = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 阻塞回收管理者线程</span><br>    pthread_join(pool-&gt;managerID, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 唤醒阻塞的消费者线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;liveNum; ++i)<br>    &#123;<br>        pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>    &#125;<br>    <span class="hljs-comment">// 释放堆内存</span><br>    <span class="hljs-keyword">if</span> (pool-&gt;taskQ)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;taskQ);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;threadIDs)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pool-&gt;threadIDs);<br>    &#125;<br><br>    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);<br>    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);<br>    pthread_cond_destroy(&amp;pool-&gt;notEmpty);<br>    pthread_cond_destroy(&amp;pool-&gt;notFull);<br><br>    <span class="hljs-built_in">free</span>(pool);<br>    pool = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="threadPoolAdd"><a href="#threadPoolAdd" class="headerlink" title="threadPoolAdd"></a>threadPoolAdd</h3><ul><li>为什么需要<code>while</code>循环<br>因为<code>pthread_cond_signal</code>会唤醒所有被条件变量阻塞的线程。<br>假设有两个生产者线程因为任务队列已经满了，而被阻塞在该位置。随后某个工作线程拿取了一个任务而使得任务队列没有满，接着<code>pthread_cond_signal</code>唤醒这两个生产者线程。这两个生产者线程首先都尝试获取<code>mutexPool</code>这把锁，然后只有一个生产者线程拿到了这把锁，执行到下一个<code>while</code>循环条件不满足就退出了，然后就可以把任务添加到任务队列中，最后释放掉了锁。此时任务队列又满了。<br>随后第二个生产者线程获得锁，仍在<code>while</code>循环中，它发现条件仍然满足，又调用<code>pthread_cond_wait</code>函数。<br>通过这样的机制，生产者线程就不会在已经满了的任务队列中继续添加任务了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">threadPoolAdd</span><span class="hljs-params">(ThreadPool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><br>    pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-keyword">while</span> (pool-&gt;queueSize == pool-&gt;queueCapacity &amp;&amp; !pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 阻塞生产者线程</span><br>        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pool-&gt;shutdown)<br>    &#123;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 添加任务</span><br>    pool-&gt;taskQ[pool-&gt;queueRear].function = func;<br>    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;<br>    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="hljs-number">1</span>) % pool-&gt;queueCapacity;<br>    pool-&gt;queueSize++;<br><br>    pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="threadPoolBusyNum、threadPoolAliveNum"><a href="#threadPoolBusyNum、threadPoolAliveNum" class="headerlink" title="threadPoolBusyNum、threadPoolAliveNum"></a>threadPoolBusyNum、threadPoolAliveNum</h3><p>这两个函数比较简单，不做说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolBusyNum</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>    <span class="hljs-keyword">return</span> busyNum;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">threadPoolAliveNum</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-type">int</span> aliveNum = pool-&gt;liveNum;<br>    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>    <span class="hljs-keyword">return</span> aliveNum;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><p>上一篇说过，<code>woker</code>函数是一个<code>while</code>循环，这很自然，因为线程池就是要复用线程，一个线程结束后应该转去执行其他任务，不应该结束。<br><code>while</code>循环下还有一个<code>while</code>循环，这和上面的逻辑很像。也是为了防止某个线程尝试获取空队列中的任务，这会引发难以预料的错误。<br>最后线程的执行就是一次函数调用<code>task.function(task.arg)</code><br>这里还需要注意对<code>busyNum</code>的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">worker</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)arg;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-comment">// 当前任务队列是否为空</span><br>        <span class="hljs-keyword">while</span> (pool-&gt;queueSize == <span class="hljs-number">0</span> &amp;&amp; !pool-&gt;shutdown)<br>        &#123;<br>            <span class="hljs-comment">// 阻塞工作线程</span><br>            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);<br><br>            <span class="hljs-comment">// 判断是不是要销毁线程</span><br>            <span class="hljs-keyword">if</span> (pool-&gt;exitNum &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                pool-&gt;exitNum--;<br>                <span class="hljs-keyword">if</span> (pool-&gt;liveNum &gt; pool-&gt;minNum)<br>                &#123;<br>                    pool-&gt;liveNum--;<br>                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>                    threadExit(pool);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断线程池是否被关闭了</span><br>        <span class="hljs-keyword">if</span> (pool-&gt;shutdown)<br>        &#123;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>            threadExit(pool);<br>        &#125;<br><br>        <span class="hljs-comment">// 从任务队列中取出一个任务</span><br>        Task task;<br>        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;<br>        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;<br>        <span class="hljs-comment">// 移动头结点</span><br>        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="hljs-number">1</span>) % pool-&gt;queueCapacity;<br>        pool-&gt;queueSize--;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_cond_signal(&amp;pool-&gt;notFull);<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld start working...\n&quot;</span>, pthread_self());<br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum++;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>        task.function(task.arg);<br>        <span class="hljs-built_in">free</span>(task.arg);<br>        task.arg = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %ld end working...\n&quot;</span>, pthread_self());<br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        pool-&gt;busyNum--;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h3><p><code>manager</code>是管理这些存活线程的线程。<br><code>exitNum</code>是需要杀死的线程数目。<br>在这里，增加存活线程和杀死存活线程的逻辑比较简单，详情见代码。<br>每一次最多增加或杀死<code>NUMBER</code>个存活线程。其实杀死存活线程的逻辑仍然在存活线程的<code>worker</code>函数中，<del>存活线程都是自杀的</del>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">manager</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    ThreadPool *pool = (ThreadPool *)arg;<br>    <span class="hljs-keyword">while</span> (!pool-&gt;shutdown)<br>    &#123;<br>        <span class="hljs-comment">// 每隔3s检测一次</span><br>        sleep(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 取出线程池中任务的数量和当前线程的数量</span><br>        pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>        <span class="hljs-type">int</span> queueSize = pool-&gt;queueSize;<br>        <span class="hljs-type">int</span> liveNum = pool-&gt;liveNum;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br><br>        <span class="hljs-comment">// 取出忙的线程的数量</span><br>        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);<br>        <span class="hljs-type">int</span> busyNum = pool-&gt;busyNum;<br>        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);<br><br>        <span class="hljs-comment">// 添加线程</span><br>        <span class="hljs-comment">// 任务的个数&gt;存活的线程个数 &amp;&amp; 存活的线程数&lt;最大线程数</span><br>        <span class="hljs-keyword">if</span> (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum)<br>        &#123;<br>            pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>            <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="hljs-literal">NULL</span>, worker, pool);<br>                    counter++;<br>                    pool-&gt;liveNum++;<br>                &#125;<br>            &#125;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>        &#125;<br>        <span class="hljs-comment">// 销毁线程</span><br>        <span class="hljs-comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程&gt;最小线程数</span><br>        <span class="hljs-keyword">if</span> (busyNum * <span class="hljs-number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum)<br>        &#123;<br>            pthread_mutex_lock(&amp;pool-&gt;mutexPool);<br>            pool-&gt;exitNum = NUMBER;<br>            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);<br>            <span class="hljs-comment">// 让工作的线程自杀</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUMBER; ++i)<br>            &#123;<br>                pthread_cond_signal(&amp;pool-&gt;notEmpty);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="threadExit"><a href="#threadExit" class="headerlink" title="threadExit"></a>threadExit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">threadExit</span><span class="hljs-params">(ThreadPool *pool)</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid = pthread_self();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pool-&gt;maxNum; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool-&gt;threadIDs[i] == tid)<br>        &#123;<br>            pool-&gt;threadIDs[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池概述</title>
    <link href="/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/08/05/%E9%A1%B9%E7%9B%AE/%E7%BA%BF%E7%A8%8B%E6%B1%A0/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-线程池的原理"><a href="#1-线程池的原理" class="headerlink" title="1.线程池的原理"></a>1.线程池的原理</h2><p>为什么需要线程池</p><ul><li>并发的线程数目较多，假如每一个线程都只是执行一个时间很短的任务就结束了，那么这样频繁的创建线程就会大大降低系统的效率，因为频繁创建和销毁线程都需要时间。</li></ul><p>线程池就是使得线程可以复用，一个线程执行完一个任务后并不销毁。线程池里的线程都是后台线程。如果某个线程在托管代码中空闲，那么线程池将插入另一个辅助线程来使所有处理器繁忙。如果线程池中的所有线程都繁忙，但队列中包含挂起的任务，那么线程池应该创建一个辅助线程但线程的总数不应超过最大值。超过最大值的线程需要排队。</p><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>存储需要处理的任务，由工作的线程来处理这些任务，线程池threadpool中就是存储这些待处理的任务。</p><blockquote><p>生产者消费者模型：生产者线程往任务队列里放任务，消费者线程把任务从队列中取出去。</p></blockquote><h4 id="工作的线程"><a href="#工作的线程" class="headerlink" title="工作的线程"></a>工作的线程</h4><p>任务队列的消费者。它们不停地读取任务队列，从中取出任务并处理。<br>如果任务队列为空，工作的线程将被阻塞；如果阻塞后有新的任务，由生产者将阻塞解除，工作线程开始工作。</p><h4 id="管理者线程"><a href="#管理者线程" class="headerlink" title="管理者线程"></a>管理者线程</h4><p>周期性地对任务队列中任务的数量以及处于忙碌状态的工作线程进行检测。</p><ul><li>任务过多的时候，可以创建一些新的工作线程</li><li>任务过少时，可以销毁一些工作线程</li></ul><hr><h2 id="2-项目介绍"><a href="#2-项目介绍" class="headerlink" title="2.项目介绍"></a>2.项目介绍</h2><h3 id="相关函数介绍"><a href="#相关函数介绍" class="headerlink" title="相关函数介绍"></a>相关函数介绍</h3><p>首先需要介绍几个<code>pthread.h</code>的库函数。<br><code>pthread_create(pthread_t *restrict thread, const pthread_attr_t`` *restrict attr, void *(*start_routine)(void *),void *restrict arg)</code>:创建线程, <code>start_rountine</code>作为线程起始执行函数，<code>arg</code>是传进该函数的参数。</p><p><code>pthread_join(pthread_t thread, void **retval)</code>:等待 <code>thread</code>线程结束，调用该函数的线程将被阻塞。</p><p><code>pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex)</code>: 在调用这个函数前，都要获取<code>mutex</code>互斥锁。然后挂起该线程，阻塞的时候释放<code>mutex</code>这把锁（避免死锁）。等到再被唤醒的时候，他又会重新获取<code>mutex</code>这把锁。</p><p><code>pthread_signal(pthread_cond_t *cond)</code>:唤醒阻塞在<code>cond</code>条件变量上的所有线程，通常配合上面的函数一起使用。</p><h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a>代码实现思路</h3><ol><li>存活线程：是等待执行任务的线程或者已经在执行任务的线程</li><li>忙碌线程：已经在执行任务的线程</li></ol><ul><li>需要创建一个管理者线程，传入一个函数指针<code>manage</code>,这个<code>manage</code>函数是一个<code>while</code>循环，它每隔一段时间就做一次检查，判断是否需要添加新的存活线程或者销毁存活线程。</li><li>创建多个存活线程，传入函数指针<code>worker</code>,同样，这个<code>worker</code>函数也是一个<code>while</code>循环，不断处理线程池中的待处理任务。在获取了线程池中的任务后，待处理任务的执行就是一个函数调用，函数完成后接着下一次的<code>while</code>循环判断。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件视角的操作系统</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A1%AC%E4%BB%B6%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：计算机硬件的状态机模型；回答以下问题："><a href="#本讲内容：计算机硬件的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：计算机硬件的状态机模型；回答以下问题："></a>本讲内容：计算机硬件的状态机模型；回答以下问题：</h2><ul><li>什么是计算机硬件？</li><li>计算机硬件和程序员之间是如何约定的？</li><li>听说操作系统也是程序。那到底是鸡生蛋还是蛋生鸡？</li></ul><h2 id="硬件与程序员的约定"><a href="#硬件与程序员的约定" class="headerlink" title="硬件与程序员的约定"></a>硬件与程序员的约定</h2><h3 id="Bare-metal-与程序员的约定"><a href="#Bare-metal-与程序员的约定" class="headerlink" title="Bare-metal 与程序员的约定"></a>Bare-metal 与程序员的约定</h3><blockquote><p>Bare-metal 是指在没有操作系统或者其他软件支持的情况下直接运行硬件的情况。</p></blockquote><ul><li><p>Bare-metal 与厂商的约定</p><ul><li>CPU Reset 后的状态 (寄存器值)</li></ul></li></ul><blockquote><p>   Reset 后处理器都从固定地址 (Reset Vector) 启动<br>     - 厂商自由处理这个地址上的值<br>     - Memory-mapped I&#x2F;O</p></blockquote><ul><li><p>厂商为操作系统开发者提供 Firmware</p><ul><li>管理硬件和系统配置</li><li>把存储设备上的代码加载到内存<ul><li>例如存储介质上的第二级 loader (加载器)</li><li>或者直接加载操作系统 (嵌入式系统)</li></ul></li></ul></li><li><p>Firmware 负责加载操作系统: BIOS vs UEFI<br>Legacy BIOS 把第一个可引导设备的第一个 512 字节加载到物理内存的 7c00 位置<br>此时处理器处于 16-bit 模式。</p></li><li><p>我们构造一个 512 字节的 “Master Boot Record” 作为磁盘镜像装在在模拟器上，并且用 gdb 观察指令在处理器上的执行。</p></li></ul><p>如何验证这一点？<br>计算机系统公理：你想到的就一定有人做到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs asm">#define SECT_SIZE  512<br><br>.code16  // 16-bit assembly<br><br>// Entry of the code<br>.globl _start<br>_start:<br>  lea   (msg), %si   // R[si] = &amp;msg;<br><br>again:<br>  movb  (%si), %al   // R[al] = *R[si]; &lt;--+<br>  incw  %si          // R[si]++;           |<br>  orb   %al, %al     // if (!R[al])        |<br>  jz    done         //   goto done; --+   |<br>  movb  $0x0e, %ah   // R[ah] = 0x0e;  |   |<br>  movb  $0x00, %bh   // R[bh] = 0x00;  |   |<br>  int   $0x10        // bios_call();   |   |<br>  jmp   again        // goto again; ---+---+<br>                     //                |<br>done:                //                |<br>  jmp   .            // goto done; &lt;---+<br><br>// Data: const char msg[] = &quot;...&quot;;<br>msg:<br>  .asciz &quot;This is a baby step towards operating systems!\r\n&quot;<br><br>// Magic number for bootable device<br>.org SECT_SIZE - 2<br>.byte 0x55, 0xAA<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">mbr.img: mbr.S</span><br>gcc -ggdb -c <span class="hljs-variable">$&lt;</span><br>ld mbr.o -Ttext 0x7c00<br>objcopy -S -O binary -j .text a.out <span class="hljs-variable">$@</span><br><br><span class="hljs-section">run: mbr.img</span><br>qemu-system-x86_64 <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">debug: mbr.img</span><br>qemu-system-x86_64 -s -S <span class="hljs-variable">$&lt;</span> &amp;  <span class="hljs-comment"># Run QEMU in background</span><br>gdb -x init.gdb  <span class="hljs-comment"># RTFM: gdb (1)</span><br><br><span class="hljs-section">clean:</span><br>rm -f *.img *.o a.out<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs init.gdb"># Kill process (QEMU) on gdb exits<br>define hook-quit<br>  kill<br>end<br><br># Connect to remote<br>target remote localhost:1234<br>file a.out<br>break *0x7c00<br>layout src<br>continue<br></code></pre></td></tr></table></figure><blockquote><p>前三行命令定义了一个名为 hook-quit 的 GDB 钩子。当用户在 GDB 中执行 quit 命令时，GDB 将自动执行 hook-quit 钩子中定义的命令。在这个例子中，hook-quit 钩子中只有一条命令 kill，它的作用是在用户退出 GDB 时杀死正在被调试的进程。这样可以确保在退出 GDB 后，被调试的进程也会被终止，避免出现进程僵死等问题。</p></blockquote><ul><li>如何用 gdb 调试 qemu<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">qemu-<span class="hljs-keyword">system</span>-x86_64 -s -S mbr.img<br></code></pre></td></tr></table></figure>-S： 把CPU暂停下来<br>-s： shorthand for -gdb tcp::1234       监听1234的端口</li></ul><p>所以我们可以启动一个 gdb </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gdb</span><br><span class="hljs-attribute">target</span> remote localhost::<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>这样就可以在gdb中调试这个qemu模拟器了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统调用和UNIX Shell</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8CUNIX%20Shell/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ul><li>Shell</li><li>xv6 shell 代码讲解</li></ul><h3 id="什么是-shell"><a href="#什么是-shell" class="headerlink" title="什么是 shell"></a>什么是 shell</h3><ul><li>os &#x3D; API + 对象<blockquote><p>人不可能直接使用系统调用来使用操作系统，所以人和操作系统之间隔了一个应用程序，这个应用程序就叫 shell。shell 把内核的 API 和对象做一层封装，来帮助用户管理操作系统对象的一个<strong>应用程序</strong> 。<br>有 graphic shell 和 command line shell。</p></blockquote></li></ul><h3 id="shell-编程语言"><a href="#shell-编程语言" class="headerlink" title="shell 编程语言"></a>shell 编程语言</h3><ul><li>基于文本替换的快速工作流搭建<blockquote><p>再把 shell 命令构建成一棵树，解释为一组系统调用。</p></blockquote></li></ul><ol><li>重定向: cmd &gt; file &lt; file 2&gt; &#x2F;dev&#x2F;null</li><li>顺序结构: cmd1; cmd2, cmd1 &amp;&amp; cmd2, cmd1 || cmd2</li><li>管道: cmd1 | cmd2</li><li>预处理: $(), &lt;()</li><li>变量&#x2F;环境变量、控制流……</li></ol><ul><li>Job control<br>类比窗口管理器里的 “叉”、“最小化”<br>jobs, fg, bg, wait<br>(今天的 GUI 并没有比 CLI 多做太多事)<blockquote><p>例如用 jobs 查看所有的进程，用 fg 命令使该进程变成前台进程等等。</p></blockquote></li></ul><h3 id="复刻经典"><a href="#复刻经典" class="headerlink" title="复刻经典"></a>复刻经典</h3><p>一个简单地 shell 的实现<br>推荐阅读网站源代码。</p><h3 id="管道的一些细节"><a href="#管道的一些细节" class="headerlink" title="管道的一些细节"></a>管道的一些细节</h3><ul><li>在gdb中如何调试会产生子进程(多进程)的程序？</li></ul><ol><li>set follow-fork-mode child<blockquote><p>这可以在 fork 后直接切到子进程执行流。</p></blockquote></li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> follow-fork-mode <span class="hljs-comment">child</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">detach-on-fork off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">follow-exec-mode same</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">confirm off</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">pagination off</span><br>source <span class="hljs-comment">visualize.py</span><br>break <span class="hljs-comment">_start</span><br>run<br>n <span class="hljs-comment">2</span><br>define <span class="hljs-comment">hook-stop</span><br>    pdump<br>end<br></code></pre></td></tr></table></figure><ol start="2"><li><p>info inferiors 命令查看 gdb中的进程</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Num  <span class="hljs-keyword">Description</span>       Executable<br><span class="hljs-number">1</span>    process <span class="hljs-number">1234</span>      <span class="hljs-regexp">/path/</span>to/parent<br><span class="hljs-number">2</span>    process <span class="hljs-number">5678</span>      <span class="hljs-regexp">/path/</span>to/child<br></code></pre></td></tr></table></figure></li><li><p>inferior 命令切换进程</p><blockquote><p>例如 inferior 1</p></blockquote></li></ol><ul><li><p>利用好工具，定制化的gdb</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        <span class="hljs-built_in">print</span>()<br>    <br>        <span class="hljs-keyword">for</span> proc <span class="hljs-keyword">in</span> gdb.inferiors():<br>            pid = proc.pid<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(pid) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">continue</span><br>    <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Process <span class="hljs-subst">&#123;proc.num&#125;</span> (<span class="hljs-subst">&#123;pid&#125;</span>)&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">if</span> proc <span class="hljs-keyword">is</span> gdb.selected_inferior():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>()<br>    <br>            <span class="hljs-keyword">for</span> fd_desc <span class="hljs-keyword">in</span> subprocess.check_output(<br>                [<span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-string">&#x27;-l&#x27;</span>, <span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/fd&#x27;</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span><br>            ).splitlines()[<span class="hljs-number">1</span>:]:<br>                perm, *_, fd, _, fname = fd_desc.split()<br>    <br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;rw&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;-&gt;&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;r&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;&lt;--&#x27;</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;w&#x27;</span> <span class="hljs-keyword">in</span> perm: rw = <span class="hljs-string">&#x27;--&gt;&#x27;</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;pipe:&#x27;</span> <span class="hljs-keyword">in</span> fname:<br>                    pipe_id = re.search(<span class="hljs-string">f&#x27;[0-9]+&#x27;</span>, fname).group()<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> [=== <span class="hljs-subst">&#123;pipe_id&#125;</span> ===]&#x27;</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  <span class="hljs-subst">&#123;fd&#125;</span> <span class="hljs-subst">&#123;rw&#125;</span> <span class="hljs-subst">&#123;fname&#125;</span>&#x27;</span>)<br><br>ProcDump()<br><br><br></code></pre></td></tr></table></figure><blockquote><p>这个类继承自gdb.Command类，这个类是一个GDB命令的基类，用于创建新的GDB命令。在这个类的构造函数中，调用了父类的构造函数，并传入了三个参数，分别是”pdump”，gdb.COMMAND_DATA和gdb.COMPLETE_SYMBOL。其中，”pdump”是命令名称，gdb.COMMAND_DATA表示这是一个处理数据的命令，gdb.COMPLETE_SYMBOL表示这个命令需要在符号表中进行自动补全。<br>在你的代码中，你需要在ProcDump类中实现一个名为invoke的方法，这个方法将会被调用来执行pdump命令的实际功能。</p></blockquote></li><li><p>init.gdb脚本<br>init.gdb脚本是一个GDB初始化脚本，它会在GDB启动时自动执行。你可以在这个脚本中设置GDB的一些默认行为，例如设置别名、定义宏、加载符号表等。这个脚本可以包含任意数量的GDB命令，它们会按照在脚本中出现的顺序依次执行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">gdb +x <span class="hljs-keyword">init</span>.gdb a.<span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 &#x2F;dev&#x2F;pts ?</p><blockquote><p>&#x2F;dev&#x2F;pts是一个特殊的文件系统，它提供了一个伪终端（pseudo-terminal）接口，允许用户与计算机进行交互。当用户登录到计算机时，系统会为该用户分配一个伪终端，这个伪终端就会在&#x2F;dev&#x2F;pts目录下创建一个对应的设备文件。</p></blockquote></li></ul><p>echo hello &gt; &#x2F;dev&#x2F;pts&#x2F;8 会发生什么</p><blockquote><p>会在相应终端产生输出。使用 tty 命令可以查看当前 shell 终端对应的终端文件是哪一个。</p></blockquote><ul><li><p>说明<br>由于这里文件描述符的应用我在 MIT 6.S081 中的实验1中实现过类似的，所以在这里不再详细地描述调代码的细节。</p></li><li><p>关于 va_list</p><ol><li>va_start sets arg_ptr to the first optional argument in the list of arguments that’s passed to the function.</li><li>va_arg retrieves a value of type from the location that’s given by arg_ptr, and increments arg_ptr to point to the next argument in the list by using the size of type to determine where the next argument starts. </li><li>va_end resets the pointer to NULL</li></ol></li></ul><p>是不是似乎好像会实现 printf 函数了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入输出设备模型</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器"><a href="#IO设备-CPU视角-：一个能与CPU交换数据的接口-控制器" class="headerlink" title="IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器"></a>IO设备(CPU视角)：一个能与CPU交换数据的接口&#x2F;控制器</h3><ul><li>就是“几组约定好功能的线”，通过握手信号从线上读出&#x2F;写入数据</li><li>每一组线都有自己的地址<blockquote><p>CPU可以直接使用指令(in&#x2F;out&#x2F;MMIO)和设备交换数据<br>CPU不管设备具体是如何实现的</p></blockquote></li></ul><h3 id="总线、中断控制器和DMA"><a href="#总线、中断控制器和DMA" class="headerlink" title="总线、中断控制器和DMA"></a>总线、中断控制器和DMA</h3><p>越来越多的IO设备，如何给未来留出一点空间？</p><ul><li>CPU只直接连接一个设备，这个IO设备实际上是一块板卡，板卡上有很多个小插槽(寄存器)。这个IO设备负责管理其他IO设备，这个设备就叫做总线。</li><li>甚至这个IO设备做得更彻底一点，我们的内存也连接在这个总线上，同一个地址空间，CPU只需要一个地址，就可以知道访问的是内存还是IO设备(统一编址)。</li></ul><h3 id="中断没能解决的"><a href="#中断没能解决的" class="headerlink" title="中断没能解决的"></a>中断没能解决的</h3><p>假设程序希望写入1GB的数据到磁盘</p><ul><li>即使磁盘已经准备好了，依然需要非常浪费时间的循环。<blockquote><p>DMA的出现：一个专门执行”memcpy”程序的CPU<br>通过增加一个CPU专门负责从内存到总线的数据搬运<br>memory-&gt;memory     device-&gt;memory    memory-&gt;device</p></blockquote></li></ul><h3 id="IO设备和计算机之间的边界逐渐模糊"><a href="#IO设备和计算机之间的边界逐渐模糊" class="headerlink" title="IO设备和计算机之间的边界逐渐模糊"></a>IO设备和计算机之间的边界逐渐模糊</h3><p>DMA不就是一个“只做一件特别事情的”CPU吗</p><ul><li>那么我们还可以有做各种事情的”CPU”啊, 例如显卡</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设备驱动程序</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课的主要内容"><a href="#本次课的主要内容" class="headerlink" title="本次课的主要内容"></a>本次课的主要内容</h2><ul><li>什么是设备驱动程序</li><li>Linux设备抽象</li></ul><h3 id="设备驱动程序原理"><a href="#设备驱动程序原理" class="headerlink" title="设备驱动程序原理"></a>设备驱动程序原理</h3><ul><li>设备其实是一组寄存器和一组协议，一个设备，一个协议</li></ul><p>设备可以分为两种</p><ol><li>字符设备：字节流，例如键盘</li><li>块设备：字节数组，例如磁盘</li></ol><h3 id="操作系统：设备-支持各类操作的对象（文件）"><a href="#操作系统：设备-支持各类操作的对象（文件）" class="headerlink" title="操作系统：设备&#x3D;支持各类操作的对象（文件）"></a>操作系统：设备&#x3D;支持各类操作的对象（文件）</h3><ul><li>read: 从设备某个指定的位置读出数据</li><li>write：向设备某个位置写入数据</li><li>ioctl: 读取&#x2F;设置设备的状态, ioctl是一个系统调用<br>上面为设备建立一个模型       <blockquote><p>也就是说，把上面这三个系统调用，也就是通用的API，经过设备驱动程序，翻译成设备能够听得懂的语言, 这段代码就是设备驱动程序。</p></blockquote></li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>把系统调用“翻译”成与设备寄存器的交互</p><ul><li>就是一段普通的内核代码</li><li>有可能这个设备驱动程序后面就是一个真实的设备，有可能没有设备，就是用设备驱动程序来模拟这个设备</li></ul><p>例如：&#x2F;dev&#x2F;中的对象</p><ol><li>&#x2F;dev&#x2F;null   null设备</li><li>&#x2F;dev&#x2F;random   随机数生成器</li></ol><h3 id="Linux设备驱动"><a href="#Linux设备驱动" class="headerlink" title="Linux设备驱动"></a>Linux设备驱动</h3><p>我们希望实现一个最简单的“软件定义核弹”</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内核线程与进程、进程API</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%EF%BC%9B%E8%BF%9B%E7%A8%8BAPI/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><h3 id="虚拟化：操作系统同时保存多个状态机"><a href="#虚拟化：操作系统同时保存多个状态机" class="headerlink" title="虚拟化：操作系统同时保存多个状态机"></a>虚拟化：操作系统同时保存多个状态机</h3><p>C程序 &#x3D; 状态机</p><ul><li>初始状态： main(argc, argv)</li><li>状态迁移： 指令的执行，包括syscall</li></ul><p>实际上，在 UNIX&#x2F;Linux 系统内核完成初始化后，只有一个 init 进程被启动，从此以后，操作系统内核就化身为了一个事件驱动的程序、状态机的管理者，仅在中断和系统调用发生时开始执行。</p><p>下面看一段小代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)&#123;<br>fork();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写出代码的运行结果。</p></blockquote><ul><li>.&#x2F;a.out</li><li>.&#x2F;a.out | cat</li></ul><ol><li>当执行.&#x2F;a.out时，会打印 6 个 Hello</li><li>当执行.&#x2F;a.out | wc -l 时，会打印 8 个 Hello ? 这是为什么呢？</li></ol><p>不妨用 strace 来看一下。<br>我们发现，</p><blockquote><p>我们的 printf 不总是打印到标准输出的。也就是说它根据标准输出连接的是终端还是管道，它会做不同的行为，这里连接到了管道，也就把输出放到一个缓冲区里面 。当第一个循环之后，缓冲区里面有一个 hello，有两个进程；第二次循环完毕后，缓冲区里面有 2 个 hello, 总共 4 个进程。所以打印 8 个。 </p></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>应用程序执行的环境。</p><ul><li>export: 告诉shell在创建子进程的时候设置环境变量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可执行程序</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="可执行文件：状态机的描述"><a href="#可执行文件：状态机的描述" class="headerlink" title="可执行文件：状态机的描述"></a>可执行文件：状态机的描述</h2><h3 id="一个描述了状态机初始状态-迁移的数据结构"><a href="#一个描述了状态机初始状态-迁移的数据结构" class="headerlink" title="一个描述了状态机初始状态 + 迁移的数据结构"></a>一个描述了状态机初始状态 + 迁移的<font color=#FF000 >数据结构</font></h3><ol><li>寄存器：大部分由ABI规定，操作系统负责设置。例如初始化pc。</li><li>地址空间：二进制文件+ABI共同决定。例如argv和envp的存储。</li><li>其他有用的信息（例如调试和core dump的信息）</li></ol><hr><h2 id="可执行文件里面应该有什么？"><a href="#可执行文件里面应该有什么？" class="headerlink" title="可执行文件里面应该有什么？"></a>可执行文件里面应该有什么？</h2><p>可执行程序描述了状态机重置后的状态，那状态有什么呢？</p><blockquote><p>无非就是寄存器和内存（地址空间）</p></blockquote><hr><h2 id="操作系统上的可执行程序"><a href="#操作系统上的可执行程序" class="headerlink" title="操作系统上的可执行程序"></a>操作系统上的可执行程序</h2><p>需要满足以下条件：</p><ol><li><p>具有执行(x)权限<br>执行.&#x2F;a.c命令 (出现permission denied错误)<br>但如果先执行 chmod +x a.c命令，会出现加载器不能正确识别题。    </p></li><li><p>加载器能够识别的可执行文件</p></li></ol><hr><h2 id="常见的可执行文件"><a href="#常见的可执行文件" class="headerlink" title="常见的可执行文件"></a>常见的可执行文件</h2><blockquote><p>就是操作系统里面的一个普通对象。</p></blockquote><h3 id="UNIX-Linux"><a href="#UNIX-Linux" class="headerlink" title="UNIX&#x2F;Linux"></a>UNIX&#x2F;Linux</h3><ul><li>a.out</li><li>ELF</li><li>She-bang<blockquote><p>She-bang是什么呢？其实就是一个“偷换参数”地execve。</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">#!/usr/bin/python3               #这是一个可执行文件<br>print(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再执行命令 chmod +x a.c。上面这个文件就可以执行了。<br>如果加载器这样一个程序的时候，如果它发现一个#!开头的，就会在execve偷换一下，把#!后面的填入execve的第一个参数，该文件名填入第二个参数。</p><hr><h2 id="从C代码到二进制文件"><a href="#从C代码到二进制文件" class="headerlink" title="从C代码到二进制文件"></a>从C代码到二进制文件</h2><p>一段简单的C代码(main.c)：   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    hello();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>gcc -O2 -c main.c得到main.o文件, 然后objdump -d main.o得到反汇编 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">0000000000000000</span> &lt;main&gt;:<br>   <span class="hljs-number">0</span>:   f3 <span class="hljs-number">0f</span> <span class="hljs-number">1</span>e fa             endbr64 <br>   <span class="hljs-number">4</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">08</span>             sub    $<span class="hljs-number">0x8</span>,%rsp<br>   <span class="hljs-number">8</span>:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>   a:   e8 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          call   f &lt;main+<span class="hljs-number">0xf</span>&gt;<br>   f:   <span class="hljs-number">31</span> c0                   xor    %eax,%eax<br>  <span class="hljs-number">11</span>:   <span class="hljs-number">48</span> <span class="hljs-number">83</span> c4 <span class="hljs-number">08</span>             add    $<span class="hljs-number">0x8</span>,%rsp<br>  <span class="hljs-number">15</span>:   c3                      ret    <br></code></pre></td></tr></table></figure><p>我们可以看到 0xa 地址处，由于不知道hello函数的地址，这里暂时填为 0</p><p>hello.c的代码块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xa</span> + <span class="hljs-number">1</span>;   <span class="hljs-comment">//有上面汇编代码可以看出，代填 </span><br>               <span class="hljs-comment">//hello地址为 main 的地址加上偏移再加上1(操作码1个字节)</span><br>    <span class="hljs-type">int32_t</span> offset = *(<span class="hljs-type">int32_t</span>*)p;<br>    assert( (<span class="hljs-type">char</span>*)main + <span class="hljs-number">0xf</span> +offset == (<span class="hljs-type">char</span>*)hello);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下：在我们的main函数要调用hello函数时，此时pc会指向这条call指令的下一条指令的地址，也就是pc指针会是(char*)main + 0xf,由于是相对寻址(call指令的语义)，所以会跳转到pc + offset的位置，offset也就是待填地址处的值。而跳转后的地址要是hello的地址。</p></blockquote><p>我们 readelf -a main.o 来看一下有什么输出信息,其中有一部分是这样的（这里复制过来格式有点不正确）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Relocation</span> section &#x27;.rela.text.startup&#x27; at offset <span class="hljs-number">0</span>x1b8 contains <span class="hljs-number">1</span> entry:<br>  <span class="hljs-attribute">Offset</span>          Info       Type        Sym. Value    Sym. Name+Addend<br><span class="hljs-attribute">00000000000b</span>  <span class="hljs-number">000600000004</span> R_X86_64_PLT32 <span class="hljs-number">0000000000000000</span> hello - <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="重新理解编译、链接流程"><a href="#重新理解编译、链接流程" class="headerlink" title="重新理解编译、链接流程"></a>重新理解编译、链接流程</h2><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><blockquote><p>High-level semantics(高级C状态机) -&gt; Low-level semantics(汇编状态机)</p></blockquote><h3 id="汇编器"><a href="#汇编器" class="headerlink" title="汇编器"></a>汇编器</h3><blockquote><p>Low-level semantics -&gt; Binary semantics(状态机的容器)</p></blockquote><ol><li>“一一对应”地翻译成二进制代码，sections, symbols, debug info……</li><li>不能决定的要留下“之后要怎么办”的信息(relocations重定位)</li></ol><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><blockquote><p>合并所有的容器，得到一个完整的状态机</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多处理器编程从入门到放弃</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：多处理器编程：从入门到放弃："><a href="#本讲内容：多处理器编程：从入门到放弃：" class="headerlink" title="本讲内容：多处理器编程：从入门到放弃："></a>本讲内容：多处理器编程：从入门到放弃：</h2><ul><li>入门：多线程编程库</li><li>放弃：原子性、可见性、顺序</li></ul><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>每个线程都有自己的堆栈，如何确定各自的堆栈大小？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> low[<span class="hljs-number">64</span>];<br><span class="hljs-type">void</span> * <span class="hljs-keyword">volatile</span> high[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update_range</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">void</span> *ptr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (ptr &lt; low[T]) low[T] = ptr;<br>    <span class="hljs-keyword">if</span> (ptr &gt; high[T]) high[T] = ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">probe</span><span class="hljs-params">(<span class="hljs-type">int</span> T, <span class="hljs-type">int</span> n)</span> &#123;<br>  update_range(T, &amp;n);<br>  <span class="hljs-type">long</span> sz = (<span class="hljs-type">uintptr_t</span>)high[T] - (<span class="hljs-type">uintptr_t</span>)low[T];<br>  <span class="hljs-keyword">if</span> (sz % <span class="hljs-number">1024</span> &lt; <span class="hljs-number">32</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Stack(T%d) &gt;= %ld KB\n&quot;</span>, T, sz / <span class="hljs-number">1024</span>);<br>  &#125;<br>  probe(T, n + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Infinite recursion</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tprobe</span><span class="hljs-params">(<span class="hljs-type">int</span> T)</span> &#123;<br>  low[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>;<br>  high[T] = (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>  update_range(T, &amp;T);<br>  probe(T, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    create(Tprobe);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要 setbuf(stdout, NULL) 关闭缓冲区？</p><blockquote><p>有时候一个printf明明在crash前的代码运行了，但没有得到输出，原因是什么呢？<br>是因为printf先把输出放在缓冲区里。</p></blockquote><p>这段代码的核心思想就是无穷递归，利用函数参数存储在栈空间里估算栈的大小。</p><h2 id="放弃：原子性"><a href="#放弃：原子性" class="headerlink" title="放弃：原子性"></a>放弃：原子性</h2><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100000000</span><br><br><span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Tsum</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>    sum++;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  create(Tsum);<br>  create(Tsum);<br>  join();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum = %ld\n&quot;</span>, sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译优化 -O2得到答案 200000000</p><blockquote><p>编译器直接计算出答案，一条指令赋值给sum</p></blockquote><p>编译优化 -O1得到答案 100000000</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接和加载(2)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="动态链接与加载原理"><a href="#动态链接与加载原理" class="headerlink" title="动态链接与加载原理"></a>动态链接与加载原理</h2><h3 id="若干要素"><a href="#若干要素" class="headerlink" title="若干要素"></a>若干要素</h3><ol><li>编译成位置无关代码</li><li>对外部函数的调用是查表的</li><li>在运行（加载）的时候填表</li></ol><p>我们就发明了GOT(Global Offset Table)</p><blockquote><p>也就是table </p></blockquote><h3 id="有个有趣的问题"><a href="#有个有趣的问题" class="headerlink" title="有个有趣的问题"></a>有个有趣的问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>; <br></code></pre></td></tr></table></figure><p>编译器遇到函数调用，应该翻译成哪种指令？</p><ul><li>如果是同一个动态链接库    call foo   (因为如果是一个库的，链接的时候相对地址已经确定下来了)</li><li>如果是另外一个动态链接库  call TABLE(foo)</li></ul><p>这就需要PLT (Procedure Linkage Table)       </p><ul><li>函数太多，每个都标记区分太难看</li><li>编译器总是生成一个直接的call<blockquote><p>来自另一个动态链接库     call foo@plt            </p></blockquote></li></ul><h3 id="更多的细节"><a href="#更多的细节" class="headerlink" title="更多的细节"></a>更多的细节</h3><p>对于一个动态链接的二进制文件，execve后的第一条指令在哪里？</p><ul><li>what are the first a few steps executed after execve() of a ELF dynamic link binary?  (Chatgpt)</li></ul><blockquote><p>第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2   _start函数<br>也就是说，刚刚执行玩execve后，我们的pc指针指向了ld.so中的代码。</p></blockquote><ol><li>首先会加载这个ELF文件，把相关的段加载进地址空间中。</li><li>内核会根据查看程序头表(program header)中的PT_INTERP的判断是否需要动态链接。如果需要，内核就会把动态链接器(通常来说是ld-linux.so)加载进进程的地址空间中。</li><li>设置栈的初始状态。</li><li>把控制交给动态链接器：内核把pc指针设置为动态链接器的入口地址。</li><li>动态链接器的初始化，解析符号，重定位等。</li><li>把控制权交给程序(通常来说是_start函数)</li></ol><ul><li>How can I compile an ELF binary that use an alternative dynamic loader than the default ld.so?（能否替换这个加载器） <blockquote><p>gcc -o hello hello.c -Wl, –dynamic-linker&#x3D;&#x2F;path&#x2F;to&#x2F;my_ld.so<br>readelf -l hello | grep “program interpreter” 查看可执行文件的动态链接器</p></blockquote></li></ul><p>示例代码<br>ld.S  ——  将来链接成动态链接库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><br>.globl _start<br>_start:<br>  movq $SYS_write, %rax   <span class="hljs-comment">// write(</span><br>  movq $<span class="hljs-number">1</span>,         %rdi   <span class="hljs-comment">//   fd=1,</span><br>  lea  <span class="hljs-title function_">st</span><span class="hljs-params">(%rip)</span>,   %rsi   <span class="hljs-comment">//   buf=st,</span><br>  movq $<span class="hljs-params">(ed - st)</span>, %rdx   <span class="hljs-comment">//   count=ed-st</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>  movq $SYS_exit,  %rax   <span class="hljs-comment">// exit(</span><br>  movq $1,         %rdi   <span class="hljs-comment">//   status=1</span><br>  syscall                 <span class="hljs-comment">// );</span><br><br>st:<br>  .ascii &quot;\033[01;<span class="hljs-number">31</span>mThis is a loader.\<span class="hljs-number">033</span>[<span class="hljs-number">0</span>m\n<span class="hljs-string">&quot;</span><br><span class="hljs-string">ed:</span><br></code></pre></td></tr></table></figure><p>hello.c </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ld<span class="hljs-selector-class">.so</span>: ld<span class="hljs-selector-class">.S</span> hello<span class="hljs-selector-class">.c</span><br>gcc -fPIC -shared -c ld<span class="hljs-selector-class">.S</span><br>ld -shared ld<span class="hljs-selector-class">.o</span> -o ld<span class="hljs-selector-class">.so</span><br>gcc hello<span class="hljs-selector-class">.c</span> -Wl,<span class="hljs-attr">--dynamic-linker</span>=$(PWD)/ld.so<br></code></pre></td></tr></table></figure><ul><li>当我们输入make指令并执行 .&#x2F;a.out 时，我们看到，我们并没有输出Hello,而是输出了This is a loader. 这也就说明了我们的动态链接器确实换掉了，由于hello.c是动态链接的，所以内核会加载我们自己的动态链接器并执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态链接和加载(1)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A0%E8%BD%BD(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="本次课要回答的问题"><a href="#本次课要回答的问题" class="headerlink" title="本次课要回答的问题"></a>本次课要回答的问题</h2><ol><li>可执行文件是如何被操作系统加载的</li><li>什么是动态链接&#x2F;动态加载</li></ol><h2 id="静态ELF加载器：实现"><a href="#静态ELF加载器：实现" class="headerlink" title="静态ELF加载器：实现"></a>静态ELF加载器：实现</h2><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><ol><li>解析数据结构 + 复制到内存 + 跳转</li><li>创建进程运行时的初始状态(argv,envp,…)</li></ol><h3 id="loader-static-c"><a href="#loader-static-c" class="headerlink" title="loader-static.c"></a>loader-static.c</h3><ol><li>可以加载任何静态链接的代码, minimal.S, dfs-fork.c</li><li>并可以正确处理参数&#x2F;环境变量 env.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STK_SZ           (1 &lt;&lt; 20)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROUND(x, align)  (void *)(((uintptr_t)x) &amp; ~(align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD(x, align)    (((uintptr_t)x) &amp; (align - 1))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> push(sp, T, ...) (&#123; *((T*)sp) = (T)__VA_ARGS__; sp = (void *)((uintptr_t)(sp) + sizeof(T)); &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">execve_</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-comment">// WARNING: This execve_ does not free process resources.</span><br>  <span class="hljs-type">int</span> fd = open(file, O_RDONLY);<br>  assert(fd &gt; <span class="hljs-number">0</span>);<br>  Elf64_Ehdr *h = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">4096</span>, PROT_READ, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  assert(h != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>  assert(h-&gt;e_type == ET_EXEC &amp;&amp; h-&gt;e_machine == EM_X86_64);<br><br>  Elf64_Phdr *pht = (Elf64_Phdr *)((<span class="hljs-type">char</span> *)h + h-&gt;e_phoff);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h-&gt;e_phnum; i++) &#123;<br>    Elf64_Phdr *p = &amp;pht[i];<br>    <span class="hljs-keyword">if</span> (p-&gt;p_type == PT_LOAD) &#123;<br>      <span class="hljs-type">int</span> prot = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_R) prot |= PROT_READ;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_W) prot |= PROT_WRITE;<br>      <span class="hljs-keyword">if</span> (p-&gt;p_flags &amp; PF_X) prot |= PROT_EXEC;<br>      <span class="hljs-type">void</span> *ret = mmap(<br>        ROUND(p-&gt;p_vaddr, p-&gt;p_align),              <span class="hljs-comment">// addr, rounded to ALIGN</span><br>        p-&gt;p_memsz + MOD(p-&gt;p_vaddr, p-&gt;p_align),   <span class="hljs-comment">// length</span><br>        prot,                                       <span class="hljs-comment">// protection</span><br>        MAP_PRIVATE | MAP_FIXED,                    <span class="hljs-comment">// flags, private &amp; strict</span><br>        fd,                                         <span class="hljs-comment">// file descriptor</span><br>        (<span class="hljs-type">uintptr_t</span>)ROUND(p-&gt;p_offset, p-&gt;p_align)); <span class="hljs-comment">// offset</span><br>      assert(ret != (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>);<br>      <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(p-&gt;p_vaddr + p-&gt;p_filesz), <span class="hljs-number">0</span>, p-&gt;p_memsz - p-&gt;p_filesz);<br>    &#125;<br>  &#125;<br>  close(fd);<br><br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> <span class="hljs-built_in">stack</span>[STK_SZ], rnd[<span class="hljs-number">16</span>];<br>  <span class="hljs-type">void</span> *sp = ROUND(<span class="hljs-built_in">stack</span> + <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">stack</span>) - <span class="hljs-number">4096</span>, <span class="hljs-number">16</span>);<br>  <span class="hljs-type">void</span> *sp_exec = sp;<br>  <span class="hljs-type">int</span> argc = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// argc</span><br>  <span class="hljs-keyword">while</span> (argv[argc]) argc++;<br>  push(sp, <span class="hljs-type">intptr_t</span>, argc);<br>  <span class="hljs-comment">// argv[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= argc; i++)<br>    push(sp, <span class="hljs-type">intptr_t</span>, argv[i]);<br>  <span class="hljs-comment">// envp[], NULL-terminate</span><br>  <span class="hljs-keyword">for</span> (; *envp; envp++) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strchr</span>(*envp, <span class="hljs-string">&#x27;_&#x27;</span>)) <span class="hljs-comment">// remove some verbose ones</span><br>      push(sp, <span class="hljs-type">intptr_t</span>, *envp);<br>  &#125;<br>  <span class="hljs-comment">// auxv[], AT_NULL-terminate</span><br>  push(sp, <span class="hljs-type">intptr_t</span>, <span class="hljs-number">0</span>);<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_RANDOM, .a_un.a_val = (<span class="hljs-type">uintptr_t</span>)rnd &#125; );<br>  push(sp, Elf64_auxv_t, &#123; .a_type = AT_NULL &#125; );<br><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov $0, %%rdx;&quot;</span> <span class="hljs-comment">// required by ABI</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;mov %0, %%rsp;&quot;</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;jmp *%1&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span>(sp_exec), <span class="hljs-string">&quot;b&quot;</span>(h-&gt;e_entry))</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[], <span class="hljs-type">char</span> *envp[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s file [args...]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  execve_(argv[<span class="hljs-number">1</span>], argv + <span class="hljs-number">1</span>, envp);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下我们这里的loader(它是动态链接的): 给我们的loader传入一个参数,它执行到某一个状态的时候，把我们的ELF文件(argv[1])搬到我们的loader程序的状态上,相当于我们的程序被替换了,但这个过程并没有执行execve,只是简单地用mmap系统调用(当然操作系统加载loader这个程序的时候会用execve)。</p></blockquote></li></ol><h3 id="初始化堆栈"><a href="#初始化堆栈" class="headerlink" title="初始化堆栈"></a>初始化堆栈</h3><p>状态机是well-defined的。</p><table><thead><tr><th>表头</th><th>表头</th><th>长度(字节)</th></tr></thead><tbody><tr><td>其他信息</td><td></td><td>未知</td></tr><tr><td>Null auxiliary vector entry</td><td></td><td>1 eightbyte each</td></tr><tr><td>Auxiliary vector entries</td><td></td><td>2 eightbytes each</td></tr><tr><td>0</td><td></td><td>8</td></tr><tr><td>Environment pointers</td><td></td><td>8 bytes each</td></tr><tr><td>0</td><td>8 + 8*argc + %rsp</td><td>8</td></tr><tr><td>Argument pointers</td><td>8 + %rsp</td><td>argc 8</td></tr><tr><td>Argument count</td><td>%rsp</td><td>8</td></tr><tr><td>Undefined</td><td>Low Address</td><td></td></tr></tbody></table><h3 id="有趣之处"><a href="#有趣之处" class="headerlink" title="有趣之处"></a>有趣之处</h3><blockquote><p>这是在操作系统上实现的。用 open , mmap, close实现了一个 execve。     </p></blockquote><hr><h2 id="动态链接和加载"><a href="#动态链接和加载" class="headerlink" title="动态链接和加载"></a>动态链接和加载</h2><h3 id="为什么要动态加载"><a href="#为什么要动态加载" class="headerlink" title="为什么要动态加载"></a>为什么要动态加载</h3><ol><li>减少库函数的磁盘和内存拷贝</li></ol><ul><li>每个可执行文件里面都有所有的库函数拷贝那也太浪费了</li><li>只要遵守约定，不挑战库函数的版本(否则发布一个新版本就要重新编译全部程序)</li></ul><h3 id="这就有了”拆解应用程序”的需求"><a href="#这就有了”拆解应用程序”的需求" class="headerlink" title="这就有了”拆解应用程序”的需求"></a>这就有了”拆解应用程序”的需求</h3><blockquote><p>随着库函数越来越大，希望项目能够运行时链接。</p></blockquote><h3 id="动态链接，但不讲ELF-换一种方法。"><a href="#动态链接，但不讲ELF-换一种方法。" class="headerlink" title="动态链接，但不讲ELF,换一种方法。"></a>动态链接，但不讲ELF,换一种方法。</h3><ul><li>如果编译器、链接器、加载器都受你控制</li><li>那你怎么设计实现一个“最直观”的动态链接格式？</li><li>如何改进，就得到了ELF！</li><li>假设编译器可以为你生成位置无关代码(PIC)</li></ul><h3 id="来看一下蒋神的设计-main-part"><a href="#来看一下蒋神的设计-main-part" class="headerlink" title="来看一下蒋神的设计(main part)"></a>来看一下蒋神的设计(main part)</h3><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul><li>dl.h(数据结构定义)</li></ul><h4 id="全家桶工具集"><a href="#全家桶工具集" class="headerlink" title="全家桶工具集"></a>全家桶工具集</h4><ul><li>dlbox.c(gcc, readdl, objdump, interp)</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>libc.S - 提供 putchar 和 exit</li><li>libhello.S - 调用 putchar, 提供 hello</li><li>main.S - 调用 hello, 提供 main</li></ul><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o dlbox dlbox<span class="hljs-selector-class">.c</span><br>./dlbox gcc libc<span class="hljs-selector-class">.S</span><br>./dlbox gcc libhello<span class="hljs-selector-class">.S</span><br>./dlbox gcc <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.S</span><br>./dlbox readdl libc<span class="hljs-selector-class">.dl</span>         <span class="hljs-comment">//readelf</span><br></code></pre></td></tr></table></figure><blockquote></blockquote><p>会生成.dl格式的自定义可执行文件。这个可执行文件是不可以在操作系统上执行，需要自己的加载器。<br>并且我们的加载器是在当前目录中动态加载.dl文件(根据)的，如果先前没有生成所需要的.dl文件的话，我们的加载器会出现错误。</p><blockquote></blockquote><h4 id="演示一下下"><a href="#演示一下下" class="headerlink" title="演示一下下"></a><strong>演示一下下</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br>DL_HEAD<br><br><span class="hljs-title function_">LOAD</span><span class="hljs-params">(<span class="hljs-string">&quot;libc.dl&quot;</span>)</span><br><span class="hljs-title function_">IMPORT</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br><span class="hljs-title function_">EXPORT</span><span class="hljs-params">(hello)</span><br><br>DL_CODE<br><br>hello:<br>  lea <span class="hljs-title function_">str</span><span class="hljs-params">(%rip)</span>, %rdi<br>  mov <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span>, %eax<br>  push %rbx<br>  mov %rdi, %rbx<br>  inc %eax<br>  mov %eax, <span class="hljs-title function_">count</span><span class="hljs-params">(%rip)</span><br>  add $0x30, %eax<br>  movb %al, 0<span class="hljs-title function_">x6</span><span class="hljs-params">(%rdi)</span><br>loop:<br>  <span class="hljs-title function_">movsbl</span> <span class="hljs-params">(%rbx)</span>,%edi<br>  test %dil,%dil<br>  je out<br>  call <span class="hljs-title function_">DSYM</span><span class="hljs-params">(<span class="hljs-built_in">putchar</span>)</span><br>  inc  %rbx<br>  jmp loop<br>out:<br>  pop %rbx<br>  ret<br><br>str:<br>  .asciz &quot;Hello X\n&quot;<br><br>count:<br>  .<span class="hljs-type">int</span> 0<br><br>DL_END<br><br></code></pre></td></tr></table></figure><blockquote><p>这个文件需要使用外部的putchar函数,所以需要call DSYM(putchar), DSYM表示动态链接的，也需要手动指明putchar函数所在的库libc.dl。它定义有一个hello函数，所以需要导出。也就是EXPORT(hello).</p></blockquote><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a><strong>代码解析</strong></h3><ol><li><p><strong>首先来看一下dl.h文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> REC_SZ 32</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_MAGIC <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __ASSEMBLER__</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_HEAD     __hdr: \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* magic */</span>    .ascii DL_MAGIC; \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* file_sz */</span>  .4byte (__end - __hdr); \</span><br><span class="hljs-meta">                      <span class="hljs-comment">/* code_off */</span> .4byte (__code - __hdr)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_CODE     .fill REC_SZ - 1, 1, 0; \</span><br><span class="hljs-meta">                      .align REC_SZ, 0; \</span><br><span class="hljs-meta">                      __code:</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DL_END      __end:</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> RECORD(sym, off, name) \</span><br><span class="hljs-meta">    .align REC_SZ, 0; \</span><br><span class="hljs-meta">    sym .8byte (off); .ascii name</span><br><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> IMPORT(sym) RECORD(sym:,           0, <span class="hljs-string">&quot;?&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> EXPORT(sym) RECORD(    , sym - __hdr, <span class="hljs-string">&quot;#&quot;</span> #sym <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> LOAD(lib)   RECORD(    ,           0, <span class="hljs-string">&quot;+&quot;</span> lib  <span class="hljs-string">&quot;\0&quot;</span>)</span><br>  <span class="hljs-meta">#<span class="hljs-keyword">define</span> DSYM(sym)   *sym(%rip)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> &#123;</span><br>    <span class="hljs-type">char</span> magic[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">uint32_t</span> file_sz, code_off;<br>  &#125;;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> &#123;</span><br>    <span class="hljs-type">int64_t</span> offset;<br>    <span class="hljs-type">char</span> type, name[REC_SZ - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int64_t</span>) - <span class="hljs-number">1</span>];<br>  &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure><blockquote><ol><li>__ASSEMBLER__是一个内置的宏，它由编译器预定义，用于判断当前代码是否为汇编代码。在编写汇编代码时，编译器会自动定义这个宏。</li><li>怎么用汇编语言定义结构体呢？ 为什么变量名前面要加.呢？这表示这是在当前偏移量下定义的。</li><li>RECORD宏定义：.align REC_SZ, 0 表示将当前位置对齐到 REC_SZ 字节边界。<br>这行代码定义了一个标签 sym，并将 off 表示的偏移量存储到该标签处。.8byte 指令告诉汇编器为该标签分配一个 8 字节的存储空间，即使用一个 64 位无符号整数来存储偏移量。<br>.ascii name 表示将 name 参数表示的记录名称作为 ASCII 字符串嵌入到汇编代码中。.ascii 指令用于将一个字符串常量嵌入到汇编代码中。</li><li>#define DSYM(sym)  这是间接跳转，先将 %rip 寄存器中存储的当前指令地址加上 hello 符号相对于当前指令的偏移量，得到函数地址，然后再根据这个地址的值进行跳转，而符号表结构体前八个字节就是函数的地址。</li></ol></blockquote></li><li><p><strong>dlbox.c文件</strong></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;dl.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LENGTH(arr) (sizeof(arr) / sizeof(arr[0]))</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">symtab</span>;</span> <span class="hljs-comment">// borrowed spaces from header</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span>;<br><br><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br><span class="hljs-comment">// Implementation of binutils</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_readdl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DLIB file %s:\n\n&quot;</span>, h-&gt;path);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;    LOAD  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  EXTERN  %s\n&quot;</span>, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: <span class="hljs-built_in">printf</span>(   <span class="hljs-string">&quot;%08lx  %s\n&quot;</span>, sym-&gt;offset, sym-&gt;name); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_objdump</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">char</span> *hc = (<span class="hljs-type">char</span> *)h, cmd[<span class="hljs-number">64</span>];<br>  FILE *fp = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Disassembly of binary %s:\n&quot;</span>, h-&gt;path);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> *code = hc + h-&gt;hdr.code_off; code &lt; hc + h-&gt;hdr.file_sz; code++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>      <span class="hljs-keyword">if</span> (hc + sym-&gt;offset == code) &#123;<br>        <span class="hljs-type">int</span> off = code - hc - h-&gt;hdr.code_off;<br>        <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>        <span class="hljs-built_in">sprintf</span>(cmd, <span class="hljs-string">&quot;ndisasm - -b 64 -o 0x%08x\n&quot;</span>, off);<br>        fp = popen(cmd, <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n%016x &lt;%s&gt;:\n&quot;</span>, off, sym-&gt;name);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fp) fputc(*code, fp);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (fp) pclose(fp);<br>&#125;<br><br><span class="hljs-comment">// binutils: interpreter</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cmd</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *cmd;<br>  <span class="hljs-type">void</span> (*handler)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path);<br>&#125; commands[] = &#123;<br>  &#123; <span class="hljs-string">&quot;gcc&quot;</span>,     dl_gcc &#125;,<br>  &#123; <span class="hljs-string">&quot;readdl&quot;</span>,  dl_readdl &#125;,<br>  &#123; <span class="hljs-string">&quot;objdump&quot;</span>, dl_objdump &#125;,<br>  &#123; <span class="hljs-string">&quot;interp&quot;</span>,  dl_interp &#125;,<br>  &#123; <span class="hljs-string">&quot;&quot;</span>,        <span class="hljs-literal">NULL</span> &#125;,<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s &#123;gcc|readdl|objdump|interp&#125; FILE...\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> cmd *cmd = &amp;commands[<span class="hljs-number">0</span>]; cmd-&gt;handler; cmd++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **path = &amp;argv[<span class="hljs-number">2</span>]; *path &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], cmd-&gt;cmd) == <span class="hljs-number">0</span>; path++) &#123;<br>      <span class="hljs-keyword">if</span> (path != argv + <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>      cmd-&gt;handler(*path);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Implementation of dlopen()</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">symbol</span> *<span class="hljs-title">libs</span>[16], <span class="hljs-title">syms</span>[128];</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">dlsym</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(syms[i].name, name) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)syms[i].offset;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlload</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> symbol *sym)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(libs); i++) &#123;<br>    <span class="hljs-keyword">if</span> (libs[i] &amp;&amp; <span class="hljs-built_in">strcmp</span>(libs[i]-&gt;name, sym-&gt;name) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// already loaded</span><br>    <span class="hljs-keyword">if</span> (!libs[i]) &#123;<br>      libs[i] = sym;<br>      dlopen(sym-&gt;name); <span class="hljs-comment">// load recursively</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="来解释一下-按顺序-："><a href="#来解释一下-按顺序-：" class="headerlink" title="来解释一下(按顺序)："></a>来解释一下(按顺序)：</h3><ol><li><p>首先需要dl_gcc各.S文件得到.dl。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_gcc</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>], *dot = <span class="hljs-built_in">strrchr</span>(path, <span class="hljs-string">&#x27;.&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (dot) &#123;<br>    *dot = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;gcc -m64 -fPIC -c %s.S &amp;&amp; &quot;</span><br>      <span class="hljs-string">&quot;objcopy -S -j .text -O binary %s.o %s.dl&quot;</span>, path, path, path);<br>    system(buf);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>原来命令行还可以这么写！ 前一句生成64位的位置无关代码，然后再把代码段拷贝成.dl文件。这里主要是一些宏替换，并且由于我们的汇编代码格式是很严格地按照dl_hdr的形式写的，所以我们得到的其实是一个dl_lib的结构体。更直观地来感受一下，我们使用命令gcc -E main.S,得到宏替换展开的文件(如下):</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 0 &quot;main.S&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;built-in&gt;&quot;</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot;</span><br><span class="hljs-comment"># 1 &quot;/usr/include/stdc-predef.h&quot; 1 3 4</span><br><span class="hljs-comment"># 0 &quot;&lt;command-line&gt;&quot; 2</span><br><span class="hljs-comment"># 1 &quot;main.S&quot;</span><br><span class="hljs-comment"># 1 &quot;dl.h&quot; 1</span><br><span class="hljs-comment"># 2 &quot;main.S&quot; 2</span><br><br>__hdr: <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;\x01\x14\x05\x14&quot;</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__end - __hdr)</span>; <span class="hljs-string">.4byte</span> <span class="hljs-params">(__code - __hdr)</span><br><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libc.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;+&quot;</span> <span class="hljs-string">&quot;libhello.dl&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; hello: <span class="hljs-string">.8byte</span> <span class="hljs-params">(0)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;?&quot;</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><span class="hljs-string">.align</span> 32, 0; <span class="hljs-string">.8byte</span> <span class="hljs-params">(main - __hdr)</span>; <span class="hljs-string">.ascii</span> <span class="hljs-string">&quot;#&quot;</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-string">&quot;\0&quot;</span><br><br><span class="hljs-string">.fill</span> 32 - 1, 1, 0; <span class="hljs-string">.align</span> 32, 0; __code:<br><br>main:<br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  call *hello<span class="hljs-params">(%rip)</span><br>  movq $0, %rax<br>  ret<br><br>__end:<br></code></pre></td></tr></table></figure><blockquote><p>xxd main.dl命令得到二进制文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dotnetcli">00000000: 0114 0514 e000 0000 c000 0000 0000 0000  ................<br>00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000020: 0000 0000 0000 0000 2b6c 6962 632e 646c  ........+libc.dl<br>00000030: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000040: 0000 0000 0000 0000 2b6c 6962 6865 6c6c  ........+libhell<br>00000050: 6f2e 646c 0000 0000 0000 0000 0000 0000  o.dl............<br>00000060: 0000 0000 0000 0000 3f68 656c 6c6f 0000  ........?hello..<br>00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>00000080: c000 0000 0000 0000 236d 6169 6e00 0000  ........#main...<br>00000090: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000b0: 0000 0000 0000 0000 0000 0000 0000 0000  ................<br>000000c0: ff15 9aff ffff ff15 94ff ffff ff15 8eff  ................<br>000000d0: ffff ff15 88ff ffff 48c7 c000 0000 00c3  ........H.......<br></code></pre></td></tr></table></figure><blockquote><p>libc.dl、libhello.dl、hello这三个符号都是填零的。只有main函数已经填上了正确的偏移。<br>可以反推，我们得到的.dl文件的格式是这样的：首先是__hdr头，这里有模数，文件的大小，以及代码段的偏移。 然后是符号表；符号表结束后，再32个字节填0作为分界线，然后是代码段。 妙哇妙哇！原来宏定义还可以这么用！</p></blockquote></li><li><p><strong>然后是dl_interp函数来解释执行</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dl_interp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span> =</span> dlopen_chk(path);<br>  <span class="hljs-type">int</span> (*entry)() = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(sym-&gt;name, <span class="hljs-string">&quot;main&quot;</span>) == <span class="hljs-number">0</span>)<br>      entry = (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)h + sym-&gt;offset);<br>  <span class="hljs-keyword">if</span> (entry) &#123;<br>    <span class="hljs-built_in">exit</span>(entry());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>找到main函数，exit(entry()) 的作用就是在程序结束时执行 main 函数，并将其返回值作为程序的退出码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen_chk</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">lib</span> =</span> dlopen(path);<br>  <span class="hljs-keyword">if</span> (!lib) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Not a valid dlib file: %s.\n&quot;</span>, path);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> lib;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> dlib *<span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dl_hdr</span> <span class="hljs-title">hdr</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dlib</span> *<span class="hljs-title">h</span>;</span><br><br>  <span class="hljs-type">int</span> fd = open(path, O_RDONLY);<br>  <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (read(fd, &amp;hdr, <span class="hljs-keyword">sizeof</span>(hdr)) &lt; <span class="hljs-keyword">sizeof</span>(hdr)) <span class="hljs-keyword">goto</span> bad;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(hdr.magic, DL_MAGIC, <span class="hljs-built_in">strlen</span>(DL_MAGIC)) != <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h = mmap(<span class="hljs-literal">NULL</span>, hdr.file_sz, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (h == (<span class="hljs-type">void</span> *)<span class="hljs-number">-1</span>) <span class="hljs-keyword">goto</span> bad;<br><br>  h-&gt;symtab = (<span class="hljs-keyword">struct</span> symbol *)((<span class="hljs-type">char</span> *)h + REC_SZ);<br>  h-&gt;path = path;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> symbol *sym = h-&gt;symtab; sym-&gt;type; sym++) &#123;<br>    <span class="hljs-keyword">switch</span> (sym-&gt;type) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: dlload(sym); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// (recursively) load</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>: sym-&gt;offset = (<span class="hljs-type">uintptr_t</span>)dlsym(sym-&gt;name); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// resolve</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// export</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> h;<br><br>bad:<br>  <span class="hljs-keyword">if</span> (fd &gt; <span class="hljs-number">0</span>) close(fd);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol><li>这里要打开.dl文件，并且把这个文件用mmap函数映射到dlbox进程的地址空间，此时其他.dl文件的代码段就会映射到dlbox进程的地址空间中，也就可以确定函数的地址了，这也就和动态链接的链接时绑定思想不谋而合。打开这个可执行程序时，h-&gt;symtab &#x3D; (struct symbol *)((char *)h + REC_SZ);这里是初始化符号表。</li><li>如果遇到.dl作为符号表项(‘+’)，则用dlload递归加载，dlload则是调用dlopen实现的。</li><li>如果遇到符号表项的某一项标记位’?’,表示引用外部符号，我们通过查表dlsym函数来填表。</li><li>可以想象，这是一个递归的过程，递归地填表。如果变量是这个main程序的函数(‘#’),我们直接可以确定该函数的地址。也就是表头的地址加上偏移。</li><li>如果这个符号是个.dl文件，则需要调用dlopen把这个文件整体映射进进程的地址空间(递归)，映射完后，所有符号的地址都会被确定，然后我们就可以遍历来填sym表了。这个sym表记录了所有符号，也是一个结构体，一开始所有的项的name字段初始化为NULL。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#&#x27;</span>: dlexport(sym-&gt;name, (<span class="hljs-type">char</span> *)h + sym-&gt;offset); <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">dlexport</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">void</span> *addr)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; LENGTH(syms); i++)<br>    <span class="hljs-keyword">if</span> (!syms[i].name[<span class="hljs-number">0</span>]) &#123;<br>      syms[i].offset = (<span class="hljs-type">uintptr_t</span>)addr; <span class="hljs-comment">// load-time offset</span><br>      <span class="hljs-built_in">strcpy</span>(syms[i].name, name);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  assert(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>如果这个符号是外部的函数，由于我们先包含.dl的库文件，所以外部符号这时候都会解析完毕，我们就可以直接填入正确的地址。</li><li>上面的思想主要是：我们在装载动态库的时候，我们不像静态链接那样可以知道这个模块是装载在哪个位置的。我们的解决方法是通过间接跳转在本模块的某个位置(这是可以确定的)，这个位置就有这个函数的地址的信息。由于我们都是按模块装载的，所以这一点并不难实现，通过添加一个sym的全局变量结构数组，在每装载一个模块(.dl)时，就把该模块的所有这个模块的export类型的变量全部填入这个sym数组中。<br>然后，有了这个sym数组，就可以开始回填到每个模块的符号表中带有(‘?’)的符号offset字段了。</li></ol></blockquote></li></ol><hr><h3 id="反思与改进-最精彩的部分"><a href="#反思与改进-最精彩的部分" class="headerlink" title="反思与改进(最精彩的部分)"></a><strong>反思与改进(最精彩的部分)</strong></h3><h5 id="一些小缺陷"><a href="#一些小缺陷" class="headerlink" title="一些小缺陷"></a>一些小缺陷</h5><ul><li>存储保护和加载位置。允许将.dl中的一部分以某个指定的权限映射到内存的某个位置—&gt;程序头表</li><li>允许自由指定加载器—&gt;加入INTERP</li><li>空间浪费 —&gt;字符串存储在常量池，统一通过“指针”访问(这也是ELF难读的原因)</li></ul><h5 id="另一个大缺陷"><a href="#另一个大缺陷" class="headerlink" title="另一个大缺陷"></a>另一个大缺陷</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><blockquote><p>一种写法，两种情况</p></blockquote><ul><li>来自于其他编译单元(静态链接)</li><li>动态链接库</li></ul><p>例如，有a.o和b.o静态链接再和lib.so动态链接,如果a.o中引用了一个外部符号foo,那么该如何判断这个符号究竟是属于哪个单元呢？如果只是简单地宏替换, call *foo(%rip),但其实这样是效率很低的。</p><h5 id="“发明”PLT-GOT"><a href="#“发明”PLT-GOT" class="headerlink" title="“发明”PLT &amp; GOT"></a>“发明”PLT &amp; GOT</h5><blockquote><p>先编译为相对于%rip的简单的call调用，在链接的时候，如果发现这是一个本单元的符号，直接相对于rip寻址；如果发现这是一个外部(动态链接)库的话，就需要plt这条entry,再把地址填上去。</p></blockquote><blockquote><p>我们的“符号表”就是Global Offset Table(GOT).</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00000000000011e0</span> &lt;printf@plt&gt;:<br>    <span class="hljs-attribute">11e0</span>:       f3 <span class="hljs-number">0</span>f <span class="hljs-number">1</span>e fa             endbr64<br>    <span class="hljs-attribute">11e4</span>:       f2 ff <span class="hljs-number">25</span> <span class="hljs-number">7</span>d <span class="hljs-number">2</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span>    bnd jmp *<span class="hljs-number">0</span>x2d7d(%rip)        # <span class="hljs-number">3</span>f68 &lt;printf@GLIBC_2.<span class="hljs-number">2</span>.<span class="hljs-number">5</span>&gt;<br>    <span class="hljs-attribute">11eb</span>:       <span class="hljs-number">0</span>f <span class="hljs-number">1</span>f <span class="hljs-number">44</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>          nopl   <span class="hljs-number">0</span>x0(%rax,%rax,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>咦，这条jmp指令不是有点熟悉吗？和我们的DSYM很相似。这不印证了我们的猜想吗？</p></blockquote><h5 id="最后一个问题：数据"><a href="#最后一个问题：数据" class="headerlink" title="最后一个问题：数据"></a>最后一个问题：数据</h5><blockquote><p>不管多少个静态库动态库，但我们的程序只有一个errno,environ,stdout。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux世界中的应用程序(构建最小的Linux)</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E4%B8%96%E7%95%8C%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F(%E6%9E%84%E5%BB%BA%E6%9C%80%E5%B0%8F%E7%9A%84Linux)/</url>
    
    <content type="html"><![CDATA[<h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><ul><li><p>加载第一个进程 （init 应用程序）</p><blockquote><p>相当于在操作系统中放置一个位于初始状态的状态机</p></blockquote></li><li><p>包含一些进程可以操纵的操作系统对象</p></li><li><p>然后 Linux 变成一个中断(系统调用)处理程序</p></li></ul><p>systemd为什么是进程树的根 (init 进程并不是 systemd)</p><h2 id="Linux-Kernel-系统调用上的发行版和应用生态"><a href="#Linux-Kernel-系统调用上的发行版和应用生态" class="headerlink" title="Linux Kernel 系统调用上的发行版和应用生态"></a>Linux Kernel 系统调用上的发行版和应用生态</h2><ul><li>系统工具 coreutils, binutils, systemd, ….</li><li>桌面系统 </li><li>应用程序</li></ul><h2 id="构建最小的Linux"><a href="#构建最小的Linux" class="headerlink" title="构建最小的Linux"></a>构建最小的Linux</h2><p>目标：把Linux内核启动起来，把minimal.S的二进制文件加载，打印HelloWorld，然后就退出。</p><p>我们真正的壁垒</p><ol><li>怎么样提出问题</li><li>怎样回答问出的问题</li></ol><p>问题：  我希望用 QEMU 在给定的 Linux 内核完成初始化后，直接执行我自己编写的、静态链接的 init 二进制文件。我应该怎么做？</p><ol><li>需要编译一个静态链接的 init 二进制文件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ gcc -<span class="hljs-keyword">static</span> -o <span class="hljs-keyword">init</span> <span class="hljs-keyword">init</span>.c<br></code></pre></td></tr></table></figure></li><li>创建一个 initramfs 文件系统，其中包含您的 init 二进制文件和任何其他必需的文件和目录。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">initramfs:<br><span class="hljs-comment"># Copy kernel and busybox from the host system</span><br>@<span class="hljs-built_in">mkdir</span> -p build/initramfs/bin<br>sudo bash -c <span class="hljs-string">&quot;cp /boot/vmlinuz build/ &amp;&amp; chmod 666 build/vmlinuz&quot;</span><br><span class="hljs-built_in">cp</span> init build/initramfs/<br><span class="hljs-built_in">cp</span> $(shell <span class="hljs-built_in">which</span> busybox) build/initramfs/bin/<br></code></pre></td></tr></table></figure></li></ol><ul><li><p>什么是 cpio </p><blockquote><p>cpio 是一个类似于 tar 的工具，用于创建和提取归档文件。最终，归档文件将输出到名为 initramfs.cpio 的文件中。这个命令通常用于创建一个自定义的 initramfs 文件系统，以便在启动时加载自定义的软件和配置文件。</p></blockquote><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> build/initramfs &amp;&amp; \<br>find . -print0 \<br>| cpio <span class="hljs-params">--null</span> -ov <span class="hljs-params">--format=newc</span> \<br>| gzip -9 &gt; <span class="hljs-string">../initramfs.cpio.gz</span><br></code></pre></td></tr></table></figure></li><li><p>什么是 initramfs</p><blockquote><p>initramfs 是一个临时文件系统，它被加载到内存中，以便在 Linux 内核初始化后提供一个初始根文件系统。这个临时的根文件系统在根文件系统挂载之前执行必要的初始化任务。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-initrd build/initramfs.cpio.gz<br></code></pre></td></tr></table></figure></li></ul><ol start="3"><li>然后，您需要在 QEMU 中将 initramfs 文件系统加载到内存中，并将 init 二进制文件设置为 init 进程。您可以使用以下命令启动 QEMU：<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">run:<br><span class="hljs-comment"># Run QEMU with the installed kernel and generated initramfs</span><br>qemu-system-x86_64 <span class="hljs-string">\</span><br>  -serial mon:stdio <span class="hljs-string">\</span><br>  -kernel build/vmlinuz <span class="hljs-string">\</span><br>  -initrd build/initramfs.cpio.gz <span class="hljs-string">\</span><br>  -machine accel=kvm:tcg <span class="hljs-string">\</span><br>  -append <span class="hljs-string">&quot;console=ttyS0 quiet rdinit=$(INIT)&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>rdinit&#x3D;init 是一个内核命令行参数，用于指定内核启动后应该运行哪个程序作为根文件系统的初始化进程。在 Linux 系统中，init 进程是所有进程的祖先进程，负责启动系统中的各种服务和进程。rdinit&#x3D;init 参数告诉内核在启动时运行名为 init 的程序作为 init 进程，这通常是指在 initramfs 文件系统中的程序。<br>如果这个init进程中途结束退出了的话，例如把这个init进程换成我们的一个minimal.S(简单的打印后退出)，那么由于init进程结束，系统会panic。init进程有着特殊的作用。</p></blockquote></li></ol><ul><li>什么是busybox<blockquote><p>Busybox是一个开源工具集，集成了许多常用的Unix工具，如ls、cat、grep、find等，可以在嵌入式系统中提供命令行界面的支持。Busybox的目标是提供一个小巧、高效的Unix工具集。</p></blockquote></li></ul><ol><li>busybox sh 就变成一个 shell</li><li>busybox ls 就执行 ls 命令</li></ol><ul><li>busybox 可以看成Linux所有程序的一个打包</li></ul><ul><li><p>init 程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (2) Run a shell on the init console</span><br><span class="hljs-variable">$BB</span> sh<br></code></pre></td></tr></table></figure><p>把 init 程序换成这个脚本后，系统启动没有 kernel panic了。<br>make run启动后，得到了一个Linux的终端，但输入 ls 命令是没有反应的。</p><blockquote><p>回想一下：系统在启动以后，只有 init 和 busybox，系统并不认识 ls 命令。可以 &#x2F;bin&#x2F;busybox ls。</p></blockquote></li><li><p>那应该怎么办？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/busybox sh</span><br><br><span class="hljs-comment"># initrd, only busybox and /init</span><br>BB=/bin/busybox<br><br><span class="hljs-comment"># (1) Print something and exit</span><br><span class="hljs-variable">$BB</span> <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\033[31mHello, OS World\033[0m&quot;</span><br><br><span class="hljs-comment"># (3) Rock&#x27;n Roll!</span><br><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-variable">$BB</span> sh<br><br><span class="hljs-built_in">mkdir</span> -p /tmp<br><span class="hljs-built_in">mkdir</span> -p /proc &amp;&amp; mount -t proc  none /proc<br><span class="hljs-built_in">mkdir</span> -p /sys  &amp;&amp; mount -t sysfs none /sys<br><span class="hljs-built_in">mknod</span> /dev/tty c 4 1<br>setsid /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1<br></code></pre></td></tr></table></figure></li><li><p>在 &#x2F;bin 目录下创建多个命令的快捷方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> cmd <span class="hljs-keyword">in</span> $(<span class="hljs-variable">$BB</span> --list); <span class="hljs-keyword">do</span><br>  <span class="hljs-variable">$BB</span> <span class="hljs-built_in">ln</span> -s <span class="hljs-variable">$BB</span> /bin/<span class="hljs-variable">$cmd</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure></li><li><p>最后回答什么是 systemd, 它为什么是进程树的根。</p><blockquote><p>在之后，会执行 &#x2F;usr&#x2F;sbin&#x2F;init<br>可以看到，这是个快捷方式，指向 &#x2F;lib&#x2F;systemd&#x2F;systemd</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码风格和定制化gdb调试</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%AE%9A%E5%88%B6%E5%8C%96gdb%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><ol><li>编程中的一些细节</li><li>调试工具的正确使用方法</li></ol><h3 id="软件的热更新DSU"><a href="#软件的热更新DSU" class="headerlink" title="软件的热更新DSU"></a>软件的热更新DSU</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRINGIFY(s) #s</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TOSTRING(s)  STRINGIFY(s)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">padding</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;.fill &quot;</span> TOSTRING(PADDING) <span class="hljs-string">&quot;, 1, 0x90&quot;</span></span><br><span class="hljs-params">  )</span>;<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In old function %s\n&quot;</span>, __func__);<br>&#125;<br><br>__attribute__((noinline)) <span class="hljs-type">void</span> <span class="hljs-title function_">foo_new</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In new function %s\n&quot;</span>, __func__);<br>&#125;<br><br><span class="hljs-comment">// 48 b8 (64-bit imm)   movabs $imm,%rax</span><br><span class="hljs-comment">// ff e0                jmpq   *%rax</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> PATCH[] = <span class="hljs-string">&quot;\x48\xb8--------\xff\xe0&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">DSU</span><span class="hljs-params">(<span class="hljs-type">void</span> *func, <span class="hljs-type">void</span> *func_new)</span> &#123;<br>  <span class="hljs-type">int</span> flag = PROT_WRITE | PROT_READ | PROT_EXEC, rc, np;<br><br>  <span class="hljs-comment">// Grant write permission to the memory</span><br>  <span class="hljs-comment">// We must handle boundary cases</span><br>  <span class="hljs-type">uintptr_t</span> fn = (<span class="hljs-type">uintptr_t</span>)func;<br>  <span class="hljs-type">uintptr_t</span> base = fn &amp; ~<span class="hljs-number">0xfff</span>;<br>  <span class="hljs-keyword">if</span> (fn + <span class="hljs-keyword">sizeof</span>(PATCH) &gt; base + <span class="hljs-number">4096</span>) &#123;<br>    np = <span class="hljs-number">2</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    np = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;np = %d\n&quot;</span>, np);<br><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, flag);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>  <br>  <span class="hljs-comment">// Patch the first instruction (this is UB in C spec)</span><br>  <span class="hljs-built_in">memcpy</span>(func, PATCH, <span class="hljs-keyword">sizeof</span>(PATCH));<br>  <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span> *)func + <span class="hljs-number">2</span>, &amp;func_new, <span class="hljs-keyword">sizeof</span>(func_new));<br><br>  <span class="hljs-comment">// Revoke the write permission</span><br>  rc = mprotect((<span class="hljs-type">void</span> *)base, np * <span class="hljs-number">4096</span>, PROT_READ | PROT_EXEC);<br>  assert(rc == <span class="hljs-number">0</span>);  <span class="hljs-comment">// Not expecting a failure</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br>  foo();<br>  DSU(foo, foo_new);  <span class="hljs-comment">// Dynamic software update</span><br>  foo();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一些编程小技巧"><a href="#一些编程小技巧" class="headerlink" title="一些编程小技巧"></a>一些编程小技巧</h4><ul><li><p>什么是 __func__？</p><blockquote><p><strong>func</strong> 是C语言中的一个内置宏，它返回当前函数的名称作为一个字符串常量。它可以用于调试和错误报告，以便在程序出错时能够更容易地确定错误发生在哪个函数中。<br>相当于：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">my_function</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __func__ <span class="hljs-string">&quot;my_func&quot;</span></span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current function: %s\n&quot;</span>, __func__);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> __func__ </span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 <strong>func</strong> 宏不需要包含任何头文件，因为它是C语言的内置宏，可以直接在代码中使用。</p></blockquote></li><li><p>使用 assert 断言</p><blockquote><p>有利于 bug 的定位</p></blockquote></li></ul><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><ul><li><p>为什么要把函数设置成 inline?<br>内联函数（inline function）是一种编译器提供的优化手段，它的本质是将函数在调用处展开，从而避免了函数调用的开销。也就是说，内联函数不是真正的函数调用，而是将函数的代码嵌入到调用处，类似于宏替换。</p></li><li><p>打一个小补丁</p><blockquote><p>我们知道，在调用一个函数的时候，首先 call foo, 把返回地址压栈，并跳转到foo函数处，然后再在foo函数那里给上一个补丁。</p></blockquote><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">movabs <span class="hljs-built_in">$imm</span> , <span class="hljs-built_in">%rax</span><br>jump *(rax)<br></code></pre></td></tr></table></figure><p>%rax是 foo_new函数的地址，因为foo_new函数最后也会调用 ret 指令，所以结束后返回到原来的地方。</p></li></ul><h3 id="用好工具"><a href="#用好工具" class="headerlink" title="用好工具"></a>用好工具</h3><ul><li>如何让gdb以更友好的方式帮我们打印相关的信息？<br>计算机公理3：让你感到不适的 tedious 工作，一定有办法提高效率。</li></ul><blockquote><p>用python写一个脚本，增加一个自定义的gdb命令</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gdb<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>REGS = [<br>    <span class="hljs-string">&#x27;rax&#x27;</span>, <span class="hljs-string">&#x27;rbx&#x27;</span>, <span class="hljs-string">&#x27;rcx&#x27;</span>, <span class="hljs-string">&#x27;rdx&#x27;</span>,<br>    <span class="hljs-string">&#x27;rbp&#x27;</span>, <span class="hljs-string">&#x27;rsp&#x27;</span>, <span class="hljs-string">&#x27;rsi&#x27;</span>, <span class="hljs-string">&#x27;rdi&#x27;</span>,<br>    <span class="hljs-string">&#x27;r8&#x27;</span>, <span class="hljs-string">&#x27;r9&#x27;</span>, <span class="hljs-string">&#x27;r10&#x27;</span>, <span class="hljs-string">&#x27;r11&#x27;</span>,<br>]<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RegDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(RegDump, self).__init__(<br>            <span class="hljs-string">&quot;rdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, arg, _</span>):<br>        <span class="hljs-comment"># 得到变量 ctx 的值</span><br>        <span class="hljs-comment"># 每次输入 rdump 命令会执行 invoke 函数</span><br>        ctx = gdb.parse_and_eval(<span class="hljs-string">f&#x27;ctx&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(REGS):<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;r.upper():<span class="hljs-number">3</span>&#125;</span> = <span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(ctx[r]):016x&#125;</span>&#x27;</span>,<br>                end=[<span class="hljs-string">&#x27;  &#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>][i % <span class="hljs-number">2</span>]<br>            )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>RegDump()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_source_line</span>(<span class="hljs-params">address</span>):<br>    <span class="hljs-comment"># by GPT-4</span><br><br>    <span class="hljs-comment"># Find the source code line corresponding to the given address</span><br>    symtab_and_line = gdb.find_pc_line(address)<br><br>    <span class="hljs-comment"># Check if the source code line was found</span><br>    <span class="hljs-keyword">if</span> symtab_and_line.symtab <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Get the source file name and line number</span><br>        filename = symtab_and_line.symtab.filename<br>        line_number = symtab_and_line.line<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Path(filename).name&#125;</span>:<span class="hljs-subst">&#123;line_number&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Source code line not found&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProcDump</span>(gdb.Command):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ProcDump, self).__init__(<br>            <span class="hljs-string">&quot;pdump&quot;</span>, gdb.COMMAND_DATA, gdb.COMPLETE_SYMBOL<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, *_</span>):<br>        n = gdb.parse_and_eval(<span class="hljs-string">f&#x27;NTASK&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            tsk = gdb.parse_and_eval(<span class="hljs-string">f&#x27;tasks[<span class="hljs-subst">&#123;i&#125;</span>]&#x27;</span>)<br>            pc = <span class="hljs-built_in">int</span>(tsk[<span class="hljs-string">&#x27;context&#x27;</span>][<span class="hljs-string">&#x27;rip&#x27;</span>])<br>            is_current = <span class="hljs-built_in">int</span>(<br>                gdb.parse_and_eval(<span class="hljs-string">f&#x27;&amp;tasks[<span class="hljs-subst">&#123;i&#125;</span>] == current&#x27;</span>)<br>            )<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;Proc-<span class="hljs-subst">&#123;i&#125;</span><span class="hljs-subst">&#123;<span class="hljs-string">&quot; *&quot;</span>[is_current]&#125;</span> &#x27;</span>,<br>                get_source_line(pc)<br>            )<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">40</span>)<br><br>ProcDump()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程地址空间</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux进程的地址空间"><a href="#Linux进程的地址空间" class="headerlink" title="Linux进程的地址空间"></a>Linux进程的地址空间</h2><p>有什么工具可以来查看进程的地址空间</p><ol><li>pmap</li><li>cat &#x2F;proc&#x2F; [pid] &#x2F; maps</li><li>gdb</li><li>readelf</li><li>objdump</li></ol><p>有的程序刚开始执行就结束了(比如打印一个东西就退出)，如果要查看这个进程的地址空间。那怎么办？</p><blockquote><p>使用gdb。<br>使用gdb命令 info inferiors得到进程的pid</p></blockquote><ul><li>该命令打印gdb当前管理的inferiors列表，每个inferior都有自己的不同地址空间，inferior与进程对应。</li></ul><ol><li><p>得到进程的pid后,使用命令 !pmap [pid], 在gdb中使用shell命令需要在前面加上 ！。</p></li><li><p>同样，在gdb中，还可以使用 !cat &#x2F;proc&#x2F; [pid] &#x2F;maps来查看进程的地址空间。</p></li></ol><ul><li>其实pmap就是使用系统中的 &#x2F;proc&#x2F;[pid]&#x2F;这个文件实现的。<br>怎么证明呢？<blockquote><p>使用 strace   strace pmap [pid]</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>gdb调试starti之后，查看进程的地址空间：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">8</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>     <span class="hljs-number">16</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>              <span class="hljs-number">416</span>K<br></code></pre></td></tr></table></figure><p>我们还发现，在按下starti后，有一条信息：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fe32b0 in _start () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib64/</span>ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>说明动态链接的第一条指令在&#x2F;lib64&#x2F;ld-linux-x86-64.so.2中，甚至在地址空间中此时也没有libc这个库。<br>在状态机在刚刚被初始化的一瞬间，在进程里面还没有printf。</p><blockquote><p>动态链接的ELF文件中，有一个INTERP, 就是这里的ld-linux-x86-64.so.2, 需要另外一个程序，才能执行现在这个程序，对于动态链接来说，这就是加载器。</p></blockquote><p>再在main函数上打个断点，continue后再打印一次进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000555555554000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555555000</span>      <span class="hljs-number">4</span>K r-x-- a.out<br><span class="hljs-attribute">0000555555556000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555557000</span>      <span class="hljs-number">4</span>K r---- a.out<br><span class="hljs-attribute">0000555555558000</span>      <span class="hljs-number">4</span>K rw--- a.out<br><span class="hljs-attribute">00007ffff7d7f000</span>     <span class="hljs-number">12</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7d82000</span>    <span class="hljs-number">160</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7daa000</span>   <span class="hljs-number">1620</span>K r-x-- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f3f000</span>    <span class="hljs-number">352</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f97000</span>     <span class="hljs-number">16</span>K r---- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9b000</span>      <span class="hljs-number">8</span>K rw--- libc.so.<span class="hljs-number">6</span><br><span class="hljs-attribute">00007ffff7f9d000</span>     <span class="hljs-number">52</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbb000</span>      <span class="hljs-number">8</span>K rw---  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fbd000</span>     <span class="hljs-number">16</span>K r----  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc1000</span>      <span class="hljs-number">8</span>K r-x--  <span class="hljs-meta"> [ anon ]</span><br><span class="hljs-attribute">00007ffff7fc3000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fc5000</span>    <span class="hljs-number">168</span>K r-x-- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7fef000</span>     <span class="hljs-number">44</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffb000</span>      <span class="hljs-number">8</span>K r---- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffff7ffd000</span>      <span class="hljs-number">8</span>K rw--- ld-linux-x86-<span class="hljs-number">64</span>.so.<span class="hljs-number">2</span><br><span class="hljs-attribute">00007ffffffdd000</span>    <span class="hljs-number">136</span>K rw---  <span class="hljs-meta"> [ stack ]</span><br> <span class="hljs-attribute">total</span>             <span class="hljs-number">2644</span>K<br></code></pre></td></tr></table></figure><p>如上，我们发现libc已经有了。加载器也还在，未来可能还需要这个加载器加载其他动态链接库。</p><h4 id="其他小细节"><a href="#其他小细节" class="headerlink" title="其他小细节"></a>其他小细节</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> main&#123;<br><span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在库都加载完成后，用 !cat &#x2F;proc&#x2F;14776&#x2F;&#x2F;maps 查看该进程的地址空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">7ffff7fbd000</span>-<span class="hljs-number">7</span>ffff7fc1000 r--p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vvar]</span><br><br><span class="hljs-attribute">7ffff7fc1000</span>-<span class="hljs-number">7</span>ffff7fc3000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                         <span class="hljs-meta"> [vdso]</span><br><br></code></pre></td></tr></table></figure><p>我们发现这两行， vvar 和 vdso 是什么？</p><blockquote><p>不进入内核的系统调用。<br>vvar is a memory region that contains kernel variables that are frequently accessed by user-space programs. These variables are read-only and can be accessed directly by the user-space programs without making a system call.<br>例如<br>当前的时间， 系统页面大小<br>vdso is a memory region that contains a small shared library provided by the kernel. This library contains a set of functions that are commonly used by user-space programs and can be excuted directly in user mode, without the need for a system call.</p></blockquote><h3 id="进程地址空间的管理"><a href="#进程地址空间的管理" class="headerlink" title="进程地址空间的管理"></a>进程地址空间的管理</h3><p>操作系统应该提供一个修改进程地址空间的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 映射</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br><br><span class="hljs-comment">// 修改映射权限</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>本质：在状态机状态上增加&#x2F;删除&#x2F;修改一段可访问的内存</p><ul><li>mmap: 可以用来申请内存 (MAP_ANONYMOUS)，也可以把文件 “搬到” 进程地址空间中</li></ul><p>一小段示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GiB * (1024LL * 1024 * 1024)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span> *p = mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-number">8</span> GiB, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;mmap: %lx\n&quot;</span>, (<span class="hljs-type">uintptr_t</span>)p);<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">intptr_t</span>)p == <span class="hljs-number">-1</span>) &#123;<br>    perror(<span class="hljs-string">&quot;cannot map&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  *(p + <span class="hljs-number">2</span> GiB) = <span class="hljs-number">1</span>;<br>  *(p + <span class="hljs-number">4</span> GiB) = <span class="hljs-number">2</span>;<br>  *(p + <span class="hljs-number">7</span> GiB) = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">4</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">6</span> GiB));<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read get: %d\n&quot;</span>, *(p + <span class="hljs-number">7</span> GiB));<br>&#125;<br></code></pre></td></tr></table></figure><p>疑问：这个程序运行会不会需要很长的时间，因为它分配了那么多的内存？</p><blockquote><p>其实一瞬间就完成了。也就是说，在使用mmap的时候，只是在操作系统中标记了这个进程这么多的内存，这个进程中这些内存还并没有开始分配，只是在后面用到了才会产生缺页中断。</p></blockquote><h3 id="入侵地址空间"><a href="#入侵地址空间" class="headerlink" title="入侵地址空间"></a>入侵地址空间</h3><p>进程 (M,  R 状态机) 在 “无情执行指令机器” 上执行</p><ul><li>状态机是一个封闭世界</li><li>但如果允许一个进程对其他进程的地址空间有访问权？</li></ul><p>一些入侵地址空间的例子</p><ol><li>调试器(gdb)</li></ol><ul><li>gdb 可以任意观测和修改程序的状态</li></ul><ol start="2"><li>Profiler (perf)</li></ol><h4 id="入侵进程地址空间-1-金山游侠"><a href="#入侵进程地址空间-1-金山游侠" class="headerlink" title="入侵进程地址空间 (1): 金山游侠"></a>入侵进程地址空间 (1): 金山游侠</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_WATCH 65536</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> &#123;</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;  <span class="hljs-comment">// Name of the binary</span><br>  <span class="hljs-type">int</span> pid;           <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-type">int</span> memfd;         <span class="hljs-comment">// Address space of the process</span><br>  <span class="hljs-type">int</span> bits;          <span class="hljs-comment">// Search bit-width (16, 32, or 64)</span><br>  <span class="hljs-type">bool</span> has_watch;    <span class="hljs-comment">// Watched values</span><br>  <span class="hljs-type">uintptr_t</span> watch[MAX_WATCH];<br>&#125;;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span>;<br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint32_t</span> val)</span> &#123;<br>  <span class="hljs-type">uintptr_t</span> start, kb;<br>  <span class="hljs-type">char</span> perm[<span class="hljs-number">16</span>];<br>  FILE *fp = popens(<span class="hljs-string">&quot;pmap -x $(pidof %s) | tail -n +3&quot;</span>, g-&gt;name);<br>  <span class="hljs-type">int</span> nmatch = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%lx&quot;</span>, &amp;start) == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fscanf</span>(fp, <span class="hljs-string">&quot;%ld%*ld%*ld%s%*[^\n]s&quot;</span>, &amp;kb, perm);<br>    <span class="hljs-keyword">if</span> (perm[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// Non-writable areas</span><br><br>    <span class="hljs-type">uintptr_t</span> size = kb * <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for brevity</span><br>    lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>    size = read(g-&gt;memfd, mem, size);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Scanning %lx--%lx\n&quot;</span>, start, start + size);<br><br>    <span class="hljs-keyword">if</span> (!g-&gt;has_watch) &#123;<br>      <span class="hljs-comment">// First-time search; scan all memory</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> off = <span class="hljs-number">0</span>; off &lt; size; off += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>        <span class="hljs-keyword">if</span> (v == val &amp;&amp; nmatch &lt; MAX_WATCH) &#123;<br>          g-&gt;watch[nmatch++] = start + off;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Search in the watched values</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>        <span class="hljs-type">intptr_t</span> off = g-&gt;watch[i] - start;<br>        <span class="hljs-keyword">if</span> (g-&gt;watch[i] &amp;&amp; <span class="hljs-number">0</span> &lt;= off &amp;&amp; off &lt; size) &#123;<br>          <span class="hljs-type">uint64_t</span> v = mem_load(mem, off, g-&gt;bits);<br>          <span class="hljs-keyword">if</span> (v == val) nmatch++;<br>          <span class="hljs-keyword">else</span> g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(mem);<br>  &#125;<br>  pclose(fp);<br><br>  <span class="hljs-keyword">if</span> (nmatch &gt; <span class="hljs-number">0</span>) &#123;<br>    g-&gt;has_watch = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d match(es).\n&quot;</span>, nmatch);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">overwrite</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">uint64_t</span> val)</span> &#123;<br>  <span class="hljs-type">int</span> nwrite = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++)<br>    <span class="hljs-keyword">if</span> (g-&gt;watch[i]) &#123;<br>      lseek(g-&gt;memfd, g-&gt;watch[i], SEEK_SET);<br>      write(g-&gt;memfd, &amp;val, g-&gt;bits / <span class="hljs-number">8</span>);<br>      nwrite++;<br>    &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d value(s) written.\n&quot;</span>, nwrite);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_WATCH; i++) &#123;<br>    g-&gt;watch[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  g-&gt;has_watch = <span class="hljs-literal">false</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Search for %d-bit values in %s.\n&quot;</span>, g-&gt;bits, g-&gt;name);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">load_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span> &#123;<br>  FILE *pid_fp;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  g-&gt;name = name;<br>  g-&gt;bits = <span class="hljs-number">32</span>;<br>  reset(g);<br><br>  pid_fp = popens(<span class="hljs-string">&quot;pidof %s&quot;</span>, g-&gt;name);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fscanf</span>(pid_fp, <span class="hljs-string">&quot;%d&quot;</span>, &amp;g-&gt;pid) != <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Panic: fail to get pid of \&quot;%s\&quot;.\n&quot;</span>, g-&gt;name);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>release:<br>  <span class="hljs-keyword">if</span> (pid_fp) pclose(pid_fp);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">close_game</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> game *g)</span> &#123;<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &gt;= <span class="hljs-number">0</span>) &#123;<br>    close(g-&gt;memfd);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>  <span class="hljs-type">long</span> val;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">game</span> <span class="hljs-title">game</span>;</span><br><br>  <span class="hljs-keyword">if</span> (load_game(&amp;game, argv[<span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (!feof(<span class="hljs-built_in">stdin</span>)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(%s %d) &quot;</span>, game.name, game.pid);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">goto</span> release;<br><br>    <span class="hljs-keyword">switch</span> (buf[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>: <span class="hljs-keyword">goto</span> release; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); game.bits = val; reset(&amp;game); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); scan(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;w&#x27;</span>: <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>, &amp;val); overwrite(&amp;game, val); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>: reset(&amp;game); <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>release:<br>  close_game(&amp;game);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>FILE* <span class="hljs-title function_">popens</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span> &#123;<br>  <span class="hljs-type">char</span> cmd[<span class="hljs-number">128</span>];<br>  va_list args;<br>  va_start(args, fmt);<br>  vsnprintf(cmd, <span class="hljs-keyword">sizeof</span>(cmd), fmt, args);<br>  va_end(args);<br>  FILE *ret = popen(cmd, <span class="hljs-string">&quot;r&quot;</span>);<br>  assert(ret);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">mem_load</span><span class="hljs-params">(<span class="hljs-type">char</span> *mem, <span class="hljs-type">int</span> off, <span class="hljs-type">int</span> bits)</span> &#123;<br>  <span class="hljs-type">uint64_t</span> val = *(<span class="hljs-type">uint64_t</span> *)(&amp;mem[off]);<br>  <span class="hljs-keyword">switch</span> (bits) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: val &amp;= <span class="hljs-number">0xffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: val &amp;= <span class="hljs-number">0xffffffff</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>: <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码导读</p><ul><li>va_list，va_start()、va_arg() 和 va_end() 是什么<blockquote><p>这可以使C语言实现变长参数。</p><blockquote><p>va_list 是一个类型，用于表示可变参数列表。<br>va_start() 宏用于初始化可变参数列表<br>va_arg() 宏用于访问可变参数列表中的下一个参数<br>va_end() 宏用于结束可变参数列表的访问</p></blockquote></blockquote></li><li>一段小例子<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdarg.h&gt;</span></span><br><br><span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">int</span> count, ...)</span> &#123;<br>    va_list ap;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">double</span> total = <span class="hljs-number">0.0</span>;<br><br>    va_start(ap, count); <span class="hljs-comment">// 初始化可变参数列表</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        total += va_arg(ap, <span class="hljs-type">double</span>); <span class="hljs-comment">// 获取下一个参数</span><br>    &#125;<br><br>    va_end(ap); <span class="hljs-comment">// 结束可变参数列表</span><br><br>    <span class="hljs-keyword">return</span> total / count;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">double</span> avg = average(<span class="hljs-number">5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">5.0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;平均值为：%f\n&quot;</span>, avg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>popen函数</p><blockquote><p>popen()会调用fork()产生子进程，然后从子进程中调用&#x2F;bin&#x2F;sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。</p></blockquote></blockquote></li><li>也就是说，首先获取游戏进程的名字后，先创建一个子进程执行 pidof [name]的命令，可以获取游戏进程pid。然后fscanf(pid_fp, “%d”, &amp;g-&gt;pid) !&#x3D; 1读取该进程pid。<br>接着打开&#x2F;proc&#x2F;[pid]&#x2F;mem这个文件。g-&gt;memfd指向这个文件。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-string">&quot;/proc/%d/mem&quot;</span>, g-&gt;pid);<br>  g-&gt;memfd = open(buf, O_RDWR);<br>  <span class="hljs-keyword">if</span> (g-&gt;memfd &lt; <span class="hljs-number">0</span>) &#123;<br>    perror(<span class="hljs-string">&quot;/proc/[pid]/mem&quot;</span>);<br>    ret = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">goto</span> release;<br>  &#125;<br><br></code></pre></td></tr></table></figure></li><li>scan函数<br>在用pmap得到虚拟地址区域后，就可以把这个区域映射到入侵程序的地址空间中，并得到起始地址。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *mem = <span class="hljs-built_in">calloc</span>(size + <span class="hljs-number">16</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// Ignores error handling for </span><br></code></pre></td></tr></table></figure></li><li>之后把 &#x2F;proc&#x2F;pid&#x2F;mem的文件偏移设为虚拟地址区域起始处。</li></ul><ul><li>如果想要在&#x2F;proc&#x2F;pid&#x2F;mem 文件访问进程的虚拟地址 0x12345678，您需要将文件偏移量设置为 0x12345678。<br>并把这个区域的内存全部写入入侵进程的地址空间中。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">lseek(g-&gt;memfd, start, SEEK_SET);  <span class="hljs-comment">// Don&#x27;t do this in production!</span><br>size = read(g-&gt;memfd, mem, size);<br></code></pre></td></tr></table></figure></li></ul><ul><li>然后就可以根据偏移，可以把相应的地址对应起来了。大致意思就是在入侵地址里暴力寻找符合条件的地址，然后根据找的的符合条件的地址，由于偏移是一样的，也就可以把这个地址对应到被入侵进程的相应虚拟地址区域中了。</li></ul><h4 id="入侵进程地址空间-2-变速齿轮"><a href="#入侵进程地址空间-2-变速齿轮" class="headerlink" title="入侵进程地址空间 (2): 变速齿轮"></a>入侵进程地址空间 (2): 变速齿轮</h4><p>用修改程序系统调用的手段来欺骗程序对时间的认识，就可以实现游戏的加速和减速。</p><ul><li><p>简单的一段C程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> hp = <span class="hljs-number">10000</span>;<br><br>__attribute__((noinline)) <span class="hljs-type">int</span> <span class="hljs-title function_">hit</span><span class="hljs-params">(<span class="hljs-type">int</span> damage)</span> &#123;<br>  <span class="hljs-keyword">return</span> hp - damage;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    hp = hit(rand() % <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hp = %d\n&quot;</span>, hp);<br>    usleep(<span class="hljs-number">10000</span>);<br>    <span class="hljs-keyword">if</span> (hp &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Game Over\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>python 脚本</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> argv<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(argv) &lt; <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Usage <span class="hljs-subst">&#123;argv[<span class="hljs-number">0</span>]&#125;</span> [--hp] [--fast] [--slow]&#x27;</span>)<br>    exit(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">addr, patch</span>):<br>    pid = <span class="hljs-built_in">int</span>(subprocess.check_output([<span class="hljs-string">&#x27;pidof&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]))<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;/proc/<span class="hljs-subst">&#123;pid&#125;</span>/mem&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        fp.seek(addr)<br>        fp.write(patch)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">symbol</span>):<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> subprocess.check_output([<span class="hljs-string">&#x27;nm&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>]).splitlines():<br>        tokens = line.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).split()<br>        <span class="hljs-keyword">if</span> tokens[-<span class="hljs-number">2</span>:] == [<span class="hljs-string">&#x27;T&#x27;</span>, symbol]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(tokens[<span class="hljs-number">0</span>], base=<span class="hljs-number">16</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--hp&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># hit -&gt; mov $9999999, %eax; ret</span><br>    patch(name(<span class="hljs-string">&#x27;hit&#x27;</span>), <span class="hljs-string">b&#x27;\xb8\x7f\x96\x98\x00\xc3&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--slow&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shl $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xe7\x04&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;--fast&#x27;</span> <span class="hljs-keyword">in</span> argv:<br>    <span class="hljs-comment"># usleep (endbr64) -&gt; shr $0x4, %rdi</span><br>    patch(name(<span class="hljs-string">&#x27;usleep&#x27;</span>), <span class="hljs-string">b&#x27;\x48\xc1\xef\x04&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fork的应用</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/fork%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><ul><li>fork状态机复制，包括持有的所有操作系统对象(如文件描述符)</li><li>execve重置状态机，但继承持有的所有操作系统的对象</li><li>例如在fork之前打开一个管道, 然后就可以把一部分计算的输出管道给另外一个进程的输入</li></ul><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure><ul><li>RTFM: O_CLOEXEC : execve时文件描述符不应该被继承； O_APPEND：以追加的方式写该文件</li><li>对于数据文件，文件描述符会记住上次访问的位置</li><li>dup：复制一个文件描述符，进程有两个fd指向同一个文件，并且具有同一个offset</li></ul><h2 id="回到fork-复制，但又没有完全复制"><a href="#回到fork-复制，但又没有完全复制" class="headerlink" title="回到fork, 复制，但又没有完全复制"></a>回到fork, 复制，但又没有完全复制</h2><p>概念上状态机被复制，但实际上复制后内存都共享</p><ul><li>“Copy on Write”只有被写入的页面才会复制一份<ol><li>被复制后，整个地址空间都被标记位”只读”</li><li>操作系统捕获Page Fault后酌情复制页面</li><li>操作系统会维护每个页面的引用计数</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C标准库和实现</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/C%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="我们该如何学习-C-标准库"><a href="#我们该如何学习-C-标准库" class="headerlink" title="我们该如何学习 C 标准库?"></a>我们该如何学习 C 标准库?</h2><ul><li><del>直接调试 glibc (像我们上课那样)</del></li><li>寻找更好的替代品，一定有为嵌入式设备实现的简化 libc。<blockquote><p>选择 musl<br>musl是一个轻量级的C标准库，它专注于提供高效、可靠和安全的C语言运行时环境。musl库的设计目标是遵循POSIX标准，同时保持代码的简洁和易于维护。它主要用于嵌入式系统、轻量级容器和其他类似的应用程序中，因为它比其他标准库更小、更快、更安全，并且不包含任何专有代码或许可证限制。在某些情况下，它也可以用作替代glibc的标准库。</p></blockquote></li></ul><ul><li>那怎么编译一个 C 程序用 musl 作为 libc 而不是用 glibc呢 ？<ol><li>sudo apt-get install musl-tools</li><li>编写C程序，包含 stdio.h 头文件</li><li>musl-gcc -o hello hello.c</li></ol></li></ul><h2 id="libc-的基本功能"><a href="#libc-的基本功能" class="headerlink" title="libc 的基本功能"></a>libc 的基本功能</h2><ul><li>基础数据的体系结构无关抽象</li></ul><ul><li>inttypes.h</li></ul><ul><li>字符串和数组操作</li></ul><h2 id="操作系统对象与环境"><a href="#操作系统对象与环境" class="headerlink" title="操作系统对象与环境"></a>操作系统对象与环境</h2><ul><li><p>环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> **environ;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> **env = environ; *env; env++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, *env);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>environ是一个字符指针的指针。</p></li><li><p>environ是谁赋值的？</p></li></ul><p>gdb调试<br>第一条指令的时候 environ 还没有被赋值。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span>x00007ffff7fc7bfe in _dlstart () <span class="hljs-keyword">from</span> <span class="hljs-regexp">/lib/</span>ld-musl-x86_64.so.<span class="hljs-number">1</span><br>(gdb) p(<span class="hljs-keyword">char</span>*) environ<br>$<span class="hljs-number">1</span> = <span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>而在main函数的时候，environ是有正确的值的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>__libc_start_main函数<br>char **envp = argv + argc + <span class="hljs-number">1</span>;<br>.....<br>.....<br><span class="hljs-regexp">//</span>__init_libc函数<br>environ = envp<br></code></pre></td></tr></table></figure><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用视角的操作系统</title>
    <link href="/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/08/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/jyy%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%BA%94%E7%94%A8%E8%A7%86%E8%A7%92%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："><a href="#本讲内容：指令序列和高级语言的状态机模型；回答以下问题：" class="headerlink" title="本讲内容：指令序列和高级语言的状态机模型；回答以下问题："></a>本讲内容：指令序列和高级语言的状态机模型；回答以下问题：</h2><ul><li>什么是软件 (程序)？</li><li>如何在操作系统上构造最小&#x2F;一般&#x2F;图形界面应用程序？</li><li>什么是编译器？编译器把一段程序翻译成什么样的指令序列才算 “正确”？</li></ul><h2 id="构建一个最小的程序"><a href="#构建一个最小的程序" class="headerlink" title="构建一个最小的程序"></a>构建一个最小的程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="gcc-编译出来的文件一点也不小"><a href="#gcc-编译出来的文件一点也不小" class="headerlink" title="gcc 编译出来的文件一点也不小"></a>gcc 编译出来的文件一点也不小</h3><ol><li>objdump 工具可以查看对应的汇编代码</li><li>–verbose 可以查看所有编译选项 (真不少)</li><li>printf 变成了 puts@plt</li><li>-Wl,–verbose 可以查看所有链接选项 (真不少)<br>原来链接了那么多东西<br>还解释了 end 符号的由来</li><li>-static 会链接 libc (大量的代码)<blockquote><p>gcc a.c 和 gcc a.c -static 有什么区别？</p></blockquote></li></ol><h3 id="强行构造最小的-Hello-World？"><a href="#强行构造最小的-Hello-World？" class="headerlink" title="强行构造最小的 Hello, World？"></a>强行构造最小的 Hello, World？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c hello<span class="hljs-selector-class">.c</span>    -&gt; hello<span class="hljs-selector-class">.o</span> <br>ld hello<span class="hljs-selector-class">.o</span> -e <span class="hljs-selector-tag">main</span>   -&gt; <span class="hljs-selector-tag">a</span>.out<br></code></pre></td></tr></table></figure><p>执行a.out,会发生Segmentation Fault.</p><p>如果改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>再继续执行上面的编译命令，发现程序可以正常执行了（死循环）。</p><blockquote><p>查看汇编语言，猜测程序返回时的 ret 出现了错误。</p></blockquote><h3 id="解决异常退出"><a href="#解决异常退出" class="headerlink" title="解决异常退出"></a>解决异常退出</h3><blockquote><p>解决办法：用一条特殊的指令请操作系统帮忙</p></blockquote><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">movq $SYS_exit,  %rax   <span class="hljs-comment"># exit(</span><br>movq $1,         %rdi   <span class="hljs-comment">#   status=1</span><br><span class="hljs-keyword">syscall</span>                 <span class="hljs-comment"># );</span><br></code></pre></td></tr></table></figure><ul><li>把 “系统调用” 的参数放到寄存器中</li><li>执行 syscall，操作系统接管程序<ul><li>程序把控制权完全交给操作系统</li><li>操作系统可以改变程序状态甚至终止程序</li></ul></li></ul><h2 id="理解高级编程语言程序"><a href="#理解高级编程语言程序" class="headerlink" title="理解高级编程语言程序"></a>理解高级编程语言程序</h2><blockquote><p>编程语言也是一个状态机</p></blockquote><ul><li>非递归的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> pc, n;<br>  <span class="hljs-type">char</span> from, to, via;<br>&#125; Frame;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> call(...) (&#123; *(++top) = (Frame) &#123; .pc = 0, __VA_ARGS__ &#125;; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ret()     (&#123; top--; &#125;)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> goto(loc) (&#123; f-&gt;pc = (loc) - 1; &#125;)</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  Frame stk[<span class="hljs-number">64</span>], *top = stk - <span class="hljs-number">1</span>;<br>  call(n, from, to, via);<br>  <span class="hljs-keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) &#123;<br>    n = f-&gt;n; from = f-&gt;from; to = f-&gt;to; via = f-&gt;via;<br>    <span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <br>      <span class="hljs-comment">// 为什么goto(4)只是设置pc为3，是因为循环会++</span><br><span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>什么叫函数调用<blockquote><p>函数是由很多个栈帧组成的，每一个栈帧都有一个PC</p></blockquote></li></ul><p>什么是函数调用？</p><blockquote><p> 函数调用就是在栈帧的顶部再加上一个栈帧，这个栈帧的PC是0，然后把参数放到栈上</p></blockquote><p>什么是函数返回</p><blockquote><p>  把顶部的栈给抹掉</p></blockquote><p>什么是执行一条语句</p><blockquote><p>  取最顶上栈帧PC上的语句执行</p></blockquote><ul><li>代码讲解<br>这是递归版的汉诺塔<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> via)</span> &#123;<br>  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    hanoi(n - <span class="hljs-number">1</span>, from, via, to);<br>    hanoi(<span class="hljs-number">1</span>,     from, to,  via);<br>    hanoi(n - <span class="hljs-number">1</span>, via,  to,  from);<br>  &#125;<br>  <span class="hljs-comment">// return 省略了</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>根据上面的思想，把整个hanoi函数理解成一个栈帧，每一个栈帧有一个PC，还需要参数信息</p></blockquote></li></ul><p><strong>可以理解成函数体每一条语句都是一条PC指针</strong><br>每一次循环，都会取最顶上的栈帧来操作<br>这也就是下部分的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">switch</span> (f-&gt;pc) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, from, to); <span class="hljs-keyword">goto</span>(<span class="hljs-number">4</span>); &#125; <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: call(n - <span class="hljs-number">1</span>, from, via, to);   <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: call(    <span class="hljs-number">1</span>, from, to,  via);  <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: call(n - <span class="hljs-number">1</span>, via,  to,  from); <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: ret();                        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>: assert(<span class="hljs-number">0</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="操作系统上的软件-应用程序"><a href="#操作系统上的软件-应用程序" class="headerlink" title="操作系统上的软件 (应用程序)"></a>操作系统上的软件 (应用程序)</h2><blockquote><p>任何程序 &#x3D; minimal.S &#x3D; 调用 syscall 的状态机</p></blockquote><p>可执行文件是操作系统中的对象</p><ul><li><p>与大家日常使用的文件 (a.c, README.txt) 没有本质区别</p></li><li><p>操作系统提供 API 打开、读取、改写 (都需要相应的权限)</p></li></ul><p>查看可执行文件</p><ul><li>vim, cat, xxd 都可以直接 “查看” 可执行文件</li><li>vim 中二进制的部分无法 “阅读”，但可以看到字符串常量</li><li>使用 xxd 可以看到文件以 “\x7f” “ELF” 开头</li><li>Vscode 有 binary editor 插件</li></ul><p>在 Vim 中输入 %!xxd 命令会将当前编辑的文件转换成十六进制表示，并在 Vim 中显示。这个命令的作用是将当前编辑的文件作为输入传递给 xxd 命令(%表示对整个文件执行操作)，xxd 命令会将其转换成十六进制格式，并将结果输出到标准输出流，此时 Vim 会将其读取并显示在编辑器中。</p><h2 id="动手实验：观察程序的执行"><a href="#动手实验：观察程序的执行" class="headerlink" title="动手实验：观察程序的执行"></a>动手实验：观察程序的执行</h2><p>工具程序代表：编译器 (gcc)</p><ul><li>主要的系统调用：execve, read, write</li><li>strace -f gcc a.c (gcc 会启动其他进程， -f选项会追踪所有子进程)<ul><li>可以管道给编辑器 vim -</li><li>编辑器里还可以 %!grep (细节&#x2F;技巧)</li></ul></li></ul><p>grep 命令的 -e 选项用于指定一个或多个匹配模式，这些模式可以是正则表达式或普通字符串。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">strace <span class="hljs-keyword">ls</span> |&amp; <span class="hljs-keyword">grep</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">read</span> -<span class="hljs-keyword">e</span> <span class="hljs-keyword">write</span><br></code></pre></td></tr></table></figure><p>图形界面程序代表：编辑器 (xedit)</p><ul><li>主要的系统调用：poll, recvmsg, writev</li><li>strace xedit<ul><li>图形界面程序和 X-Window 服务器按照 X11 协议通信</li><li>虚拟机中的 xedit 将 X11 命令通过 ssh (X11 forwarding) 转发到 Host</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>jyy操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jyy操作系统</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
